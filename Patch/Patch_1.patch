From a5c390b43aa9335b5cff13f65e5c5dcffa2b4c6d Mon Sep 17 00:00:00 2001
From: pavleen <pavleen03@gmail.com>
Date: Mon, 7 Apr 2014 21:52:59 -0400
Subject: [PATCH] Updated the header

---
 lmms/include/AudioAlsa.h                  |   99 +++
 lmms/include/AudioDevice.h                |  183 +++++
 lmms/include/AudioDummy.h                 |  116 +++
 lmms/include/AudioFileDevice.h            |  114 +++
 lmms/include/AudioFileOgg.h               |  107 +++
 lmms/include/AudioFileWave.h              |   84 ++
 lmms/include/AudioJack.h                  |  128 +++
 lmms/include/AudioOss.h                   |   83 ++
 lmms/include/AudioPort.h                  |  143 ++++
 lmms/include/AudioPortAudio.h             |  151 ++++
 lmms/include/AudioPulseAudio.h            |   90 +++
 lmms/include/AudioSampleRecorder.h        |   59 ++
 lmms/include/AudioSdl.h                   |   91 +++
 lmms/include/AutomatableModel.h           |  368 +++++++++
 lmms/include/AutomatableModelView.h       |  132 ++++
 lmms/include/AutomationEditor.h           |  267 +++++++
 lmms/include/AutomationPattern.h          |  190 +++++
 lmms/include/AutomationPatternView.h      |   74 ++
 lmms/include/AutomationTrack.h            |   73 ++
 lmms/include/Clipboard.h                  |   53 ++
 lmms/include/ComboBoxModel.h              |   93 +++
 lmms/include/Controller.h                 |  164 ++++
 lmms/include/ControllerConnection.h       |  117 +++
 lmms/include/ControllerConnectionDialog.h |  101 +++
 lmms/include/ControllerDialog.h           |   54 ++
 lmms/include/ControllerRackView.h         |   73 ++
 lmms/include/ControllerView.h             |   86 ++
 lmms/include/DataFile.h                   |  112 +++
 lmms/include/DetuningHelper.h             |   62 ++
 lmms/include/DspEffectLibrary.h           |  352 +++++++++
 lmms/include/DummyEffect.h                |  112 +++
 lmms/include/DummyInstrument.h            |   69 ++
 lmms/include/DummyPlugin.h                |   68 ++
 lmms/include/Effect.h                     |  231 ++++++
 lmms/include/EffectChain.h                |   83 ++
 lmms/include/EffectControlDialog.h        |   55 ++
 lmms/include/EffectControls.h             |   76 ++
 lmms/include/EffectRackView.h             |   85 ++
 lmms/include/EffectSelectDialog.h         |   70 ++
 lmms/include/EffectView.h                 |   93 +++
 lmms/include/EnvelopeAndLfoParameters.h   |  183 +++++
 lmms/include/EnvelopeAndLfoView.h         |   96 +++
 lmms/include/FileDialog.h                 |   44 ++
 lmms/include/FxMixer.h                    |  100 +++
 lmms/include/FxMixerView.h                |   84 ++
 lmms/include/ImportFilter.h               |  106 +++
 lmms/include/InlineAutomation.h           |   92 +++
 lmms/include/Instrument.h                 |  142 ++++
 lmms/include/InstrumentFunctionViews.h    |   90 +++
 lmms/include/InstrumentFunctions.h        |  211 +++++
 lmms/include/InstrumentMidiIOView.h       |   65 ++
 lmms/include/InstrumentPlayHandle.h       |   67 ++
 lmms/include/InstrumentSoundShaping.h     |   88 +++
 lmms/include/InstrumentSoundShapingView.h |   70 ++
 lmms/include/InstrumentTrack.h            |  425 ++++++++++
 lmms/include/InstrumentView.h             |   58 ++
 lmms/include/JournallingObject.h          |  185 +++++
 lmms/include/LadspaBase.h                 |   85 ++
 lmms/include/LadspaControl.h              |  120 +++
 lmms/include/LadspaControlView.h          |   48 ++
 lmms/include/LcdSpinBox.h                 |   88 +++
 lmms/include/LcdWidget.h                  |   87 ++
 lmms/include/LfoController.h              |  121 +++
 lmms/include/LmmsStyle.h                  |   97 +++
 lmms/include/MainWindow.h                 |  182 +++++
 lmms/include/MeterDialog.h                |   51 ++
 lmms/include/MeterModel.h                 |   65 ++
 lmms/include/MicroTimer.h                 |   70 ++
 lmms/include/Midi.h                       |  140 ++++
 lmms/include/MidiAlsaRaw.h                |   90 +++
 lmms/include/MidiAlsaSeq.h                |  163 ++++
 lmms/include/MidiClient.h                 |  198 +++++
 lmms/include/MidiController.h             |   84 ++
 lmms/include/MidiDummy.h                  |   81 ++
 lmms/include/MidiEvent.h                  |  210 +++++
 lmms/include/MidiEventProcessor.h         |   50 ++
 lmms/include/MidiOss.h                    |   86 ++
 lmms/include/MidiPort.h                   |  178 +++++
 lmms/include/MidiPortMenu.h               |   61 ++
 lmms/include/MidiTime.h                   |  153 ++++
 lmms/include/MidiWinMM.h                  |  155 ++++
 lmms/include/MixHelpers.h                 |   55 ++
 lmms/include/Mixer.h                      |  474 +++++++++++
 lmms/include/Model.h                      |   92 +++
 lmms/include/ModelView.h                  |   84 ++
 lmms/include/NotePlayHandle.h             |  296 +++++++
 lmms/include/Oscillator.h                 |  215 +++++
 lmms/include/PeakController.h             |   99 +++
 lmms/include/Piano.h                      |   80 ++
 lmms/include/PianoRoll.h                  |  354 +++++++++
 lmms/include/PianoView.h                  |   89 +++
 lmms/include/Pitch.h                      |   38 +
 lmms/include/PlayHandle.h                 |  106 +++
 lmms/include/Plugin.h                     |  204 +++++
 lmms/include/PluginView.h                 |   46 ++
 lmms/include/PresetPreviewPlayHandle.h    |   61 ++
 lmms/include/ProjectJournal.h             |  106 +++
 lmms/include/ProjectRenderer.h            |  118 +++
 lmms/include/RemotePlugin.h               | 1222 +++++++++++++++++++++++++++++
 lmms/include/SampleBuffer.h               |  277 +++++++
 lmms/include/SamplePlayHandle.h           |   97 +++
 lmms/include/SampleRecordHandle.h         |   72 ++
 lmms/include/SampleTrack.h                |  184 +++++
 lmms/include/SerializingObject.h          |  100 +++
 lmms/include/SideBar.h                    |   57 ++
 lmms/include/SideBarWidget.h              |   82 ++
 lmms/include/SongEditor.h                 |  140 ++++
 lmms/include/SweepOscillator.h            |   70 ++
 lmms/include/TempoSyncKnob.h              |   82 ++
 lmms/include/TempoSyncKnobModel.h         |  104 +++
 lmms/include/TimeDisplayWidget.h          |   70 ++
 lmms/include/ToolPlugin.h                 |   45 ++
 lmms/include/ToolPluginView.h             |   41 +
 lmms/include/TrackContainer.h             |  124 +++
 lmms/include/TrackContainerView.h         |  190 +++++
 lmms/include/VersionedSaveDialog.h        |   53 ++
 lmms/include/VstSyncController.h          |   99 +++
 lmms/include/VstSyncData.h                |   61 ++
 lmms/include/about_dialog.h               |   43 +
 lmms/include/aeffectx.h                   |  304 +++++++
 lmms/include/atomic_int.h                 |  103 +++
 lmms/include/automatable_button.h         |  109 +++
 lmms/include/automatable_slider.h         |   77 ++
 lmms/include/base64.h                     |   58 ++
 lmms/include/basic_filters.h              |  675 ++++++++++++++++
 lmms/include/bb_editor.h                  |   76 ++
 lmms/include/bb_track.h                   |  189 +++++
 lmms/include/bb_track_container.h         |   82 ++
 lmms/include/caption_menu.h               |   46 ++
 lmms/include/combobox.h                   |   79 ++
 lmms/include/config_mgr.h                 |  222 ++++++
 lmms/include/cpuload_widget.h             |   67 ++
 lmms/include/custom_events.h              |   46 ++
 lmms/include/debug.h                      |   42 +
 lmms/include/drumsynth.h                  |   52 ++
 lmms/include/embed.h                      |  130 +++
 lmms/include/endian_handling.h            |   53 ++
 lmms/include/engine.h                     |  205 +++++
 lmms/include/export.h                     |   47 ++
 lmms/include/export_project_dialog.h      |   75 ++
 lmms/include/fade_button.h                |   64 ++
 lmms/include/fader.h                      |  119 +++
 lmms/include/fft_helpers.h                |   85 ++
 lmms/include/fifo_buffer.h                |   88 +++
 lmms/include/file_browser.h               |  238 ++++++
 lmms/include/graph.h                      |  185 +++++
 lmms/include/group_box.h                  |   76 ++
 lmms/include/gui_templates.h              |   68 ++
 lmms/include/interpolation.h              |   94 +++
 lmms/include/knob.h                       |  174 ++++
 lmms/include/ladspa.h                     |  603 ++++++++++++++
 lmms/include/ladspa_2_lmms.h              |   78 ++
 lmms/include/ladspa_manager.h             |  338 ++++++++
 lmms/include/led_checkbox.h               |   71 ++
 lmms/include/lmms_basics.h                |  142 ++++
 lmms/include/lmms_constants.h             |   33 +
 lmms/include/lmms_math.h                  |  110 +++
 lmms/include/mmp.h                        |  113 +++
 lmms/include/note.h                       |  254 ++++++
 lmms/include/nstate_button.h              |   75 ++
 lmms/include/panning.h                    |   53 ++
 lmms/include/panning_constants.h          |   34 +
 lmms/include/pattern.h                    |  193 +++++
 lmms/include/pixmap_button.h              |   64 ++
 lmms/include/plugin_browser.h             |   87 ++
 lmms/include/project_notes.h              |   91 +++
 lmms/include/project_version.h            |   56 ++
 lmms/include/rename_dialog.h              |   61 ++
 lmms/include/rubberband.h                 |   94 +++
 lmms/include/setup_dialog.h               |  180 +++++
 lmms/include/shared_object.h              |   84 ++
 lmms/include/song.h                       |  380 +++++++++
 lmms/include/string_pair_drag.h           |   58 ++
 lmms/include/tab_bar.h                    |   88 +++
 lmms/include/tab_button.h                 |   66 ++
 lmms/include/tab_widget.h                 |   72 ++
 lmms/include/templates.h                  |   39 +
 lmms/include/text_float.h                 |   82 ++
 lmms/include/timeline.h                   |  192 +++++
 lmms/include/tool_button.h                |   82 ++
 lmms/include/tooltip.h                    |   42 +
 lmms/include/track.h                      |  610 ++++++++++++++
 lmms/include/track_label_button.h         |   61 ++
 lmms/include/transformable_auto_model.h   |   91 +++
 lmms/include/update_event.h               |   44 ++
 lmms/include/versioninfo.h                |   29 +
 lmms/include/visualization_widget.h       |   69 ++
 lmms/include/volume.h                     |   43 +
 188 files changed, 24050 insertions(+)
 create mode 100644 lmms/include/AudioAlsa.h
 create mode 100644 lmms/include/AudioDevice.h
 create mode 100644 lmms/include/AudioDummy.h
 create mode 100644 lmms/include/AudioFileDevice.h
 create mode 100644 lmms/include/AudioFileOgg.h
 create mode 100644 lmms/include/AudioFileWave.h
 create mode 100644 lmms/include/AudioJack.h
 create mode 100644 lmms/include/AudioOss.h
 create mode 100644 lmms/include/AudioPort.h
 create mode 100644 lmms/include/AudioPortAudio.h
 create mode 100644 lmms/include/AudioPulseAudio.h
 create mode 100644 lmms/include/AudioSampleRecorder.h
 create mode 100644 lmms/include/AudioSdl.h
 create mode 100644 lmms/include/AutomatableModel.h
 create mode 100644 lmms/include/AutomatableModelView.h
 create mode 100644 lmms/include/AutomationEditor.h
 create mode 100644 lmms/include/AutomationPattern.h
 create mode 100644 lmms/include/AutomationPatternView.h
 create mode 100644 lmms/include/AutomationTrack.h
 create mode 100644 lmms/include/Clipboard.h
 create mode 100644 lmms/include/ComboBoxModel.h
 create mode 100644 lmms/include/Controller.h
 create mode 100644 lmms/include/ControllerConnection.h
 create mode 100644 lmms/include/ControllerConnectionDialog.h
 create mode 100644 lmms/include/ControllerDialog.h
 create mode 100644 lmms/include/ControllerRackView.h
 create mode 100644 lmms/include/ControllerView.h
 create mode 100644 lmms/include/DataFile.h
 create mode 100644 lmms/include/DetuningHelper.h
 create mode 100644 lmms/include/DspEffectLibrary.h
 create mode 100644 lmms/include/DummyEffect.h
 create mode 100644 lmms/include/DummyInstrument.h
 create mode 100644 lmms/include/DummyPlugin.h
 create mode 100644 lmms/include/Effect.h
 create mode 100644 lmms/include/EffectChain.h
 create mode 100644 lmms/include/EffectControlDialog.h
 create mode 100644 lmms/include/EffectControls.h
 create mode 100644 lmms/include/EffectRackView.h
 create mode 100644 lmms/include/EffectSelectDialog.h
 create mode 100644 lmms/include/EffectView.h
 create mode 100644 lmms/include/EnvelopeAndLfoParameters.h
 create mode 100644 lmms/include/EnvelopeAndLfoView.h
 create mode 100644 lmms/include/FileDialog.h
 create mode 100644 lmms/include/FxMixer.h
 create mode 100644 lmms/include/FxMixerView.h
 create mode 100644 lmms/include/ImportFilter.h
 create mode 100644 lmms/include/InlineAutomation.h
 create mode 100644 lmms/include/Instrument.h
 create mode 100644 lmms/include/InstrumentFunctionViews.h
 create mode 100644 lmms/include/InstrumentFunctions.h
 create mode 100644 lmms/include/InstrumentMidiIOView.h
 create mode 100644 lmms/include/InstrumentPlayHandle.h
 create mode 100644 lmms/include/InstrumentSoundShaping.h
 create mode 100644 lmms/include/InstrumentSoundShapingView.h
 create mode 100644 lmms/include/InstrumentTrack.h
 create mode 100644 lmms/include/InstrumentView.h
 create mode 100644 lmms/include/JournallingObject.h
 create mode 100644 lmms/include/LadspaBase.h
 create mode 100644 lmms/include/LadspaControl.h
 create mode 100644 lmms/include/LadspaControlView.h
 create mode 100644 lmms/include/LcdSpinBox.h
 create mode 100644 lmms/include/LcdWidget.h
 create mode 100644 lmms/include/LfoController.h
 create mode 100644 lmms/include/LmmsStyle.h
 create mode 100644 lmms/include/MainWindow.h
 create mode 100644 lmms/include/MeterDialog.h
 create mode 100644 lmms/include/MeterModel.h
 create mode 100644 lmms/include/MicroTimer.h
 create mode 100644 lmms/include/Midi.h
 create mode 100644 lmms/include/MidiAlsaRaw.h
 create mode 100644 lmms/include/MidiAlsaSeq.h
 create mode 100644 lmms/include/MidiClient.h
 create mode 100644 lmms/include/MidiController.h
 create mode 100644 lmms/include/MidiDummy.h
 create mode 100644 lmms/include/MidiEvent.h
 create mode 100644 lmms/include/MidiEventProcessor.h
 create mode 100644 lmms/include/MidiOss.h
 create mode 100644 lmms/include/MidiPort.h
 create mode 100644 lmms/include/MidiPortMenu.h
 create mode 100644 lmms/include/MidiTime.h
 create mode 100644 lmms/include/MidiWinMM.h
 create mode 100644 lmms/include/MixHelpers.h
 create mode 100644 lmms/include/Mixer.h
 create mode 100644 lmms/include/Model.h
 create mode 100644 lmms/include/ModelView.h
 create mode 100644 lmms/include/NotePlayHandle.h
 create mode 100644 lmms/include/Oscillator.h
 create mode 100644 lmms/include/PeakController.h
 create mode 100644 lmms/include/Piano.h
 create mode 100644 lmms/include/PianoRoll.h
 create mode 100644 lmms/include/PianoView.h
 create mode 100644 lmms/include/Pitch.h
 create mode 100644 lmms/include/PlayHandle.h
 create mode 100644 lmms/include/Plugin.h
 create mode 100644 lmms/include/PluginView.h
 create mode 100644 lmms/include/PresetPreviewPlayHandle.h
 create mode 100644 lmms/include/ProjectJournal.h
 create mode 100644 lmms/include/ProjectRenderer.h
 create mode 100644 lmms/include/RemotePlugin.h
 create mode 100644 lmms/include/SampleBuffer.h
 create mode 100644 lmms/include/SamplePlayHandle.h
 create mode 100644 lmms/include/SampleRecordHandle.h
 create mode 100644 lmms/include/SampleTrack.h
 create mode 100644 lmms/include/SerializingObject.h
 create mode 100644 lmms/include/SideBar.h
 create mode 100644 lmms/include/SideBarWidget.h
 create mode 100644 lmms/include/SongEditor.h
 create mode 100644 lmms/include/SweepOscillator.h
 create mode 100644 lmms/include/TempoSyncKnob.h
 create mode 100644 lmms/include/TempoSyncKnobModel.h
 create mode 100644 lmms/include/TimeDisplayWidget.h
 create mode 100644 lmms/include/ToolPlugin.h
 create mode 100644 lmms/include/ToolPluginView.h
 create mode 100644 lmms/include/TrackContainer.h
 create mode 100644 lmms/include/TrackContainerView.h
 create mode 100644 lmms/include/VersionedSaveDialog.h
 create mode 100644 lmms/include/VstSyncController.h
 create mode 100644 lmms/include/VstSyncData.h
 create mode 100644 lmms/include/about_dialog.h
 create mode 100644 lmms/include/aeffectx.h
 create mode 100644 lmms/include/atomic_int.h
 create mode 100644 lmms/include/automatable_button.h
 create mode 100644 lmms/include/automatable_slider.h
 create mode 100644 lmms/include/base64.h
 create mode 100644 lmms/include/basic_filters.h
 create mode 100644 lmms/include/bb_editor.h
 create mode 100644 lmms/include/bb_track.h
 create mode 100644 lmms/include/bb_track_container.h
 create mode 100644 lmms/include/caption_menu.h
 create mode 100644 lmms/include/combobox.h
 create mode 100644 lmms/include/config_mgr.h
 create mode 100644 lmms/include/cpuload_widget.h
 create mode 100644 lmms/include/custom_events.h
 create mode 100644 lmms/include/debug.h
 create mode 100644 lmms/include/drumsynth.h
 create mode 100644 lmms/include/embed.h
 create mode 100644 lmms/include/endian_handling.h
 create mode 100644 lmms/include/engine.h
 create mode 100644 lmms/include/export.h
 create mode 100644 lmms/include/export_project_dialog.h
 create mode 100644 lmms/include/fade_button.h
 create mode 100644 lmms/include/fader.h
 create mode 100644 lmms/include/fft_helpers.h
 create mode 100644 lmms/include/fifo_buffer.h
 create mode 100644 lmms/include/file_browser.h
 create mode 100644 lmms/include/graph.h
 create mode 100644 lmms/include/group_box.h
 create mode 100644 lmms/include/gui_templates.h
 create mode 100644 lmms/include/interpolation.h
 create mode 100644 lmms/include/knob.h
 create mode 100644 lmms/include/ladspa.h
 create mode 100644 lmms/include/ladspa_2_lmms.h
 create mode 100644 lmms/include/ladspa_manager.h
 create mode 100644 lmms/include/led_checkbox.h
 create mode 100644 lmms/include/lmms_basics.h
 create mode 100644 lmms/include/lmms_constants.h
 create mode 100644 lmms/include/lmms_math.h
 create mode 100644 lmms/include/mmp.h
 create mode 100644 lmms/include/note.h
 create mode 100644 lmms/include/nstate_button.h
 create mode 100644 lmms/include/panning.h
 create mode 100644 lmms/include/panning_constants.h
 create mode 100644 lmms/include/pattern.h
 create mode 100644 lmms/include/pixmap_button.h
 create mode 100644 lmms/include/plugin_browser.h
 create mode 100644 lmms/include/project_notes.h
 create mode 100644 lmms/include/project_version.h
 create mode 100644 lmms/include/rename_dialog.h
 create mode 100644 lmms/include/rubberband.h
 create mode 100644 lmms/include/setup_dialog.h
 create mode 100644 lmms/include/shared_object.h
 create mode 100644 lmms/include/song.h
 create mode 100644 lmms/include/string_pair_drag.h
 create mode 100644 lmms/include/tab_bar.h
 create mode 100644 lmms/include/tab_button.h
 create mode 100644 lmms/include/tab_widget.h
 create mode 100644 lmms/include/templates.h
 create mode 100644 lmms/include/text_float.h
 create mode 100644 lmms/include/timeline.h
 create mode 100644 lmms/include/tool_button.h
 create mode 100644 lmms/include/tooltip.h
 create mode 100644 lmms/include/track.h
 create mode 100644 lmms/include/track_label_button.h
 create mode 100644 lmms/include/transformable_auto_model.h
 create mode 100644 lmms/include/update_event.h
 create mode 100644 lmms/include/versioninfo.h
 create mode 100644 lmms/include/visualization_widget.h
 create mode 100644 lmms/include/volume.h

diff --git a/lmms/include/AudioAlsa.h b/lmms/include/AudioAlsa.h
new file mode 100644
index 0000000..df53475
--- /dev/null
+++ b/lmms/include/AudioAlsa.h
@@ -0,0 +1,99 @@
+/*
+ * AudioAlsa.h - device-class that implements ALSA-PCM-output
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_ALSA_H
+#define _AUDIO_ALSA_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_ALSA
+
+// older ALSA-versions might require this
+#define ALSA_PCM_NEW_HW_PARAMS_API
+
+#include <alsa/asoundlib.h>
+
+#include "AudioDevice.h"
+
+
+class LcdSpinBox;
+class QLineEdit;
+
+
+class AudioAlsa : public AudioDevice, public QThread
+{
+public:
+	AudioAlsa( bool & _success_ful, Mixer* mixer );
+	virtual ~AudioAlsa();
+
+	inline static QString name()
+	{
+		return QT_TRANSLATE_NOOP( "setupWidget",
+			"ALSA (Advanced Linux Sound Architecture)" );
+	}
+
+	static QString probeDevice();
+
+
+	class setupWidget : public AudioDevice::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent );
+		virtual ~setupWidget();
+
+		virtual void saveSettings();
+
+	private:
+		QLineEdit * m_device;
+		LcdSpinBox * m_channels;
+
+	} ;
+
+
+private:
+	virtual void startProcessing();
+	virtual void stopProcessing();
+	virtual void applyQualitySettings();
+	virtual void run();
+
+	int setHWParams( const ch_cnt_t _channels, snd_pcm_access_t _access );
+	int setSWParams();
+	int handleError( int _err );
+
+
+	snd_pcm_t * m_handle;
+
+	snd_pcm_uframes_t m_bufferSize;
+	snd_pcm_uframes_t m_periodSize;
+
+	snd_pcm_hw_params_t * m_hwParams;
+	snd_pcm_sw_params_t * m_swParams;
+
+	bool m_convertEndian;
+
+} ;
+
+#endif
+
+#endif
diff --git a/lmms/include/AudioDevice.h b/lmms/include/AudioDevice.h
new file mode 100644
index 0000000..9b0b3dd
--- /dev/null
+++ b/lmms/include/AudioDevice.h
@@ -0,0 +1,183 @@
+/*
+ * AudioDevice.h - base-class for audio-devices, used by LMMS-mixer
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_DEVICE_H
+#define _AUDIO_DEVICE_H
+
+#include <QtCore/QPair>
+#include <QtCore/QMutex>
+#include <QtCore/QThread>
+
+#include "Mixer.h"
+#include "tab_widget.h"
+
+
+class AudioPort;
+
+
+class AudioDevice
+{
+public:
+	AudioDevice( const ch_cnt_t _channels, Mixer* mixer );
+	virtual ~AudioDevice();
+
+	inline void lock()
+	{
+		m_devMutex.lock();
+	}
+
+	inline void unlock()
+	{
+		m_devMutex.unlock();
+	}
+
+
+	// if audio-driver supports ports, classes inherting AudioPort
+	// (e.g. channel-tracks) can register themselves for making
+	// audio-driver able to collect their individual output and provide
+	// them at a specific port - currently only supported by JACK
+	virtual void registerPort( AudioPort * _port );
+	virtual void unregisterPort( AudioPort * _port );
+	virtual void renamePort( AudioPort * _port );
+
+
+	inline bool supportsCapture() const
+	{
+		return m_supportsCapture;
+	}
+
+	inline sample_rate_t sampleRate() const
+	{
+		return m_sampleRate;
+	}
+
+	ch_cnt_t channels() const
+	{
+		return m_channels;
+	}
+
+	void processNextBuffer();
+
+	virtual void startProcessing()
+	{
+		m_inProcess = true;
+	}
+
+	virtual void stopProcessing();
+
+	virtual void applyQualitySettings();
+
+
+
+	class setupWidget : public tabWidget
+	{
+	public:
+		setupWidget( const QString & _caption, QWidget * _parent ) :
+			tabWidget( tabWidget::tr( "Settings for %1" ).arg(
+					tabWidget::tr( _caption.toAscii() ) ).
+							toUpper(), _parent )
+		{
+		}
+
+		virtual ~setupWidget()
+		{
+		}
+
+		virtual void saveSettings() = 0;
+
+		virtual void show()
+		{
+			parentWidget()->show();
+			QWidget::show();
+		}
+
+	} ;
+
+
+
+protected:
+	// subclasses can re-implement this for being used in conjunction with
+	// processNextBuffer()
+	virtual void writeBuffer( const surroundSampleFrame * /* _buf*/,
+						const fpp_t /*_frames*/,
+						const float /*_master_gain*/ )
+	{
+	}
+
+	// called by according driver for fetching new sound-data
+	fpp_t getNextBuffer( surroundSampleFrame * _ab );
+
+	// convert a given audio-buffer to a buffer in signed 16-bit samples
+	// returns num of bytes in outbuf
+	int convertToS16( const surroundSampleFrame * _ab,
+						const fpp_t _frames,
+						const float _master_gain,
+						int_sample_t * _output_buffer,
+						const bool _convert_endian = false );
+
+	// clear given signed-int-16-buffer
+	void clearS16Buffer( int_sample_t * _outbuf,
+							const fpp_t _frames );
+
+	// resample given buffer from samplerate _src_sr to samplerate _dst_sr
+	void resample( const surroundSampleFrame * _src,
+					const fpp_t _frames,
+					surroundSampleFrame * _dst,
+					const sample_rate_t _src_sr,
+					const sample_rate_t _dst_sr );
+
+	inline void setSampleRate( const sample_rate_t _new_sr )
+	{
+		m_sampleRate = _new_sr;
+	}
+
+	Mixer* mixer()
+	{
+		return m_mixer;
+	}
+
+	bool hqAudio() const;
+
+
+protected:
+	bool m_supportsCapture;
+
+
+private:
+	sample_rate_t m_sampleRate;
+	ch_cnt_t m_channels;
+	Mixer* m_mixer;
+	bool m_inProcess;
+
+	QMutex m_devMutex;
+
+	SRC_DATA m_srcData;
+	SRC_STATE * m_srcState;
+
+	surroundSampleFrame * m_buffer;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/AudioDummy.h b/lmms/include/AudioDummy.h
new file mode 100644
index 0000000..44595c3
--- /dev/null
+++ b/lmms/include/AudioDummy.h
@@ -0,0 +1,116 @@
+/*
+ * AudioDummy.h - dummy audio-device
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_DUMMY_H
+#define _AUDIO_DUMMY_H
+
+#include "AudioDevice.h"
+#include "MicroTimer.h"
+
+
+class AudioDummy : public AudioDevice, public QThread
+{
+public:
+	AudioDummy( bool & _success_ful, Mixer* mixer ) :
+		AudioDevice( DEFAULT_CHANNELS, mixer )
+	{
+		_success_ful = true;
+	}
+
+	virtual ~AudioDummy()
+	{
+		stopProcessing();
+	}
+
+	inline static QString name()
+	{
+		return QT_TRANSLATE_NOOP( "setupWidget", "Dummy (no sound output)" );
+	}
+
+
+	class setupWidget : public AudioDevice::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent ) :
+			AudioDevice::setupWidget( AudioDummy::name(), _parent )
+		{
+		}
+
+		virtual ~setupWidget()
+		{
+		}
+
+		virtual void saveSettings()
+		{
+		}
+
+		virtual void show()
+		{
+			parentWidget()->hide();
+			QWidget::show();
+		}
+
+	} ;
+
+
+private:
+	virtual void startProcessing()
+	{
+		start();
+	}
+
+	virtual void stopProcessing()
+	{
+		if( isRunning() )
+		{
+			wait( 1000 );
+			terminate();
+		}
+	}
+
+	virtual void run()
+	{
+		MicroTimer timer;
+		while( true )
+		{
+			timer.reset();
+			const surroundSampleFrame* b = mixer()->nextBuffer();
+			if( !b )
+			{
+				break;
+			}
+			delete[] b;
+
+			const int microseconds = static_cast<int>( mixer()->framesPerPeriod() * 1000000.0f / mixer()->processingSampleRate() - timer.elapsed() );
+			if( microseconds > 0 )
+			{
+				usleep( microseconds );
+			}
+		}
+	}
+
+} ;
+
+
+#endif
diff --git a/lmms/include/AudioFileDevice.h b/lmms/include/AudioFileDevice.h
new file mode 100644
index 0000000..992c373
--- /dev/null
+++ b/lmms/include/AudioFileDevice.h
@@ -0,0 +1,114 @@
+/*
+ * AudioFileDevice.h - base-class for audio-device-classes which write 
+ *                     their output into a file
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_FILE_DEVICE_H
+#define _AUDIO_FILE_DEVICE_H
+
+#include <QtCore/QFile>
+
+#include "AudioDevice.h"
+
+
+class AudioFileDevice : public AudioDevice
+{
+public:
+	AudioFileDevice( const sample_rate_t _sample_rate,
+				const ch_cnt_t _channels, const QString & _file,
+				const bool _use_vbr,
+				const bitrate_t _nom_bitrate,
+				const bitrate_t _min_bitrate,
+				const bitrate_t _max_bitrate,
+				const int _depth,
+				Mixer* mixer );
+	virtual ~AudioFileDevice();
+
+	QString outputFile() const
+	{
+		return m_outputFile.fileName();
+	}
+
+
+protected:
+	int writeData( const void* data, int len );
+
+	inline bool useVBR() const
+	{
+		return m_useVbr;
+	}
+
+	inline bitrate_t nominalBitrate() const
+	{
+		return m_nomBitrate;
+	}
+
+	inline bitrate_t minBitrate() const
+	{
+		return m_minBitrate;
+	}
+
+	inline bitrate_t maxBitrate() const
+	{
+		return m_maxBitrate;
+	}
+
+	inline int depth() const
+	{
+		return m_depth;
+	}
+
+	inline bool outputFileOpened() const
+	{
+		return m_outputFile.isOpen();
+	}
+
+
+private:
+	QFile m_outputFile;
+
+	bool m_useVbr;
+
+	bitrate_t m_nomBitrate;
+	bitrate_t m_minBitrate;
+	bitrate_t m_maxBitrate;
+
+	int m_depth;
+
+} ;
+
+
+typedef AudioFileDevice * ( * AudioFileDeviceInstantiaton )
+					( const sample_rate_t _sample_rate,
+						const ch_cnt_t _channels,
+						bool & _success_ful,
+						const QString & _file,
+						const bool _use_vbr,
+						const bitrate_t _nom_bitrate,
+						const bitrate_t _min_bitrate,
+						const bitrate_t _max_bitrate,
+						const int _depth,
+						Mixer* mixer );
+
+
+#endif
diff --git a/lmms/include/AudioFileOgg.h b/lmms/include/AudioFileOgg.h
new file mode 100644
index 0000000..e3be674
--- /dev/null
+++ b/lmms/include/AudioFileOgg.h
@@ -0,0 +1,107 @@
+/*
+ * AudioFileOgg.h - Audio-device which encodes wave-stream and writes it
+ *                  into an OGG-file. This is used for song-export.
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_FILE_OGG_H
+#define _AUDIO_FILE_OGG_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_OGGVORBIS
+
+#include <vorbis/codec.h>
+
+#include "AudioFileDevice.h"
+
+
+class AudioFileOgg : public AudioFileDevice
+{
+public:
+	AudioFileOgg( const sample_rate_t _sample_rate,
+			const ch_cnt_t _channels,
+			bool & _success_ful,
+			const QString & _file,
+			const bool _use_vbr,
+			const bitrate_t _nom_bitrate,
+			const bitrate_t _min_bitrate,
+			const bitrate_t _max_bitrate,
+			const int _depth,
+			Mixer* mixer );
+	virtual ~AudioFileOgg();
+
+	static AudioFileDevice * getInst( const sample_rate_t _sample_rate,
+						const ch_cnt_t _channels,
+						bool & _success_ful,
+						const QString & _file,
+						const bool _use_vbr,
+						const bitrate_t _nom_bitrate,
+						const bitrate_t _min_bitrate,
+						const bitrate_t _max_bitrate,
+						const int _depth,
+						Mixer* mixer )
+	{
+		return new AudioFileOgg( _sample_rate, _channels, _success_ful,
+						_file, _use_vbr, _nom_bitrate,
+						_min_bitrate, _max_bitrate,
+							_depth, mixer );
+	}
+
+
+private:
+	virtual void writeBuffer( const surroundSampleFrame * _ab,
+						const fpp_t _frames,
+						const float _master_gain );
+
+	bool startEncoding();
+	void finishEncoding();
+	inline int writePage();
+
+
+	bool m_ok;
+	ch_cnt_t m_channels;
+	sample_rate_t m_rate;
+
+	// Various bitrate/quality options
+	bitrate_t m_minBitrate;
+	bitrate_t m_maxBitrate;
+
+	uint32_t m_serialNo;
+
+	vorbis_comment * m_comments;
+
+	// encoding setup - init by init_ogg_encoding
+	ogg_stream_state	m_os;
+	ogg_page 	 	m_og;
+	ogg_packet	 	m_op;
+
+	vorbis_dsp_state 	m_vd;
+	vorbis_block     	m_vb;
+	vorbis_info      	m_vi;
+
+} ;
+
+
+#endif
+
+#endif
diff --git a/lmms/include/AudioFileWave.h b/lmms/include/AudioFileWave.h
new file mode 100644
index 0000000..ee68aff
--- /dev/null
+++ b/lmms/include/AudioFileWave.h
@@ -0,0 +1,84 @@
+/*
+ * AudioFileWave.h - AudioDevice which encodes wave-stream and writes it
+ *                   into a WAVE-file. This is used for song-export.
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_FILE_WAVE_H
+#define _AUDIO_FILE_WAVE_H
+
+#include "lmmsconfig.h"
+#include "AudioFileDevice.h"
+
+#include <sndfile.h>
+
+
+class AudioFileWave : public AudioFileDevice
+{
+public:
+	AudioFileWave( const sample_rate_t _sample_rate,
+			const ch_cnt_t _channels,
+			bool & _success_ful,
+			const QString & _file,
+			const bool _use_vbr,
+			const bitrate_t _nom_bitrate,
+			const bitrate_t _min_bitrate,
+			const bitrate_t _max_bitrate,
+			const int _depth,
+			Mixer* mixer );
+	virtual ~AudioFileWave();
+
+	static AudioFileDevice * getInst( const sample_rate_t _sample_rate,
+						const ch_cnt_t _channels,
+						bool & _success_ful,
+						const QString & _file,
+						const bool _use_vbr,
+						const bitrate_t _nom_bitrate,
+						const bitrate_t _min_bitrate,
+						const bitrate_t _max_bitrate,
+						const int _depth,
+						Mixer* mixer )
+	{
+		return new AudioFileWave( _sample_rate, _channels,
+						_success_ful, _file, _use_vbr,
+						_nom_bitrate, _min_bitrate,
+							_max_bitrate, _depth,
+							mixer );
+	}
+
+
+private:
+	virtual void writeBuffer( const surroundSampleFrame * _ab,
+						const fpp_t _frames,
+						float _master_gain );
+
+	bool startEncoding();
+	void finishEncoding();
+
+
+	SF_INFO m_si;
+	SNDFILE * m_sf;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/AudioJack.h b/lmms/include/AudioJack.h
new file mode 100644
index 0000000..20d62cb
--- /dev/null
+++ b/lmms/include/AudioJack.h
@@ -0,0 +1,128 @@
+/*
+ * AudioJack.h - support for JACK-transport
+ *
+ * Copyright (c) 2005-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_JACK_H
+#define _AUDIO_JACK_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_JACK
+#include <jack/jack.h>
+#endif
+
+#include <QtCore/QVector>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+
+#include "AudioDevice.h"
+
+
+class QLineEdit;
+class LcdSpinBox;
+
+
+class AudioJack : public QObject, public AudioDevice
+{
+	Q_OBJECT
+public:
+	AudioJack( bool & _success_ful, Mixer* mixer );
+	virtual ~AudioJack();
+
+	inline static QString name()
+	{
+		return QT_TRANSLATE_NOOP( "setupWidget",
+			"JACK (JACK Audio Connection Kit)" );
+	}
+
+
+	class setupWidget : public AudioDevice::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent );
+		virtual ~setupWidget();
+
+		virtual void saveSettings();
+
+	private:
+		QLineEdit * m_clientName;
+		LcdSpinBox * m_channels;
+
+	} ;
+
+
+private slots:
+	void restartAfterZombified();
+
+
+#ifdef LMMS_HAVE_JACK
+private:
+	bool initJackClient();
+
+	virtual void startProcessing();
+	virtual void stopProcessing();
+	virtual void applyQualitySettings();
+
+	virtual void registerPort( AudioPort * _port );
+	virtual void unregisterPort( AudioPort * _port );
+	virtual void renamePort( AudioPort * _port );
+
+	int processCallback( jack_nframes_t _nframes, void * _udata );
+
+	static int staticProcessCallback( jack_nframes_t _nframes,
+							void * _udata );
+	static void shutdownCallback( void * _udata );
+
+
+	jack_client_t * m_client;
+
+	bool m_active;
+	bool m_stopped;
+
+	QSemaphore m_stopSemaphore;
+
+	QVector<jack_port_t *> m_outputPorts;
+	jack_default_audio_sample_t * * m_tempOutBufs;
+	surroundSampleFrame * m_outBuf;
+
+	f_cnt_t m_framesDoneInCurBuf;
+	f_cnt_t m_framesToDoInCurBuf;
+
+
+#ifdef AUDIO_PORT_SUPPORT
+	struct StereoPort
+	{
+		jack_port_t * ports[2];
+	} ;
+
+	typedef QMap<AudioPort *, StereoPort> JackPortMap;
+	JackPortMap m_portMap;
+#endif
+#endif
+
+signals:
+	void zombified();
+
+} ;
+
+#endif
diff --git a/lmms/include/AudioOss.h b/lmms/include/AudioOss.h
new file mode 100644
index 0000000..5a41d0f
--- /dev/null
+++ b/lmms/include/AudioOss.h
@@ -0,0 +1,83 @@
+/*
+ * AudioOss.h - device-class that implements OSS-PCM-output
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_OSS_H
+#define _AUDIO_OSS_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_OSS
+
+#include "AudioDevice.h"
+
+
+class LcdSpinBox;
+class QLineEdit;
+
+
+class AudioOss : public AudioDevice, public QThread
+{
+public:
+	AudioOss( bool & _success_ful, Mixer* mixer );
+	virtual ~AudioOss();
+
+	inline static QString name()
+	{
+		return QT_TRANSLATE_NOOP( "setupWidget", "OSS (Open Sound System)" );
+	}
+
+	static QString probeDevice();
+
+
+	class setupWidget : public AudioDevice::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent );
+		virtual ~setupWidget();
+
+		virtual void saveSettings();
+
+	private:
+		QLineEdit * m_device;
+		LcdSpinBox * m_channels;
+
+	} ;
+
+
+private:
+	virtual void startProcessing();
+	virtual void stopProcessing();
+	virtual void applyQualitySettings();
+	virtual void run();
+
+	int m_audioFD;
+
+	bool m_convertEndian;
+
+} ;
+
+
+#endif
+
+#endif
diff --git a/lmms/include/AudioPort.h b/lmms/include/AudioPort.h
new file mode 100644
index 0000000..47129ae
--- /dev/null
+++ b/lmms/include/AudioPort.h
@@ -0,0 +1,143 @@
+/*
+ * AudioPort.h - base-class for objects providing sound at a port
+ *
+ * Copyright (c) 2005-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_PORT_H
+#define _AUDIO_PORT_H
+
+#include <QtCore/QString>
+#include <QtCore/QMutex>
+#include <QtCore/QMutexLocker>
+
+#include "Mixer.h"
+
+class EffectChain;
+
+class AudioPort
+{
+public:
+	AudioPort( const QString & _name, bool _has_effect_chain = true );
+	virtual ~AudioPort();
+
+	inline sampleFrame * firstBuffer()
+	{
+		return m_firstBuffer;
+	}
+
+	inline sampleFrame * secondBuffer()
+	{
+		return m_secondBuffer;
+	}
+
+	inline void lockFirstBuffer()
+	{
+		m_firstBufferLock.lock();
+	}
+
+	inline void lockSecondBuffer()
+	{
+		m_secondBufferLock.lock();
+	}
+
+	inline void unlockFirstBuffer()
+	{
+		m_firstBufferLock.unlock();
+	}
+
+	inline void unlockSecondBuffer()
+	{
+		m_secondBufferLock.unlock();
+	}
+
+	void nextPeriod();
+
+
+	// indicate whether JACK & Co should provide output-buffer at ext. port
+	inline bool extOutputEnabled() const
+	{
+		return m_extOutputEnabled;
+	}
+
+	void setExtOutputEnabled( bool _enabled );
+
+
+	// next effect-channel after this audio-port
+	// (-1 = none  0 = master)
+	inline fx_ch_t nextFxChannel() const
+	{
+		return m_nextFxChannel;
+	}
+
+	inline EffectChain * effects()
+	{
+		return m_effects;
+	}
+
+	void setNextFxChannel( const fx_ch_t _chnl )
+	{
+		m_nextFxChannel = _chnl;
+	}
+
+
+	const QString & name() const
+	{
+		return m_name;
+	}
+
+	void setName( const QString & _new_name );
+
+
+	bool processEffects();
+
+
+	enum bufferUsages
+	{
+		NoUsage,
+		FirstBuffer,
+		BothBuffers
+	} ;
+
+
+private:
+	volatile bufferUsages m_bufferUsage;
+
+	sampleFrame * m_firstBuffer;
+	sampleFrame * m_secondBuffer;
+	QMutex m_firstBufferLock;
+	QMutex m_secondBufferLock;
+
+	bool m_extOutputEnabled;
+	fx_ch_t m_nextFxChannel;
+
+	QString m_name;
+	
+	EffectChain * m_effects;
+
+
+	friend class Mixer;
+	friend class MixerWorkerThread;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/AudioPortAudio.h b/lmms/include/AudioPortAudio.h
new file mode 100644
index 0000000..04b0d35
--- /dev/null
+++ b/lmms/include/AudioPortAudio.h
@@ -0,0 +1,151 @@
+/*
+ * AudioPortAudio.h - device-class that performs PCM-output via PortAudio
+ *
+ * Copyright (c) 2008 Csaba Hruska <csaba.hruska/at/gmail.com>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_PORTAUDIO_H
+#define _AUDIO_PORTAUDIO_H
+
+#include <QtCore/QObject>
+
+#include "lmmsconfig.h"
+#include "ComboBoxModel.h"
+
+class AudioPortAudioSetupUtil : public QObject
+{
+	Q_OBJECT
+public slots:
+	void updateDevices();
+	void updateChannels();
+		
+public:
+	ComboBoxModel m_backendModel;
+	ComboBoxModel m_deviceModel;
+} ;
+
+
+#ifdef LMMS_HAVE_PORTAUDIO
+
+#include <portaudio.h>
+
+#include "AudioDevice.h"
+
+#if defined paNeverDropInput || defined paNonInterleaved
+#	define PORTAUDIO_V19
+#else
+#	define PORTAUDIO_V18
+#endif
+
+
+class comboBox;
+class LcdSpinBox;
+
+
+class AudioPortAudio : public AudioDevice
+{
+public:
+	AudioPortAudio( bool & _success_ful, Mixer* mixer );
+	virtual ~AudioPortAudio();
+
+	inline static QString name()
+	{
+		return QT_TRANSLATE_NOOP( "setupWidget", "PortAudio" );
+	}
+
+
+	int process_callback( const float *_inputBuffer,
+		float * _outputBuffer,
+		unsigned long _framesPerBuffer );
+
+
+	class setupWidget : public AudioDevice::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent );
+		virtual ~setupWidget();
+
+		virtual void saveSettings();
+
+	private:
+		comboBox * m_backend;
+		comboBox * m_device;
+		AudioPortAudioSetupUtil m_setupUtil;
+
+	} ;
+
+private:
+	virtual void startProcessing();
+	virtual void stopProcessing();
+	virtual void applyQualitySettings();
+
+#ifdef PORTAUDIO_V19
+	static int _process_callback( const void *_inputBuffer, void * _outputBuffer,
+		unsigned long _framesPerBuffer,
+		const PaStreamCallbackTimeInfo * _timeInfo,
+		PaStreamCallbackFlags _statusFlags,
+		void *arg );
+
+#else
+
+#define paContinue 0
+#define paComplete 1
+#define Pa_GetDeviceCount Pa_CountDevices
+#define Pa_GetDefaultInputDevice Pa_GetDefaultInputDeviceID
+#define Pa_GetDefaultOutputDevice Pa_GetDefaultOutputDeviceID
+#define Pa_IsStreamActive Pa_StreamActive
+
+	static int _process_callback( void * _inputBuffer, void * _outputBuffer,
+		unsigned long _framesPerBuffer, PaTimestamp _outTime, void * _arg );
+
+
+	typedef double PaTime;
+	typedef PaDeviceID PaDeviceIndex;
+	
+	typedef struct PaStreamParameters
+	{
+		PaDeviceIndex device;
+		int channelCount;
+		PaSampleFormat sampleFormat;
+		PaTime suggestedLatency;
+		void *hostApiSpecificStreamInfo;
+
+	} PaStreamParameters;
+#endif
+
+	PaStream * m_paStream;
+	PaStreamParameters m_outputParameters;
+	PaStreamParameters m_inputParameters;
+
+	bool m_wasPAInitError;
+ 
+	surroundSampleFrame * m_outBuf;
+	int m_outBufPos;
+	int m_outBufSize;
+
+	bool m_stopped;
+	QSemaphore m_stopSemaphore;
+
+} ;
+
+#endif
+
+#endif
diff --git a/lmms/include/AudioPulseAudio.h b/lmms/include/AudioPulseAudio.h
new file mode 100644
index 0000000..e525484
--- /dev/null
+++ b/lmms/include/AudioPulseAudio.h
@@ -0,0 +1,90 @@
+/*
+ * AudioPulseAudio.h - device-class which implements PulseAudio-output
+ *
+ * Copyright (c) 2008-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_PULSEAUDIO_H
+#define _AUDIO_PULSEAUDIO_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_PULSEAUDIO
+
+#include <pulse/pulseaudio.h>
+
+#include "AudioDevice.h"
+
+
+class LcdSpinBox;
+class QLineEdit;
+
+
+class AudioPulseAudio : public AudioDevice, public QThread
+{
+public:
+	AudioPulseAudio( bool & _success_ful, Mixer* mixer );
+	virtual ~AudioPulseAudio();
+
+	inline static QString name()
+	{
+		return QT_TRANSLATE_NOOP( "setupWidget", "PulseAudio (bad latency!)" );
+	}
+
+	static QString probeDevice();
+
+
+	class setupWidget : public AudioDevice::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent );
+		virtual ~setupWidget();
+
+		virtual void saveSettings();
+
+	private:
+		QLineEdit * m_device;
+		LcdSpinBox * m_channels;
+
+	} ;
+
+
+	void streamWriteCallback( pa_stream * s, size_t length );
+
+	pa_stream * m_s;
+	pa_sample_spec m_sampleSpec;
+
+
+private:
+	virtual void startProcessing();
+	virtual void stopProcessing();
+	virtual void applyQualitySettings();
+	virtual void run();
+
+	volatile bool m_quit;
+
+	bool m_convertEndian;
+
+} ;
+
+#endif
+
+#endif
diff --git a/lmms/include/AudioSampleRecorder.h b/lmms/include/AudioSampleRecorder.h
new file mode 100644
index 0000000..7b0a6ae
--- /dev/null
+++ b/lmms/include/AudioSampleRecorder.h
@@ -0,0 +1,59 @@
+/*
+ * AudioSampleRecorder.h - device-class that implements recording
+ *                         audio-buffers into RAM
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_SAMPLE_RECORDER_H
+#define _AUDIO_SAMPLE_RECORDER_H
+
+#include <QtCore/QList>
+#include <QtCore/QPair>
+
+#include "AudioDevice.h"
+
+class SampleBuffer;
+
+
+class AudioSampleRecorder : public AudioDevice
+{
+public:
+	AudioSampleRecorder( const ch_cnt_t _channels, bool & _success_ful,
+							Mixer* mixer );
+	virtual ~AudioSampleRecorder();
+
+	f_cnt_t framesRecorded() const;
+	void createSampleBuffer( SampleBuffer** sampleBuffer );
+
+
+private:
+	virtual void writeBuffer( const surroundSampleFrame * _ab,
+						const fpp_t _frames,
+						const float _master_gain );
+
+	typedef QList<QPair<sampleFrame *, fpp_t> > BufferList;
+	BufferList m_buffers;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/AudioSdl.h b/lmms/include/AudioSdl.h
new file mode 100644
index 0000000..d5b073e
--- /dev/null
+++ b/lmms/include/AudioSdl.h
@@ -0,0 +1,91 @@
+/*
+ * AudioSdl.h - device-class that performs PCM-output via SDL
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUDIO_SDL_H
+#define _AUDIO_SDL_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_SDL
+
+#include <SDL/SDL.h>
+#include <SDL/SDL_audio.h>
+
+#include "AudioDevice.h"
+
+class QLineEdit;
+
+
+class AudioSdl : public AudioDevice
+{
+public:
+	AudioSdl( bool & _success_ful, Mixer* mixer );
+	virtual ~AudioSdl();
+
+	inline static QString name()
+	{
+		return QT_TRANSLATE_NOOP( "setupWidget",
+					"SDL (Simple DirectMedia Layer)" );
+	}
+
+
+	class setupWidget : public AudioDevice::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent );
+		virtual ~setupWidget();
+
+		virtual void saveSettings();
+
+	private:
+		QLineEdit * m_device;
+
+	} ;
+
+
+private:
+	virtual void startProcessing();
+	virtual void stopProcessing();
+	virtual void applyQualitySettings();
+
+	static void sdlAudioCallback( void * _udata, Uint8 * _buf, int _len );
+	void sdlAudioCallback( Uint8 * _buf, int _len );
+
+	SDL_AudioSpec m_audioHandle;
+
+	surroundSampleFrame * m_outBuf;
+	Uint8 * m_convertedBuf;
+	int m_convertedBufPos;
+	int m_convertedBufSize;
+
+	bool m_convertEndian;
+
+	volatile bool m_stopped;
+	QSemaphore m_stopSemaphore;
+
+} ;
+
+#endif
+
+#endif
diff --git a/lmms/include/AutomatableModel.h b/lmms/include/AutomatableModel.h
new file mode 100644
index 0000000..f390d25
--- /dev/null
+++ b/lmms/include/AutomatableModel.h
@@ -0,0 +1,368 @@
+/*
+ * AutomatableModel.h - declaration of class AutomatableModel
+ *
+ * Copyright (c) 2007-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef AUTOMATABLE_MODEL_H
+#define AUTOMATABLE_MODEL_H
+
+#include <math.h>
+
+#include "JournallingObject.h"
+#include "Model.h"
+
+
+// simple way to map a property of a view to a model
+#define mapPropertyFromModelPtr(type,getfunc,setfunc,modelname)	\
+		public:													\
+			type getfunc() const								\
+			{													\
+				return (type) modelname->value();				\
+			}													\
+		public slots:											\
+			void setfunc( const type val )						\
+			{													\
+				modelname->setValue( val );						\
+			}
+
+#define mapPropertyFromModel(type,getfunc,setfunc,modelname)	\
+		public:													\
+			type getfunc() const								\
+			{													\
+				return (type) modelname.value();				\
+			}													\
+		public slots:											\
+			void setfunc( const type val )						\
+			{													\
+				modelname.setValue( (float) val );				\
+			}
+
+
+
+class ControllerConnection;
+
+
+class EXPORT AutomatableModel : public Model, public JournallingObject
+{
+	Q_OBJECT
+public:
+	typedef QVector<AutomatableModel *> AutoModelVector;
+
+	enum DataType
+	{
+		Float,
+		Integer,
+		Bool
+	} ;
+
+	AutomatableModel( DataType type,
+						const float val = 0,
+						const float min = 0,
+						const float max = 0,
+						const float step = 0,
+						Model* parent = NULL,
+						const QString& displayName = QString(),
+						bool defaultConstructed = false );
+
+	virtual ~AutomatableModel();
+
+
+	static float copiedValue()
+	{
+		return s_copiedValue;
+	}
+
+	bool isAutomated() const;
+
+	ControllerConnection* controllerConnection() const
+	{
+		return m_controllerConnection;
+	}
+
+
+	void setControllerConnection( ControllerConnection* c );
+
+
+	template<class T>
+	static T castValue( const float v )
+	{
+		return (T)( v );
+	}
+
+	template<bool>
+	static bool castValue( const float v )
+	{
+		return ( qRound( v ) != 0 );
+	}
+
+
+	template<class T>
+	inline T value( int frameOffset = 0 ) const
+	{
+		if( unlikely( m_hasLinkedModels || m_controllerConnection != NULL ) )
+		{
+			return castValue<T>( controllerValue( frameOffset ) );
+		}
+
+		return castValue<T>( m_value );
+	}
+
+	float controllerValue( int frameOffset ) const;
+
+
+	template<class T>
+	T initValue() const
+	{
+		return castValue<T>( m_initValue );
+	}
+
+	bool isAtInitValue() const
+	{
+		return m_value == m_initValue;
+	}
+
+	template<class T>
+	T minValue() const
+	{
+		return castValue<T>( m_minValue );
+	}
+
+	template<class T>
+	T maxValue() const
+	{
+		return castValue<T>( m_maxValue );
+	}
+
+	template<class T>
+	T step() const
+	{
+		return castValue<T>( m_step );
+	}
+
+
+	void setInitValue( const float value );
+
+	void setAutomatedValue( const float value );
+	void setValue( const float value );
+
+	void incValue( int steps )
+	{
+		setValue( m_value + steps * m_step );
+	}
+
+	float range() const
+	{
+		return m_range;
+	}
+
+	void setRange( const float min, const float max, const float step = 1 );
+
+	void setStep( const float step );
+
+	float centerValue() const
+	{
+		return m_centerValue;
+	}
+
+	void setCenterValue( const float centerVal )
+	{
+		m_centerValue = centerVal;
+	}
+
+	static void linkModels( AutomatableModel* m1, AutomatableModel* m2 );
+	static void unlinkModels( AutomatableModel* m1, AutomatableModel* m2 );
+
+	void unlinkAllModels();
+
+	/*! \brief Saves settings (value, automation links and controller connections) of AutomatableModel into
+				specified DOM element using <name> as attribute/node name */
+	virtual void saveSettings( QDomDocument& doc, QDomElement& element, const QString& name );
+
+	/*! \brief Loads settings (value, automation links and controller connections) of AutomatableModel from
+				specified DOM element using <name> as attribute/node name */
+	virtual void loadSettings( const QDomElement& element, const QString& name );
+
+	virtual QString nodeName() const
+	{
+		return "automatablemodel";
+	}
+
+	void prepareJournalEntryFromOldVal();
+
+	void addJournalEntryFromOldToCurVal();
+
+
+	QString displayValue( const float val ) const
+	{
+		switch( m_dataType )
+		{
+			case Float: return QString::number( castValue<float>( val ) );
+			case Integer: return QString::number( castValue<int>( val ) );
+			case Bool: return QString::number( castValue<bool>( val ) );
+		}
+		return "0";
+	}
+
+	bool hasLinkedModels() const
+	{
+		return m_hasLinkedModels;
+	}
+
+
+public slots:
+	virtual void reset();
+	virtual void copyValue();
+	virtual void pasteValue();
+	void unlinkControllerConnection();
+
+
+protected:
+	virtual void redoStep( JournalEntry& je );
+	virtual void undoStep( JournalEntry& je );
+
+	float fittedValue( float value ) const;
+
+
+private:
+	virtual void saveSettings( QDomDocument& doc, QDomElement& element )
+	{
+		saveSettings( doc, element, "value" );
+	}
+
+	virtual void loadSettings( const QDomElement& element )
+	{
+		loadSettings( element, "value" );
+	}
+
+	void linkModel( AutomatableModel* model );
+	void unlinkModel( AutomatableModel* model );
+
+
+	DataType m_dataType;
+	float m_value;
+	float m_initValue;
+	float m_minValue;
+	float m_maxValue;
+	float m_step;
+	float m_range;
+	float m_centerValue;
+
+	// most objects will need this temporarily (until sampleExact is
+	// standard)
+	float m_oldValue;
+	bool m_journalEntryReady;
+	int m_setValueDepth;
+
+	AutoModelVector m_linkedModels;
+	bool m_hasLinkedModels;
+
+
+	ControllerConnection* m_controllerConnection;
+
+
+	static float s_copiedValue;
+
+
+signals:
+	void initValueChanged( float val );
+	void destroyed( jo_id_t id );
+
+} ;
+
+
+
+
+
+#define defaultTypedMethods(type)								\
+	type value( int frameOffset = 0 ) const						\
+	{															\
+		return AutomatableModel::value<type>( frameOffset );	\
+	}															\
+																\
+	type initValue() const										\
+	{															\
+		return AutomatableModel::initValue<type>();				\
+	}															\
+																\
+	type minValue() const										\
+	{															\
+		return AutomatableModel::minValue<type>();				\
+	}															\
+																\
+	type maxValue() const										\
+	{															\
+		return AutomatableModel::maxValue<type>();				\
+	}															\
+
+
+// some typed AutomatableModel-definitions
+
+class FloatModel : public AutomatableModel
+{
+public:
+	FloatModel( float val = 0, float min = 0, float max = 0, float step = 0,
+				Model * parent = NULL,
+				const QString& displayName = QString(),
+				bool defaultConstructed = false ) :
+		AutomatableModel( Float, val, min, max, step, parent, displayName, defaultConstructed )
+	{
+	}
+
+	defaultTypedMethods(float);
+
+} ;
+
+
+class IntModel : public AutomatableModel
+{
+public:
+	IntModel( int val = 0, int min = 0, int max = 0,
+				Model* parent = NULL,
+				const QString& displayName = QString(),
+				bool defaultConstructed = false ) :
+		AutomatableModel( Integer, val, min, max, 1, parent, displayName, defaultConstructed )
+	{
+	}
+
+	defaultTypedMethods(int);
+
+} ;
+
+
+class BoolModel : public AutomatableModel
+{
+public:
+	BoolModel( const bool val = false,
+				Model* parent = NULL,
+				const QString& displayName = QString(),
+				bool defaultConstructed = false ) :
+		AutomatableModel( Bool, val, false, true, 1, parent, displayName, defaultConstructed )
+	{
+	}
+
+	defaultTypedMethods(bool);
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/AutomatableModelView.h b/lmms/include/AutomatableModelView.h
new file mode 100644
index 0000000..f213db4
--- /dev/null
+++ b/lmms/include/AutomatableModelView.h
@@ -0,0 +1,132 @@
+/*
+ * AutomatableModelView.h - class AutomatableModelView
+ *
+ * Copyright (c) 2008-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUTOMATABLE_MODEL_VIEW_H
+#define _AUTOMATABLE_MODEL_VIEW_H
+
+#include "ModelView.h"
+#include "AutomatableModel.h"
+
+class QMenu;
+
+
+class EXPORT AutomatableModelView : public ModelView
+{
+public:
+	AutomatableModelView( Model* model, QWidget* _this );
+	virtual ~AutomatableModelView();
+
+	// some basic functions for convenience
+	AutomatableModel* modelUntyped()
+	{
+		return castModel<AutomatableModel>();
+	}
+
+	const AutomatableModel* modelUntyped() const
+	{
+		return castModel<AutomatableModel>();
+	}
+
+	virtual void setModel( Model* model, bool isOldModelValid = true );
+
+	template<typename T>
+	inline T value() const
+	{
+		return modelUntyped() ? modelUntyped()->value<T>() : 0;
+	}
+
+	inline void setDescription( const QString& desc )
+	{
+		m_description = desc;
+	}
+
+	inline void setUnit( const QString& unit )
+	{
+		m_unit = unit;
+	}
+
+	void addDefaultActions( QMenu* menu );
+
+
+protected:
+	virtual void mousePressEvent( QMouseEvent* event );
+
+	QString m_description;
+	QString m_unit;
+
+} ;
+
+
+
+
+class AutomatableModelViewSlots : public QObject
+{
+	Q_OBJECT
+public:
+	AutomatableModelViewSlots( AutomatableModelView* amv, QObject* parent );
+
+public slots:
+	void execConnectionDialog();
+	void removeConnection();
+	void editSongGlobalAutomation();
+	void unlinkAllModels();
+	void removeSongGlobalAutomation();
+
+
+protected:
+	AutomatableModelView* m_amv;
+
+} ;
+
+
+
+
+#define generateTypedModelView(type)							\
+class EXPORT type##ModelView : public AutomatableModelView		\
+{																\
+public:															\
+	type##ModelView( Model* model, QWidget* _this ) :			\
+		AutomatableModelView( model, _this )					\
+	{															\
+	}															\
+																\
+	type##Model* model()										\
+	{															\
+		return castModel<type##Model>();						\
+	}															\
+																\
+	const type##Model* model() const							\
+	{															\
+		return castModel<type##Model>();						\
+	}															\
+}
+
+
+generateTypedModelView(Float);
+generateTypedModelView(Int);
+generateTypedModelView(Bool);
+
+
+#endif
+
diff --git a/lmms/include/AutomationEditor.h b/lmms/include/AutomationEditor.h
new file mode 100644
index 0000000..9ff61bf
--- /dev/null
+++ b/lmms/include/AutomationEditor.h
@@ -0,0 +1,267 @@
+/*
+ * AutomationEditor.h - declaration of class AutomationEditor which is a window
+ *                      where you can edit dynamic values in an easy way
+ *
+ * Copyright (c) 2006-2008 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _AUTOMATION_EDITOR_H
+#define _AUTOMATION_EDITOR_H
+
+#include <QtCore/QMutex>
+#include <QtGui/QWidget>
+
+#include "lmms_basics.h"
+#include "JournallingObject.h"
+#include "MidiTime.h"
+#include "AutomationPattern.h"
+#include "ComboBoxModel.h"
+#include "knob.h"
+
+
+class QPainter;
+class QPixmap;
+class QScrollBar;
+
+class comboBox;
+class NotePlayHandle;
+class timeLine;
+class toolButton;
+
+
+class AutomationEditor : public QWidget, public JournallingObject
+{
+	Q_OBJECT
+public:
+	void setCurrentPattern( AutomationPattern * _new_pattern );
+
+	inline const AutomationPattern * currentPattern() const
+	{
+		return( m_pattern );
+	}
+
+	inline bool validPattern() const
+	{
+		return( m_pattern != NULL );
+	}
+
+	int quantization() const;
+
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+	inline virtual QString nodeName() const
+	{
+		return( "automationeditor" );
+	}
+
+	void setPauseIcon( bool pause );
+
+
+public slots:
+	void update();
+	void updateAfterPatternChange();
+
+
+protected:
+	typedef AutomationPattern::timeMap timeMap;
+
+	virtual void closeEvent( QCloseEvent * _ce );
+	virtual void keyPressEvent( QKeyEvent * _ke );
+	virtual void leaveEvent( QEvent * _e );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+	virtual void mouseMoveEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void resizeEvent( QResizeEvent * _re );
+	virtual void wheelEvent( QWheelEvent * _we );
+
+	float getLevel( int _y );
+	int xCoordOfTick( int _tick );
+	int yCoordOfLevel( float _level );
+	inline void drawLevelTick( QPainter & _p, int _tick,
+					float _value, bool _is_selected );
+	void removeSelection();
+	void selectAll();
+	void getSelectedValues( timeMap & _selected_values );
+
+	void drawLine( int x0, float y0, int x1, float y1 );
+	void disableTensionKnob();
+
+protected slots:
+	void play();
+	void stop();
+
+	void horScrolled( int _new_pos );
+	void verScrolled( int _new_pos );
+
+	void drawButtonToggled();
+	void eraseButtonToggled();
+	void selectButtonToggled();
+	void moveButtonToggled();
+
+	void discreteButtonToggled();
+	void linearButtonToggled();
+	void cubicHermiteButtonToggled();
+	void tensionChanged();
+
+	void copySelectedValues();
+	void cutSelectedValues();
+	void pasteValues();
+	void deleteSelectedValues();
+
+	void updatePosition( const MidiTime & _t );
+
+	void zoomingXChanged();
+	void zoomingYChanged();
+
+
+private:
+
+	enum editModes
+	{
+		DRAW,
+		ERASE,
+		SELECT,
+		MOVE
+	} ;
+
+	enum actions
+	{
+		NONE,
+		MOVE_VALUE,
+		SELECT_VALUES,
+		MOVE_SELECTION
+	} ;
+
+	// some constants...
+	static const int INITIAL_WIDTH = 860;
+	static const int INITIAL_HEIGHT = 480;
+
+	static const int SCROLLBAR_SIZE = 16;
+	static const int TOP_MARGIN = 48;
+
+	static const int DEFAULT_Y_DELTA = 6;
+	static const int DEFAULT_STEPS_PER_TACT = 16;
+	static const int DEFAULT_PPT = 12 * DEFAULT_STEPS_PER_TACT;
+
+	static const int VALUES_WIDTH = 64;
+
+	AutomationEditor();
+	AutomationEditor( const AutomationEditor & );
+	virtual ~AutomationEditor();
+
+
+	static QPixmap * s_toolDraw;
+	static QPixmap * s_toolErase;
+	static QPixmap * s_toolSelect;
+	static QPixmap * s_toolMove;
+
+
+	QWidget * m_toolBar;
+
+	toolButton * m_playButton;
+	toolButton * m_stopButton;
+
+	toolButton * m_drawButton;
+	toolButton * m_eraseButton;
+	toolButton * m_selectButton;
+	toolButton * m_moveButton;
+
+	toolButton * m_discreteButton;
+	toolButton * m_linearButton;
+	toolButton * m_cubicHermiteButton;
+	knob * m_tensionKnob;
+	FloatModel * m_tensionModel;
+
+	toolButton * m_cutButton;
+	toolButton * m_copyButton;
+	toolButton * m_pasteButton;
+
+	comboBox * m_zoomingXComboBox;
+	comboBox * m_zoomingYComboBox;
+	comboBox * m_quantizeComboBox;
+
+	ComboBoxModel m_zoomingXModel;
+	ComboBoxModel m_zoomingYModel;
+	ComboBoxModel m_quantizeModel;
+
+	QMutex m_patternMutex;
+	AutomationPattern * m_pattern;
+	float m_minLevel;
+	float m_maxLevel;
+	float m_step;
+	float m_scrollLevel;
+	float m_bottomLevel;
+	float m_topLevel;
+
+	void updateTopBottomLevels();
+
+	QScrollBar * m_leftRightScroll;
+	QScrollBar * m_topBottomScroll;
+
+	MidiTime m_currentPosition;
+
+	actions m_action;
+
+	tick_t m_selectStartTick;
+	tick_t m_selectedTick;
+	float m_selectStartLevel;
+	float m_selectedLevels;
+
+	float m_moveStartLevel;
+	tick_t m_moveStartTick;
+	int m_moveXOffset;
+
+	float m_drawLastLevel;
+	tick_t m_drawLastTick;
+
+	int m_ppt;
+	int m_y_delta;
+	bool m_y_auto;
+
+	timeMap m_valuesToCopy;
+	timeMap m_selValuesForMove;
+
+
+	editModes m_editMode;
+
+
+	timeLine * m_timeLine;
+	bool m_scrollBack;
+
+	void drawCross( QPainter & _p );
+	void drawAutomationPoint( QPainter & p, timeMap::iterator it );
+	bool inBBEditor();
+
+
+
+	friend class engine;
+
+
+signals:
+	void currentPatternChanged();
+	void positionChanged( const MidiTime & );
+
+} ;
+
+
+#endif
diff --git a/lmms/include/AutomationPattern.h b/lmms/include/AutomationPattern.h
new file mode 100644
index 0000000..39dd0cf
--- /dev/null
+++ b/lmms/include/AutomationPattern.h
@@ -0,0 +1,190 @@
+/*
+ * AutomationPattern.h - declaration of class AutomationPattern, which contains
+ *                       all information about an automation pattern
+ *
+ * Copyright (c) 2008-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * Copyright (c) 2006-2008 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef AUTOMATION_PATTERN_H
+#define AUTOMATION_PATTERN_H
+
+#include <QtCore/QPointer>
+
+#include "track.h"
+
+
+class AutomationTrack;
+class MidiTime;
+
+
+
+class EXPORT AutomationPattern : public trackContentObject
+{
+	Q_OBJECT
+public:
+	enum ProgressionTypes
+	{
+		DiscreteProgression,
+		LinearProgression,
+		CubicHermiteProgression
+	} ;
+
+	typedef QMap<int, float> timeMap;
+	typedef QVector<QPointer<AutomatableModel> > objectVector;
+
+	AutomationPattern( AutomationTrack * _auto_track );
+	AutomationPattern( const AutomationPattern & _pat_to_copy );
+	virtual ~AutomationPattern();
+
+	void addObject( AutomatableModel * _obj, bool _search_dup = true );
+
+	const AutomatableModel * firstObject() const;
+
+	// progression-type stuff
+	inline ProgressionTypes progressionType() const
+	{
+		return m_progressionType;
+	}
+	void setProgressionType( ProgressionTypes _new_progression_type );
+
+	inline float getTension() const
+	{
+		return m_tension;
+	}
+	void setTension( QString _new_tension );
+
+	virtual MidiTime length() const;
+
+	MidiTime putValue( const MidiTime & _time, const float _value,
+						const bool _quant_pos = true );
+
+	void removeValue( const MidiTime & _time,
+					  const bool _quant_pos = true );
+
+	MidiTime setDragValue( const MidiTime & _time, const float _value,
+						   const bool _quant_pos = true );
+
+	void applyDragValue();
+
+
+	bool isDragging() const
+	{
+		return m_dragging;
+	}
+
+	inline const timeMap & getTimeMap() const
+	{
+		return m_timeMap;
+	}
+
+	inline timeMap & getTimeMap()
+	{
+		return m_timeMap;
+	}
+
+	inline const timeMap & getTangents() const
+	{
+		return m_tangents;
+	}
+
+	inline timeMap & getTangents()
+	{
+		return m_tangents;
+	}
+
+	inline float getMin() const
+	{
+		return firstObject()->minValue<float>();
+	}
+
+	inline float getMax() const
+	{
+		return firstObject()->maxValue<float>();
+	}
+
+	inline bool hasAutomation() const
+	{
+		return m_timeMap.isEmpty() == false;
+	}
+
+	float valueAt( const MidiTime & _time ) const;
+	float *valuesAfter( const MidiTime & _time ) const;
+
+	const QString name() const;
+
+	// settings-management
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+	static inline const QString classNodeName()
+	{
+		return "automationpattern";
+	}
+
+	inline virtual QString nodeName() const
+	{
+		return classNodeName();
+	}
+
+	void processMidiTime( const MidiTime & _time );
+
+	virtual trackContentObjectView * createView( trackView * _tv );
+
+
+	static bool isAutomated( const AutomatableModel * _m );
+	static AutomationPattern * globalAutomationPattern( AutomatableModel * _m );
+	static void resolveAllIDs();
+
+
+public slots:
+	void clear();
+	void openInAutomationEditor();
+	void objectDestroyed( jo_id_t );
+
+
+private:
+	void cleanObjects();
+	void generateTangents();
+	void generateTangents( timeMap::const_iterator it, int numToGenerate );
+	float valueAt( timeMap::const_iterator v, int offset ) const;
+
+	AutomationTrack * m_autoTrack;
+	QVector<jo_id_t> m_idsToResolve;
+	objectVector m_objects;
+	timeMap m_timeMap;	// actual values
+	timeMap m_oldTimeMap;	// old values for storing the values before setDragValue() is called.
+	timeMap m_tangents;	// slope at each point for calculating spline
+	float m_tension;
+	bool m_hasAutomation;
+	ProgressionTypes m_progressionType;
+
+	bool m_dragging;
+
+	static const float DEFAULT_MIN_VALUE;
+	static const float DEFAULT_MAX_VALUE;
+
+	friend class AutomationPatternView;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/AutomationPatternView.h b/lmms/include/AutomationPatternView.h
new file mode 100644
index 0000000..5d8bed1
--- /dev/null
+++ b/lmms/include/AutomationPatternView.h
@@ -0,0 +1,74 @@
+/*
+ * AutomationPatternView.h - declaration of class AutomationPatternView
+ *
+ * Copyright (c) 2008-2010 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef AUTOMATION_PATTERN_VIEW_H
+#define AUTOMATION_PATTERN_VIEW_H
+
+#include "track.h"
+
+class AutomationPattern;
+
+
+class AutomationPatternView : public trackContentObjectView
+{
+	Q_OBJECT
+public:
+	AutomationPatternView( AutomationPattern * _pat, trackView * _parent );
+	virtual ~AutomationPatternView();
+
+
+public slots:
+	virtual void update();
+
+
+protected slots:
+	void resetName();
+	void changeName();
+	void disconnectObject( QAction * _a );
+
+
+protected:
+	virtual void constructContextMenu( QMenu * );
+	virtual void mouseDoubleClickEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void resizeEvent( QResizeEvent * _re )
+	{
+		m_needsUpdate = true;
+		trackContentObjectView::resizeEvent( _re );
+	}
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+
+
+private:
+	AutomationPattern * m_pat;
+	QPixmap m_paintPixmap;
+	bool m_needsUpdate;
+
+	void scaleTimemapToFit( float oldMin, float oldMax );
+
+} ;
+
+
+#endif
diff --git a/lmms/include/AutomationTrack.h b/lmms/include/AutomationTrack.h
new file mode 100644
index 0000000..d6af755
--- /dev/null
+++ b/lmms/include/AutomationTrack.h
@@ -0,0 +1,73 @@
+/*
+ * AutomationTrack.h - declaration of class AutomationTrack, which handles
+ *                     automation of objects without a track
+ *
+ * Copyright (c) 2008-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * Copyright (c) 2006-2008 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef AUTOMATION_TRACK_H
+#define AUTOMATION_TRACK_H
+
+#include "track.h"
+
+
+class AutomationTrack : public track
+{
+public:
+	AutomationTrack( TrackContainer* tc, bool _hidden = false );
+	virtual ~AutomationTrack();
+
+	virtual bool play( const MidiTime & _start, const fpp_t _frames,
+						const f_cnt_t _frame_base, int _tco_num = -1 );
+
+	virtual QString nodeName() const
+	{
+		return "automationtrack";
+	}
+
+	virtual trackView * createView( TrackContainerView* );
+	virtual trackContentObject * createTCO( const MidiTime & _pos );
+
+	virtual void saveTrackSpecificSettings( QDomDocument & _doc,
+							QDomElement & _parent );
+	virtual void loadTrackSpecificSettings( const QDomElement & _this );
+
+private:
+	friend class AutomationTrackView;
+
+} ;
+
+
+
+class AutomationTrackView : public trackView
+{
+public:
+	AutomationTrackView( AutomationTrack* at, TrackContainerView* tcv );
+	virtual ~AutomationTrackView();
+
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+
+} ;
+
+
+#endif
diff --git a/lmms/include/Clipboard.h b/lmms/include/Clipboard.h
new file mode 100644
index 0000000..58d9a58
--- /dev/null
+++ b/lmms/include/Clipboard.h
@@ -0,0 +1,53 @@
+/*
+ * Clipboard.h - the clipboard for patterns, notes etc.
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _CLIPBOARD_H
+#define _CLIPBOARD_H
+
+#include <QtCore/QMap>
+#include <QtXml/QDomElement>
+
+
+class JournallingObject;
+
+class Clipboard
+{
+public:
+	typedef QMap<QString, QDomElement> Map;
+
+	static void copy( JournallingObject * _object );
+	static const QDomElement * getContent( const QString & _node_name );
+
+	static const char * mimeType()
+	{
+		return( "application/x-lmms-clipboard" );
+	}
+
+
+private:
+	static Map content;
+
+} ;
+
+#endif
diff --git a/lmms/include/ComboBoxModel.h b/lmms/include/ComboBoxModel.h
new file mode 100644
index 0000000..b11af88
--- /dev/null
+++ b/lmms/include/ComboBoxModel.h
@@ -0,0 +1,93 @@
+/*
+ * ComboBoxModel.h - declaration of class ComboBoxModel
+ *
+ * Copyright (c) 2008-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _COMBOBOX_MODEL_H
+#define _COMBOBOX_MODEL_H
+
+#include <QtCore/QVector>
+#include <QtCore/QPair>
+
+#include "AutomatableModel.h"
+#include "templates.h"
+
+class PixmapLoader;
+
+
+class EXPORT ComboBoxModel : public IntModel
+{
+	Q_OBJECT
+public:
+	ComboBoxModel( Model* parent = NULL,
+					const QString& displayName = QString(),
+					bool isDefaultConstructed = false ) :
+		IntModel( 0, 0, 0, parent, displayName, isDefaultConstructed )
+	{
+	}
+
+	virtual ~ComboBoxModel()
+	{
+		clear();
+	}
+
+	void addItem( const QString& item, PixmapLoader* loader = NULL );
+
+	void clear();
+
+	int findText( const QString& txt ) const;
+
+	QString currentText() const
+	{
+		return ( size() > 0 && value() < size() ) ? m_items[value()].first : QString();
+	}
+
+	const PixmapLoader* currentData() const
+	{
+		return m_items[value()].second;
+	}
+
+	const QString & itemText( int i ) const
+	{
+		return m_items[qBound<int>( minValue(), i,  maxValue() )].first;
+	}
+
+	const PixmapLoader* itemPixmap( int i ) const
+	{
+		return m_items[qBound<int>( minValue(), i, maxValue() )].second;
+	}
+
+	int size() const
+	{
+		return m_items.size();
+	}
+
+
+private:
+	typedef QPair<QString, PixmapLoader *> Item;
+
+	QVector<Item> m_items;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/Controller.h b/lmms/include/Controller.h
new file mode 100644
index 0000000..5a7d5a8
--- /dev/null
+++ b/lmms/include/Controller.h
@@ -0,0 +1,164 @@
+/*
+ * Controller.h - declaration of class controller, which provides a
+ *                standard for all controllers and controller plugins
+ *
+ * Copyright (c) 2008-2009 Paul Giblock <pgllama/at/gmail.com>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _CONTROLLER_H
+#define _CONTROLLER_H
+
+#include "engine.h"
+#include "Mixer.h"
+#include "Model.h"
+#include "JournallingObject.h"
+
+class ControllerDialog;
+class Controller;
+class ControllerConnection;
+
+typedef QVector<Controller *> ControllerVector;
+
+
+class Controller : public Model, public JournallingObject
+{
+	Q_OBJECT
+public:
+	enum ControllerTypes
+	{
+		DummyController,
+		LfoController,
+		MidiController,
+		PeakController,
+		/*
+		XYController,
+		EquationController
+		*/
+		NumControllerTypes
+	} ;
+
+	Controller( ControllerTypes _type, Model * _parent,
+						const QString & _display_name );
+
+	virtual ~Controller();
+
+	virtual float currentValue( int _offset );
+
+	inline bool isSampleExact() const
+	{
+		return m_sampleExact ||
+			engine::mixer()->currentQualitySettings().
+							sampleExactControllers;
+	}
+
+	void setSampleExact( bool _exact )
+	{
+		m_sampleExact = _exact;
+	}
+
+	inline ControllerTypes type() const
+	{
+		return( m_type );
+	}
+
+	// return whether this controller updates models frequently - used for
+	// determining when to update GUI
+	inline bool frequentUpdates() const
+	{
+		switch( m_type )
+		{
+			case LfoController: return( true );
+			case PeakController: return( true );
+			default:
+				break;
+		}
+		return( false );
+	}
+
+	virtual const QString & name() const
+	{
+		return( m_name );
+	}
+
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _this );
+	virtual void loadSettings( const QDomElement & _this );
+	virtual QString nodeName() const;
+
+	static Controller * create( ControllerTypes _tt, Model * _parent );
+	static Controller * create( const QDomElement & _this,
+							Model * _parent );
+
+	inline static float fittedValue( float _val )
+	{
+		return tLimit<float>( _val, 0.0f, 1.0f );
+	}
+
+	static unsigned int runningFrames();
+	static float runningTime();
+
+	static void triggerFrameCounter();
+	static void resetFrameCounter();
+
+	//Accepts a ControllerConnection * as it may be used in the future.
+	void addConnection( ControllerConnection * );
+	void removeConnection( ControllerConnection * );
+	int connectionCount() const;
+
+
+public slots:
+	virtual ControllerDialog * createDialog( QWidget * _parent );
+
+	virtual void setName( const QString & _new_name )
+	{
+		m_name = _new_name;
+	}
+
+	bool hasModel( const Model * m );
+
+
+protected:
+	// The internal per-controller get-value function
+	virtual float value( int _offset );
+
+	float m_currentValue;
+	bool  m_sampleExact;
+	int m_connectionCount;
+
+	QString m_name;
+	ControllerTypes m_type;
+
+	static ControllerVector s_controllers;
+
+	static unsigned int s_frames;
+
+
+signals:
+	// The value changed while the mixer isn't running (i.e: MIDI CC)
+	void valueChanged();
+
+	friend class ControllerDialog;
+
+} ;
+
+#endif
+
diff --git a/lmms/include/ControllerConnection.h b/lmms/include/ControllerConnection.h
new file mode 100644
index 0000000..440960f
--- /dev/null
+++ b/lmms/include/ControllerConnection.h
@@ -0,0 +1,117 @@
+/*
+ * ControllerConnection.h - declaration of a controller connect, which
+ *              provides a definition of the link between a controller and
+ *              model, also handles deferred creation of links while
+ *              loading project
+ *
+ * Copyright (c) 2008 Paul Giblock <pgllama/at/gmail.com>
+ * Copyright (c) 2010 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _CONTROLLER_CONNECTION_H
+#define _CONTROLLER_CONNECTION_H
+
+#include <QtCore/QObject>
+#include <QtCore/QVector>
+
+#include "Controller.h"
+#include "JournallingObject.h"
+
+class ControllerConnection;
+
+typedef QVector<ControllerConnection *> ControllerConnectionVector;
+
+
+class EXPORT ControllerConnection : public QObject, public JournallingObject
+{
+	Q_OBJECT
+public:
+
+	ControllerConnection( Controller * _controller );
+	ControllerConnection( int _controllerId );
+
+	virtual ~ControllerConnection();
+
+	inline Controller * getController()
+	{
+		return m_controller;
+	}
+
+	void setController( Controller * _controller );
+
+	inline void setController( int _controllerId );
+
+	float currentValue( int _offset )
+	{
+		return m_controller->currentValue( _offset );
+	}
+
+	inline void setTargetName( const QString & _name );
+
+	inline QString targetName() const
+	{
+		return m_targetName;
+	}
+
+	inline bool isFinalized()
+	{
+		return m_controllerId < 0;
+	}
+
+	static void finalizeConnections();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _this );
+	virtual void loadSettings( const QDomElement & _this );
+
+	static inline const QString classNodeName()
+	{
+		return "connection";
+	}
+
+	virtual QString nodeName() const
+	{
+		return classNodeName();
+	}
+
+
+public slots:
+	void deleteConnection();
+
+protected:
+	//virtual controllerDialog * createDialog( QWidget * _parent );
+	Controller * m_controller;
+	QString m_targetName;
+	int m_controllerId;	
+	
+	bool m_ownsController;
+
+	static ControllerConnectionVector s_connections;
+
+signals:
+	// The value changed while the mixer isn't running (i.e: MIDI CC)
+	void valueChanged();
+
+	friend class ControllerConnectionDialog;
+};
+
+#endif
+
diff --git a/lmms/include/ControllerConnectionDialog.h b/lmms/include/ControllerConnectionDialog.h
new file mode 100644
index 0000000..9d8a6ca
--- /dev/null
+++ b/lmms/include/ControllerConnectionDialog.h
@@ -0,0 +1,101 @@
+/*
+ * ControllerConnectionDialog.h - dialog allowing the user to create and
+ *	modify links between controllers and models
+ *
+ * Copyright (c) 2008  Paul Giblock <drfaygo/at/gmail.com>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _CONTROLLER_CONNECTION_DIALOG_H
+#define _CONTROLLER_CONNECTION_DIALOG_H
+
+#include <QtGui/QDialog>
+#include <QtGui/QSortFilterProxyModel>
+#include <QtGui/QStandardItemModel>
+
+#include "Controller.h"
+#include "AutomatableModel.h"
+
+
+class QLineEdit;
+class QListView;
+class QScrollArea;
+class AutoDetectMidiController;
+class comboBox;
+class groupBox;
+class tabWidget;
+class LcdSpinBox;
+class ledCheckBox;
+class MidiPortMenu;
+
+
+
+class ControllerConnectionDialog : public QDialog
+{
+	Q_OBJECT
+public:
+	ControllerConnectionDialog( QWidget * _parent,
+			const AutomatableModel * _target_model );
+	virtual ~ControllerConnectionDialog();
+
+	Controller * chosenController()
+	{
+		return m_controller;
+	}
+
+public slots:
+//	void setSelection( const effectKey & _selection );
+	void selectController();
+	void midiToggled();
+	void userToggled();
+	void autoDetectToggled();
+	void enableAutoDetect( QAction * _a );
+
+
+protected slots:
+	void midiValueChanged();
+
+
+private:
+	// Midi
+	groupBox * m_midiGroupBox;
+	LcdSpinBox * m_midiChannelSpinBox;
+	LcdSpinBox * m_midiControllerSpinBox;
+	ledCheckBox * m_midiAutoDetectCheckBox;
+	MidiPortMenu * m_readablePorts;
+	BoolModel m_midiAutoDetect;
+
+	// User
+	groupBox * m_userGroupBox;
+	comboBox * m_userController;
+
+	// Mapping
+	tabWidget * m_mappingBox;
+	QLineEdit * m_mappingFunction;
+
+	Controller * m_controller;
+	const AutomatableModel * m_targetModel;
+
+	// Temporary midiController 
+	AutoDetectMidiController * m_midiController;
+} ;
+
+#endif
diff --git a/lmms/include/ControllerDialog.h b/lmms/include/ControllerDialog.h
new file mode 100644
index 0000000..3c82ccf
--- /dev/null
+++ b/lmms/include/ControllerDialog.h
@@ -0,0 +1,54 @@
+/*
+ * ControllerDialog.h - per-controller-specific view for changing a
+ *                      controller's settings
+ *
+ * Copyright (c) 2008-2009 Paul Giblock <drfaygo/at/gmail.com>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _CONTROLLER_DIALOG_H
+#define _CONTROLLER_DIALOG_H
+
+#include <QtGui/QWidget>
+
+#include "ModelView.h"
+
+class Controller;
+
+
+class ControllerDialog : public QWidget, public ModelView
+{
+    Q_OBJECT
+public:
+	ControllerDialog( Controller * _controller, QWidget * _parent );
+
+	virtual ~ControllerDialog();
+
+
+signals:
+	void closed();
+
+
+protected:
+	virtual void closeEvent( QCloseEvent * _ce );
+
+} ;
+
+#endif
diff --git a/lmms/include/ControllerRackView.h b/lmms/include/ControllerRackView.h
new file mode 100644
index 0000000..60c8f07
--- /dev/null
+++ b/lmms/include/ControllerRackView.h
@@ -0,0 +1,73 @@
+/*
+ * ControllerRackView.h - view for song's controllers
+ *
+ * Copyright (c) 2008-2009 Paul Giblock <drfaygo/at/gmail.com>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _CONTROLLER_RACK_VIEW_H
+#define _CONTROLLER_RACK_VIEW_H
+
+#include <QtGui/QWidget>
+
+#include "SerializingObject.h"
+#include "lmms_basics.h"
+
+
+class QPushButton;
+class QScrollArea;
+
+class ControllerView;
+
+
+class ControllerRackView : public QWidget, public SerializingObject
+{
+	Q_OBJECT
+public:
+	ControllerRackView();
+	virtual ~ControllerRackView();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+	inline virtual QString nodeName() const
+	{
+		return "ControllerRackView";
+	}
+
+
+public slots:
+	void deleteController( ControllerView * _view );
+
+
+private slots:
+	virtual void update();
+	void addController();
+
+
+private:
+	QVector<ControllerView *> m_controllerViews;
+
+	QScrollArea * m_scrollArea;
+	QPushButton * m_addButton;
+
+} ;
+
+#endif
diff --git a/lmms/include/ControllerView.h b/lmms/include/ControllerView.h
new file mode 100644
index 0000000..c86b47c
--- /dev/null
+++ b/lmms/include/ControllerView.h
@@ -0,0 +1,86 @@
+/*
+ * ControllerView.h - view-component for an control
+ *
+ * Copyright (c) 2008 Paul Giblock <drfaygo/at/gmail.com>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _CONTROLLER_VIEW_H
+#define _CONTROLLER_VIEW_H
+
+#include <QtGui/QWidget>
+
+#include "AutomatableModel.h"
+#include "Controller.h"
+#include "ModelView.h"
+
+class QGroupBox;
+class QLabel;
+class QPushButton;
+class QMdiSubWindow;
+
+class ledCheckBox;
+
+
+class ControllerView : public QWidget, public ModelView
+{
+	Q_OBJECT
+public:
+	ControllerView( Controller * _controller, QWidget * _parent );
+	virtual ~ControllerView();
+	
+	inline Controller * getController()
+	{
+		return( castModel<Controller>() );
+	}
+
+	inline const Controller * getController() const
+	{
+		return( castModel<Controller>() );
+	}
+
+
+public slots:
+	void editControls();
+	void deleteController();
+	void displayHelp();
+	void closeControls();
+
+	
+signals:
+	void deleteController( ControllerView * _view );
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void modelChanged();
+	virtual void mouseDoubleClickEvent( QMouseEvent * event );
+
+
+private:
+	QPixmap m_bg;
+	QMdiSubWindow * m_subWindow;
+	ControllerDialog * m_controllerDlg;
+	bool m_show;
+
+} ;
+
+#endif
diff --git a/lmms/include/DataFile.h b/lmms/include/DataFile.h
new file mode 100644
index 0000000..499853b
--- /dev/null
+++ b/lmms/include/DataFile.h
@@ -0,0 +1,112 @@
+/*
+ * DataFile.h - class for reading and writing LMMS data files
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * Copyright (c) 2012-2013 Paul Giblock <p/at/pgiblock.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef DATA_FILE_H
+#define DATA_FILE_H
+
+#include <QtXml/QDomDocument>
+#include <QTextStream>
+
+#include "export.h"
+#include "lmms_basics.h"
+
+
+class EXPORT DataFile : public QDomDocument
+{
+public:
+	enum Types
+	{
+		UnknownType,
+		SongProject,
+		SongProjectTemplate,
+		InstrumentTrackSettings,
+		DragNDropData,
+		ClipboardData,
+		JournalData,
+		EffectSettings,
+		TypeCount
+	} ;
+	typedef Types Type;
+
+	DataFile( const QString& fileName );
+	DataFile( const QByteArray& data );
+	DataFile( Type type );
+
+	virtual ~DataFile();
+
+	QString nameWithExtension( const QString& fn ) const;
+
+	void write( QTextStream& strm );
+	bool writeFile( const QString& fn );
+
+	QDomElement& content()
+	{
+		return m_content;
+	}
+
+	QDomElement& head()
+	{
+		return m_head;
+	}
+
+	Type type() const
+	{
+		return m_type;
+	}
+
+
+private:
+	static Type type( const QString& typeName );
+	static QString typeName( Type type );
+
+	void cleanMetaNodes( QDomElement de );
+
+	void upgrade();
+
+	void loadData( const QByteArray & _data, const QString & _sourceFile );
+
+
+	struct EXPORT typeDescStruct
+	{
+		Type m_type;
+		QString m_name;
+	} ;
+	static typeDescStruct s_types[TypeCount];
+
+	QDomElement m_content;
+	QDomElement m_head;
+	Type m_type;
+
+} ;
+
+
+const int LDF_MAJOR_VERSION = 1;
+const int LDF_MINOR_VERSION = 0;
+const QString LDF_VERSION_STRING = QString::number( LDF_MAJOR_VERSION ) + "." + QString::number( LDF_MINOR_VERSION );
+
+
+#endif
+
diff --git a/lmms/include/DetuningHelper.h b/lmms/include/DetuningHelper.h
new file mode 100644
index 0000000..2d675ca
--- /dev/null
+++ b/lmms/include/DetuningHelper.h
@@ -0,0 +1,62 @@
+/*
+ * detuning_helper.h - detuning automation helper
+ *
+ * Copyright (c) 2007 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * Copyright (c) 2008-2010 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _DETUNING_HELPER_H
+#define _DETUNING_HELPER_H
+
+#include "InlineAutomation.h"
+
+
+class DetuningHelper : public InlineAutomation
+{
+public:
+	DetuningHelper() :
+		InlineAutomation()
+	{
+	}
+
+	virtual ~DetuningHelper()
+	{
+	}
+
+	virtual float defaultValue() const
+	{
+		return 0;
+	}
+
+	virtual QString displayName() const
+	{
+		return tr( "Note detuning" );
+	}
+
+	inline virtual QString nodeName() const
+	{
+		return "detuning";
+	}
+
+} ;
+
+
+#endif
diff --git a/lmms/include/DspEffectLibrary.h b/lmms/include/DspEffectLibrary.h
new file mode 100644
index 0000000..5231184
--- /dev/null
+++ b/lmms/include/DspEffectLibrary.h
@@ -0,0 +1,352 @@
+/*
+ * DspEffectLibrary.h - library with template-based inline-effects
+ *
+ * Copyright (c) 2006-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _DSP_EFFECT_LIBRARY_H
+#define _DSP_EFFECT_LIBRARY_H
+
+#include <math.h>
+
+#include "templates.h"
+#include "lmms_constants.h"
+#include "lmms_basics.h"
+
+
+namespace DspEffectLibrary
+{
+
+	template<typename T>
+	class MonoBase
+	{
+	public:
+		typedef class MonoBypass bypassType;
+
+		static void process( sample_t * * _buf, const f_cnt_t _frames )
+		{
+			for( f_cnt_t f = 0; f < _frames; ++f )
+			{
+				_buf[f][0] = T::nextSample( _buf[f][0] );
+			}
+		}
+	} ;
+
+	template<typename T>
+	class StereoBase
+	{
+	public:
+		typedef class StereoBypass bypassType;
+
+		static void process( sample_t * * _buf, const f_cnt_t _frames )
+		{
+			for( f_cnt_t f = 0; f < _frames; ++f )
+			{
+				T::nextSample( _buf[f][0], _buf[f][1] );
+			}
+		}
+	} ;
+
+
+	template<class FXL, class FXR = FXL>
+	class MonoToStereoAdaptor : public StereoBase<MonoToStereoAdaptor<FXL, FXR> >
+	{
+	public:
+		MonoToStereoAdaptor( const FXL& monoFX ) :
+			m_leftFX( monoFX ),
+			m_rightFX( monoFX )
+		{
+		}
+
+		MonoToStereoAdaptor( const FXL& leftFX, const FXR& rightFX ) :
+			m_leftFX( leftFX ),
+			m_rightFX( rightFX )
+		{
+		}
+
+		void nextSample( sample_t& inLeft, sample_t& inRight )
+		{
+			inLeft = m_leftFX.nextSample( inLeft );
+			inRight = m_rightFX.nextSample( inRight );
+		}
+
+		FXL& leftFX()
+		{
+			return( m_leftFX );
+		}
+
+		FXR& rightFX()
+		{
+			return( m_rightFX );
+		}
+
+	private:
+		FXL m_leftFX;
+		FXR m_rightFX;
+	} ;
+
+
+	template<class FX>
+	class StereoToMonoAdaptor : public MonoBase<StereoToMonoAdaptor<FX> >
+	{
+	public:
+		StereoToMonoAdaptor( const FX& fx ) :
+			m_FX( fx )
+		{
+		}
+
+		sample_t nextSample( sample_t in )
+		{
+			sample_t s[2] = { in, in };
+			m_FX.nextSample( s[0], s[1] );
+
+			return ( s[0] + s[1] ) / 2.0f;
+		}
+
+	private:
+		FX m_FX;
+
+	} ;
+
+	class MonoBypass : public MonoBase<MonoBypass>
+	{
+	public:
+		sample_t nextSample( sample_t in )
+		{
+			return in;
+		}
+	} ;
+
+
+	class StereoBypass : public StereoBase<StereoBypass>
+	{
+	public:
+		void nextSample( sample_t&, sample_t& )
+		{
+		}
+	} ;
+
+	/* convenient class to build up static FX chains, for example
+
+	using namespace DspEffectLib;
+	chain<MonoToStereoAdaptor<bassBoost<> >,
+		chain<StereoEnhancer<>,
+			MonoToStereoAdaptor<FoldbackDistortion<> > > >
+				fxchain( bassBoost<>( 60.0, 1.0, 4.0f ),
+		chain<StereoEnhancer<>,
+			MonoToStereoAdaptor<FoldbackDistortion<> > >(
+				StereoEnhancer<>( 1.0 ),
+					FoldbackDistortion<>( 1.0f, 1.0f ) ) );
+
+	// now you can do simple calls such as which will process a bass-boost-,
+	// stereo enhancer- and foldback distortion effect on your buffer
+        fx_chain.process( (sample_t * *) buf, frames );
+*/
+
+	template<class FX0, class FX1 = typename FX0::bypassType>
+	class Chain : public FX0::bypassType
+	{
+	public:
+		typedef typename FX0::sample_t sample_t;
+		Chain( const FX0& fx0, const FX1& fx1 = FX1() ) :
+			m_FX0( fx0 ),
+			m_FX1( fx1 )
+		{
+		}
+
+		void process( sample_t** buf, const f_cnt_t frames )
+		{
+			m_FX0.process( buf, frames );
+			m_FX1.process( buf, frames );
+		}
+
+	private:
+		FX0 m_FX0;
+		FX1 m_FX1;
+
+	} ;
+
+
+
+	template<typename sample_t>
+	inline sample_t saturate( sample_t x )
+	{
+		return qMin<sample_t>( qMax<sample_t>( -1.0f, x ), 1.0f );
+	}
+
+
+	class FastBassBoost : public MonoBase<FastBassBoost>
+	{
+	public:
+		FastBassBoost( const sample_t _frequency,
+				const sample_t _gain,
+				const sample_t _ratio,
+				const FastBassBoost & _orig = FastBassBoost() ) :
+			m_frequency( qMax<sample_t>( _frequency, 10.0 ) ),
+			m_gain1( 1.0 / ( m_frequency + 1.0 ) ),
+			m_gain2( _gain ),
+			m_ratio( _ratio ),
+			m_cap( _orig.m_cap )
+		{
+		}
+
+		inline sample_t nextSample( sample_t _in )
+		{
+			// TODO: somehow remove these horrible aliases...
+			m_cap = ( _in + m_cap*m_frequency ) * m_gain1;
+			return( /*saturate<sample_t>(*/ ( _in + m_cap*m_ratio ) *
+								m_gain2/* )*/ );
+		}
+
+		void setFrequency( const sample_t _frequency )
+		{
+			m_frequency = _frequency;
+			m_gain1 = 1.0 / ( m_frequency + 1.0 );
+		}
+
+		void setGain( const sample_t _gain )
+		{
+			m_gain2 = _gain;
+		}
+
+		void setRatio( const sample_t _ratio )
+		{
+			m_ratio = _ratio;
+		}
+
+	private:
+		FastBassBoost() :
+			m_cap( 0.0 )
+		{
+		}
+
+		sample_t m_frequency;
+		sample_t m_gain1;
+		sample_t m_gain2;
+		sample_t m_ratio;
+		sample_t m_cap;
+	} ;
+
+
+	class FoldbackDistortion : public MonoBase<FoldbackDistortion>
+	{
+	public:
+		FoldbackDistortion( float threshold, float gain ) :
+			m_threshold( threshold ),
+			m_gain( gain )
+		{
+		}
+
+		sample_t nextSample( sample_t in )
+		{
+			if( in >= m_threshold || in < -m_threshold )
+			{
+				return ( fabsf( fabsf( fmodf( in - m_threshold, m_threshold*4 ) ) - m_threshold*2 ) - m_threshold ) * m_gain;
+			}
+			return in * m_gain;
+		}
+
+		void setThreshold( float threshold )
+		{
+			m_threshold = threshold;
+		}
+
+		void setGain( float gain )
+		{
+			m_gain = gain;
+		}
+
+
+	private:
+		float m_threshold;
+		float m_gain;
+
+	} ;
+
+
+	class Distortion : public MonoBase<Distortion>
+	{
+	public:
+		Distortion( float threshold, float gain ) :
+			m_threshold( threshold ),
+			m_gain( gain )
+		{
+		}
+
+		sample_t nextSample( sample_t in )
+		{
+			return m_gain * ( in * ( fabsf( in )+m_threshold ) / ( in*in +( m_threshold-1 )* fabsf( in ) + 1 ) );
+		}
+
+		void setThreshold( float threshold )
+		{
+			m_threshold = threshold;
+		}
+
+		void setGain( float gain )
+		{
+			m_gain = gain;
+		}
+
+
+	private:
+		float m_threshold;
+		float m_gain;
+
+	} ;
+
+
+	class StereoEnhancer : public StereoBase<StereoEnhancer>
+	{
+	public:
+		StereoEnhancer( float wideCoeff ) :
+			m_wideCoeff( wideCoeff )
+		{
+		}
+
+		void setWideCoeff( float wideCoeff )
+		{
+			m_wideCoeff = wideCoeff;
+		}
+
+		float wideCoeff()
+		{
+			return m_wideCoeff;
+		}
+
+		void nextSample( sample_t& inLeft, sample_t& inRight )
+		{
+			const float toRad = 3.141592 / 180;
+
+			inLeft += inRight * sinf( m_wideCoeff * .5 * toRad);
+			inRight -= inLeft * sinf( m_wideCoeff * .5 * toRad);
+		}
+
+	private:
+		float m_wideCoeff;
+
+	} ;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/DummyEffect.h b/lmms/include/DummyEffect.h
new file mode 100644
index 0000000..33cff9a
--- /dev/null
+++ b/lmms/include/DummyEffect.h
@@ -0,0 +1,112 @@
+/*
+ * DummyEffect.h - effect used as fallback if an effect couldn't be loaded
+ *
+ * Copyright (c) 2006-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _DUMMY_EFFECT_H
+#define _DUMMY_EFFECT_H
+
+#include "Effect.h"
+#include "EffectControls.h"
+#include "EffectControlDialog.h"
+
+
+class DummyEffectControlDialog : public EffectControlDialog
+{
+public:
+	DummyEffectControlDialog( EffectControls * _controls ) :
+		EffectControlDialog( _controls )
+	{
+	}
+
+} ;
+
+
+class DummyEffectControls : public EffectControls
+{
+public:
+	DummyEffectControls( Effect * _eff ) :
+		EffectControls( _eff )
+	{
+	}
+
+	virtual ~DummyEffectControls()
+	{
+	}
+
+	virtual int controlCount()
+	{
+		return 0;
+	}
+
+	inline virtual void saveSettings( QDomDocument &, QDomElement & )
+	{
+	}
+
+	inline virtual void loadSettings( const QDomElement & )
+	{
+	}
+
+	inline virtual QString nodeName() const
+	{
+		return "DummyControls";
+	}
+
+	virtual EffectControlDialog * createView()
+	{
+		return new DummyEffectControlDialog( this );
+	}
+} ;
+
+
+
+class DummyEffect : public Effect
+{
+public:
+	inline DummyEffect( Model * _parent ) :
+		Effect( NULL, _parent, NULL ),
+		m_controls( this )
+	{
+	}
+
+	inline virtual ~DummyEffect()
+	{
+	}
+
+	inline virtual EffectControls * controls()
+	{
+		return &m_controls;
+	}
+
+	bool processAudioBuffer( sampleFrame *, const fpp_t )
+	{
+		return false;
+	}
+
+
+private:
+	DummyEffectControls m_controls;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/DummyInstrument.h b/lmms/include/DummyInstrument.h
new file mode 100644
index 0000000..ee9e5d3
--- /dev/null
+++ b/lmms/include/DummyInstrument.h
@@ -0,0 +1,69 @@
+/*
+ * DummyInstrument.h - instrument used as fallback if an instrument couldn't
+ *                     be loaded
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _DUMMY_INSTRUMENT_H
+#define _DUMMY_INSTRUMENT_H
+
+#include "Instrument.h"
+#include "InstrumentView.h"
+
+
+class DummyInstrument : public Instrument
+{
+public:
+	DummyInstrument( InstrumentTrack * _instrument_track ) :
+		Instrument( _instrument_track, NULL )
+	{
+	}
+
+	virtual ~DummyInstrument()
+	{
+	}
+
+	virtual void playNote( NotePlayHandle *, sampleFrame * )
+	{
+	}
+
+	virtual void saveSettings( QDomDocument &, QDomElement & )
+	{
+	}
+
+	virtual void loadSettings( const QDomElement & )
+	{
+	}
+
+	virtual QString nodeName() const
+	{
+		return "dummyinstrument";
+	}
+
+	virtual PluginView * instantiateView( QWidget * _parent )
+	{
+		return new InstrumentView( this, _parent );
+	}
+} ;
+
+
+#endif
diff --git a/lmms/include/DummyPlugin.h b/lmms/include/DummyPlugin.h
new file mode 100644
index 0000000..d0cf0b9
--- /dev/null
+++ b/lmms/include/DummyPlugin.h
@@ -0,0 +1,68 @@
+/*
+ * DummyPlugin.h - empty plugin which is used as fallback if a plugin couldn't
+ *                 be found
+ *
+ * Copyright (c) 2005-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _DUMMY_PLUGIN_H
+#define _DUMMY_PLUGIN_H
+
+#include "Plugin.h"
+#include "PluginView.h"
+
+
+class DummyPlugin : public Plugin
+{
+public:
+	DummyPlugin() :
+		Plugin( NULL, NULL )
+	{
+	}
+
+	virtual ~DummyPlugin()
+	{
+	}
+
+	virtual void saveSettings( QDomDocument &, QDomElement & )
+	{
+	}
+
+	virtual void loadSettings( const QDomElement & )
+	{
+	}
+
+	virtual QString nodeName() const
+	{
+		return "DummyPlugin";
+	}
+
+
+protected:
+	virtual PluginView * instantiateView( QWidget * _parent )
+	{
+		return new PluginView( this, _parent );
+	}
+
+} ;
+
+
+#endif
diff --git a/lmms/include/Effect.h b/lmms/include/Effect.h
new file mode 100644
index 0000000..10d3fcf
--- /dev/null
+++ b/lmms/include/Effect.h
@@ -0,0 +1,231 @@
+/*
+ * Effect.h - base class for effects
+ *
+ * Copyright (c) 2006-2007 Danny McRae <khjklujn/at/users.sourceforge.net>
+ * Copyright (c) 2006-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _EFFECT_H
+#define _EFFECT_H
+
+#include "Plugin.h"
+#include "engine.h"
+#include "Mixer.h"
+#include "AutomatableModel.h"
+#include "TempoSyncKnobModel.h"
+
+
+class EffectChain;
+class EffectControls;
+
+
+class EXPORT Effect : public Plugin
+{
+public:
+	Effect( const Plugin::Descriptor * _desc,
+			Model * _parent,
+			const Descriptor::SubPluginFeatures::Key * _key );
+	virtual ~Effect();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+	inline virtual QString nodeName() const
+	{
+		return "effect";
+	}
+
+	
+	virtual bool processAudioBuffer( sampleFrame * _buf,
+						const fpp_t _frames ) = 0;
+
+	inline ch_cnt_t processorCount() const
+	{
+		return m_processors;
+	}
+
+	inline void setProcessorCount( ch_cnt_t _processors )
+	{
+		m_processors = _processors;
+	}
+
+	inline bool isOkay() const
+	{
+		return m_okay;
+	}
+
+	inline void setOkay( bool _state )
+	{
+		m_okay = _state;
+	}
+
+
+	inline bool isRunning() const
+	{
+		return m_running;
+	}
+
+	inline void startRunning() 
+	{ 
+		m_bufferCount = 0;
+		m_running = true; 
+	}
+
+	inline void stopRunning()
+	{
+		m_running = false;
+	}
+
+	inline bool isEnabled() const
+	{
+		return m_enabledModel.value();
+	}
+
+	inline f_cnt_t timeout() const
+	{
+		const float samples = engine::mixer()->processingSampleRate() * m_autoQuitModel.value() / 1000.0f;
+		return 1 + ( static_cast<int>( samples ) / engine::mixer()->framesPerPeriod() );
+	}
+
+	inline float wetLevel() const
+	{
+		return m_wetDryModel.value();
+	}
+
+	inline float dryLevel() const
+	{
+		return 1.0f - m_wetDryModel.value();
+	}
+
+	inline float gate() const
+	{
+		const float level = m_gateModel.value();
+		return level*level * m_processors *
+				engine::mixer()->framesPerPeriod();
+	}
+
+	inline f_cnt_t bufferCount() const
+	{
+		return m_bufferCount;
+	}
+
+	inline void resetBufferCount()
+	{
+		m_bufferCount = 0;
+	}
+
+	inline void incrementBufferCount()
+	{
+		++m_bufferCount;
+	}
+
+	inline bool dontRun() const
+	{
+		return m_noRun;
+	}
+
+	inline void setDontRun( bool _state )
+	{
+		m_noRun = _state;
+	}
+
+	inline const Descriptor::SubPluginFeatures::Key & key() const
+	{
+		return m_key;
+	}
+
+	EffectChain * effectChain() const
+	{
+		return m_parent;
+	}
+
+	virtual EffectControls * controls() = 0;
+
+	static Effect * instantiate( const QString & _plugin_name,
+				Model * _parent,
+				Descriptor::SubPluginFeatures::Key * _key );
+
+
+protected:
+	void checkGate( double _out_sum );
+
+	virtual PluginView * instantiateView( QWidget * );
+
+	// some effects might not be capable of higher sample-rates so they can
+	// sample it down before processing and back after processing
+	inline void sampleDown( const sampleFrame * _src_buf,
+							sampleFrame * _dst_buf,
+							sample_rate_t _dst_sr )
+	{
+		resample( 0, _src_buf,
+				engine::mixer()->processingSampleRate(),
+					_dst_buf, _dst_sr,
+					engine::mixer()->framesPerPeriod() );
+	}
+
+	inline void sampleBack( const sampleFrame * _src_buf,
+							sampleFrame * _dst_buf,
+							sample_rate_t _src_sr )
+	{
+		resample( 1, _src_buf, _src_sr, _dst_buf,
+				engine::mixer()->processingSampleRate(),
+			engine::mixer()->framesPerPeriod() * _src_sr /
+				engine::mixer()->processingSampleRate() );
+	}
+	void reinitSRC();
+
+
+private:
+	EffectChain * m_parent;
+	void resample( int _i, const sampleFrame * _src_buf,
+					sample_rate_t _src_sr,
+					sampleFrame * _dst_buf, sample_rate_t _dst_sr,
+					const f_cnt_t _frames );
+
+	Descriptor::SubPluginFeatures::Key m_key;
+
+	ch_cnt_t m_processors;
+
+	bool m_okay;
+	bool m_noRun;
+	bool m_running;
+	f_cnt_t m_bufferCount;
+
+	BoolModel m_enabledModel;
+	FloatModel m_wetDryModel;
+	FloatModel m_gateModel;
+	TempoSyncKnobModel m_autoQuitModel;
+
+	SRC_DATA m_srcData[2];
+	SRC_STATE * m_srcState[2];
+
+
+	friend class EffectView;
+	friend class EffectChain;
+
+} ;
+
+
+typedef Effect::Descriptor::SubPluginFeatures::Key EffectKey;
+typedef Effect::Descriptor::SubPluginFeatures::KeyList EffectKeyList;
+
+
+#endif
diff --git a/lmms/include/EffectChain.h b/lmms/include/EffectChain.h
new file mode 100644
index 0000000..cb2d817
--- /dev/null
+++ b/lmms/include/EffectChain.h
@@ -0,0 +1,83 @@
+/*
+ * EffectChain.h - class for processing and effects chain
+ *
+ * Copyright (c) 2006-2008 Danny McRae <khjklujn/at/users.sourceforge.net>
+ * Copyright (c) 2008-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _EFFECT_CHAIN_H
+#define _EFFECT_CHAIN_H
+
+#include "Model.h"
+#include "SerializingObject.h"
+#include "Mixer.h"
+#include "AutomatableModel.h"
+
+class Effect;
+
+
+class EXPORT EffectChain : public Model, public SerializingObject
+{
+	Q_OBJECT
+public:
+	EffectChain( Model * _parent );
+	virtual ~EffectChain();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+	inline virtual QString nodeName() const
+	{
+		return "fxchain";
+	}
+
+	void appendEffect( Effect * _effect );
+	void removeEffect( Effect * _effect );
+	void moveDown( Effect * _effect );
+	void moveUp( Effect * _effect );
+	bool processAudioBuffer( sampleFrame * _buf, const fpp_t _frames, bool hasInputNoise );
+	void startRunning();
+
+	void clear();
+
+	void setEnabled( bool _on )
+	{
+		m_enabledModel.setValue( _on );
+	}
+
+
+private:
+	typedef QVector<Effect *> EffectList;
+	EffectList m_effects;
+
+	BoolModel m_enabledModel;
+
+
+	friend class EffectRackView;
+
+
+signals:
+	void aboutToClear();
+
+} ;
+
+#endif
+
diff --git a/lmms/include/EffectControlDialog.h b/lmms/include/EffectControlDialog.h
new file mode 100644
index 0000000..65a0ff6
--- /dev/null
+++ b/lmms/include/EffectControlDialog.h
@@ -0,0 +1,55 @@
+/*
+ * EffectControlDialog.h - base-class for effect-dialogs for displaying and
+ *                         editing control port values
+ *
+ * Copyright (c) 2006-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _EFFECT_CONTROL_DIALOG_H
+#define _EFFECT_CONTROL_DIALOG_H
+
+#include <QtGui/QWidget>
+
+#include "ModelView.h"
+
+class EffectControls;
+
+
+class EXPORT EffectControlDialog : public QWidget, public ModelView
+{
+	Q_OBJECT
+public:
+	EffectControlDialog( EffectControls * _controls );
+	virtual ~EffectControlDialog();
+
+
+signals:
+	void closed();
+
+
+protected:
+	virtual void closeEvent( QCloseEvent * _ce );
+
+	EffectControls * m_effectControls;
+
+} ;
+
+#endif
diff --git a/lmms/include/EffectControls.h b/lmms/include/EffectControls.h
new file mode 100644
index 0000000..a8883b8
--- /dev/null
+++ b/lmms/include/EffectControls.h
@@ -0,0 +1,76 @@
+/*
+ * EffectControls.h - model for effect-controls
+ *
+ * Copyright (c) 2008-2010 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _EFFECT_CONTROLS_H
+#define _EFFECT_CONTROLS_H
+
+#include "Model.h"
+#include "JournallingObject.h"
+#include "Effect.h"
+
+class EffectControlDialog;
+
+
+class EffectControls : public JournallingObject, public Model
+{
+public:
+	EffectControls( Effect * _eff ) :
+		JournallingObject(),
+		Model( _eff ),
+		m_effect( _eff ),
+		m_viewVisible( false )
+	{
+	}
+
+	virtual ~EffectControls()
+	{
+	}
+
+	virtual int controlCount() = 0;
+	virtual EffectControlDialog * createView() = 0;
+
+
+	void setViewVisible( bool _visible )
+	{
+		m_viewVisible = _visible;
+	}
+
+	bool isViewVisible() const
+	{
+		return m_viewVisible;
+	}
+
+	Effect * effect()
+	{
+		return m_effect;
+	}
+
+
+private:
+	Effect * m_effect;
+	bool m_viewVisible;
+
+} ;
+
+#endif
diff --git a/lmms/include/EffectRackView.h b/lmms/include/EffectRackView.h
new file mode 100644
index 0000000..11b57fd
--- /dev/null
+++ b/lmms/include/EffectRackView.h
@@ -0,0 +1,85 @@
+/*
+ * effect_rack_view.h - view for effectChain-model
+ *
+ * Copyright (c) 2006-2007 Danny McRae <khjklujn@netscape.net>
+ * Copyright (c) 2008-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _EFFECT_RACK_VIEW_H
+#define _EFFECT_RACK_VIEW_H
+
+#include <QtGui/QWidget>
+
+#include "EffectChain.h"
+#include "ModelView.h"
+#include "lmms_basics.h"
+
+class QScrollArea;
+class QVBoxLayout;
+
+class EffectView;
+class groupBox;
+
+
+class EffectRackView : public QWidget, public ModelView
+{
+	Q_OBJECT
+public:
+	EffectRackView( EffectChain* model, QWidget* parent = NULL );
+	virtual ~EffectRackView();
+
+
+public slots:
+	void clearViews();
+	void moveUp( EffectView* view );
+	void moveDown( EffectView* view );
+	void deletePlugin( EffectView* view );
+
+
+private slots:
+	virtual void update();
+	void addEffect();
+
+
+private:
+	virtual void modelChanged();
+
+	inline EffectChain* fxChain()
+	{
+		return castModel<EffectChain>();
+	}
+
+	inline const EffectChain* fxChain() const
+	{
+		return castModel<EffectChain>();
+	}
+
+
+	QVector<EffectView *> m_effectViews;
+
+	groupBox* m_effectsGroupBox;
+	QScrollArea* m_scrollArea;
+
+	int m_lastY;
+
+} ;
+
+#endif
diff --git a/lmms/include/EffectSelectDialog.h b/lmms/include/EffectSelectDialog.h
new file mode 100644
index 0000000..52500d4
--- /dev/null
+++ b/lmms/include/EffectSelectDialog.h
@@ -0,0 +1,70 @@
+/*
+ * EffectSelectDialog.h - dialog to choose effect plugin
+ *
+ * Copyright (c) 2006-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _EFFECT_SELECT_DIALOG_H
+#define _EFFECT_SELECT_DIALOG_H
+
+#include <QtGui/QDialog>
+#include <QtGui/QSortFilterProxyModel>
+#include <QtGui/QStandardItemModel>
+
+#include "EffectChain.h"
+#include "Effect.h"
+
+
+namespace Ui { class EffectSelectDialog; }
+
+
+class EffectSelectDialog : public QDialog
+{
+	Q_OBJECT
+public:
+	EffectSelectDialog( QWidget * _parent );
+	virtual ~EffectSelectDialog();
+
+	Effect * instantiateSelectedPlugin( EffectChain * _parent );
+
+
+protected slots:
+	void acceptSelection();
+	void rowChanged( const QModelIndex &, const QModelIndex & );
+	void updateSelection();
+
+
+private:
+	Ui::EffectSelectDialog * ui;
+
+	Plugin::DescriptorList m_pluginDescriptors;
+	EffectKeyList m_effectKeys;
+	EffectKey m_currentSelection;
+
+	QStandardItemModel m_sourceModel;
+	QSortFilterProxyModel m_model;
+	QWidget * m_descriptionWidget;
+
+} ;
+
+
+
+#endif
diff --git a/lmms/include/EffectView.h b/lmms/include/EffectView.h
new file mode 100644
index 0000000..6caa06b
--- /dev/null
+++ b/lmms/include/EffectView.h
@@ -0,0 +1,93 @@
+/*
+ * EffectView.h - view-component for an effect
+ *
+ * Copyright (c) 2006-2007 Danny McRae <khjklujn/at/users.sourceforge.net>
+ * Copyright (c) 2007-2010 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _EFFECT_VIEW_H
+#define _EFFECT_VIEW_H
+
+#include "AutomatableModel.h"
+#include "PluginView.h"
+#include "Effect.h"
+
+class QGroupBox;
+class QLabel;
+class QPushButton;
+class QMdiSubWindow;
+
+class EffectControlDialog;
+class knob;
+class ledCheckBox;
+class TempoSyncKnob;
+
+
+class EffectView : public PluginView
+{
+	Q_OBJECT
+public:
+	EffectView( Effect * _model, QWidget * _parent );
+	virtual ~EffectView();
+	
+	inline Effect * effect()
+	{
+		return castModel<Effect>();
+	}
+	inline const Effect * effect() const
+	{
+		return castModel<Effect>();
+	}
+
+
+public slots:
+	void editControls();
+	void moveUp();
+	void moveDown();
+	void deletePlugin();
+	void displayHelp();
+	void closeEffects();
+
+	
+signals:
+	void moveUp( EffectView * _plugin );
+	void moveDown( EffectView * _plugin );
+	void deletePlugin( EffectView * _plugin );
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void modelChanged();
+
+
+private:
+	QPixmap m_bg;
+	ledCheckBox * m_bypass;
+	knob * m_wetDry;
+	TempoSyncKnob * m_autoQuit;
+	knob * m_gate;
+	QMdiSubWindow * m_subWindow;
+	EffectControlDialog * m_controlView;
+
+} ;
+
+#endif
diff --git a/lmms/include/EnvelopeAndLfoParameters.h b/lmms/include/EnvelopeAndLfoParameters.h
new file mode 100644
index 0000000..1d795bd
--- /dev/null
+++ b/lmms/include/EnvelopeAndLfoParameters.h
@@ -0,0 +1,183 @@
+/*
+ * EnvelopeAndLfoParameters.h - class EnvelopeAndLfoParameters
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _ENVELOPE_AND_LFO_PARAMETERS_H
+#define _ENVELOPE_AND_LFO_PARAMETERS_H
+
+#include <QtCore/QVector>
+
+#include "JournallingObject.h"
+#include "AutomatableModel.h"
+#include "SampleBuffer.h"
+#include "TempoSyncKnobModel.h"
+#include "lmms_basics.h"
+
+
+class EXPORT EnvelopeAndLfoParameters : public Model, public JournallingObject
+{
+	Q_OBJECT
+public:
+	class LfoInstances
+	{
+	public:
+		LfoInstances()
+		{
+		}
+
+		~LfoInstances()
+		{
+		}
+
+		inline bool isEmpty() const
+		{
+			return m_lfos.isEmpty();
+		}
+
+		void trigger();
+		void reset();
+
+		void add( EnvelopeAndLfoParameters * lfo );
+		void remove( EnvelopeAndLfoParameters * lfo );
+
+	private:
+		QMutex m_lfoListMutex;
+		typedef QList<EnvelopeAndLfoParameters *> LfoList;
+		LfoList m_lfos;
+
+	} ;
+
+	EnvelopeAndLfoParameters( float _value_for_zero_amount,
+							Model * _parent );
+	virtual ~EnvelopeAndLfoParameters();
+
+	static inline float expKnobVal( float _val )
+	{
+		return ( ( _val < 0 ) ? -_val : _val ) * _val;
+	}
+
+	static LfoInstances * instances()
+	{
+		return s_lfoInstances;
+	}
+
+	void fillLevel( float * _buf, f_cnt_t _frame,
+				const f_cnt_t _release_begin,
+				const fpp_t _frames );
+
+	inline bool isUsed() const
+	{
+		return m_used;
+	}
+
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+	virtual QString nodeName() const
+	{
+		return "el";
+	}
+
+	inline f_cnt_t PAHD_Frames() const
+	{
+		return m_pahdFrames;
+	}
+
+	inline f_cnt_t releaseFrames() const
+	{
+		return m_rFrames;
+	}
+
+
+public slots:
+	void updateSampleVars();
+
+
+protected:
+	void fillLfoLevel( float * _buf, f_cnt_t _frame, const fpp_t _frames );
+
+
+private:
+	static LfoInstances * s_lfoInstances;
+	bool m_used;
+
+
+	FloatModel m_predelayModel;
+	FloatModel m_attackModel;
+	FloatModel m_holdModel;
+	FloatModel m_decayModel;
+	FloatModel m_sustainModel;
+	FloatModel m_releaseModel;
+	FloatModel m_amountModel;
+
+	float  m_sustainLevel;
+	float  m_amount;
+	float  m_valueForZeroAmount;
+	float  m_amountAdd;
+	f_cnt_t m_pahdFrames;
+	f_cnt_t m_rFrames;
+	sample_t * m_pahdEnv;
+	sample_t * m_rEnv;
+
+
+	FloatModel m_lfoPredelayModel;
+	FloatModel m_lfoAttackModel;
+	TempoSyncKnobModel m_lfoSpeedModel;
+	FloatModel m_lfoAmountModel;
+	IntModel m_lfoWaveModel;
+
+	BoolModel m_x100Model;
+	BoolModel m_controlEnvAmountModel;
+
+
+	f_cnt_t m_lfoPredelayFrames;
+	f_cnt_t m_lfoAttackFrames;
+	f_cnt_t m_lfoOscillationFrames;
+	f_cnt_t m_lfoFrame;
+	float m_lfoAmount;
+	bool m_lfoAmountIsZero;
+	sample_t * m_lfoShapeData;
+	bool m_bad_lfoShapeData;
+	SampleBuffer m_userWave;
+
+	enum LfoShapes
+	{
+		SineWave,
+		TriangleWave,
+		SawWave,
+		SquareWave,
+		UserDefinedWave,
+		NumLfoShapes
+	} ;
+
+	sample_t lfoShapeSample( fpp_t _frame_offset );
+	void updateLfoShapeData();
+
+
+
+	friend class EnvelopeAndLfoView;
+	friend class FlpImport;
+
+} ;
+
+#endif
diff --git a/lmms/include/EnvelopeAndLfoView.h b/lmms/include/EnvelopeAndLfoView.h
new file mode 100644
index 0000000..8df71b0
--- /dev/null
+++ b/lmms/include/EnvelopeAndLfoView.h
@@ -0,0 +1,96 @@
+/*
+ * EnvelopeAndLfoView.h - declaration of class EnvelopeAndLfoView which
+ *                        is used by envelope/lfo/filter-tab of instrument track
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef ENVELOPE_AND_LFO_VIEW_H
+#define ENVELOPE_AND_LFO_VIEW_H
+
+#include <QtGui/QWidget>
+
+#include "ModelView.h"
+
+class QPaintEvent;
+class QPixmap;
+
+class EnvelopeAndLfoParameters;
+
+class automatableButtonGroup;
+class knob;
+class ledCheckBox;
+class pixmapButton;
+class TempoSyncKnob;
+
+
+
+class EnvelopeAndLfoView : public QWidget, public ModelView
+{
+	Q_OBJECT
+public:
+	EnvelopeAndLfoView( QWidget * _parent );
+	virtual ~EnvelopeAndLfoView();
+
+
+protected:
+	virtual void modelChanged();
+
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+
+
+protected slots:
+	void lfoUserWaveChanged();
+
+
+private:
+	static QPixmap * s_envGraph;
+	static QPixmap * s_lfoGraph;
+
+	EnvelopeAndLfoParameters * m_params;
+
+
+	// envelope stuff
+	knob * m_predelayKnob;
+	knob * m_attackKnob;
+	knob * m_holdKnob;
+	knob * m_decayKnob;
+	knob * m_sustainKnob;
+	knob * m_releaseKnob;
+	knob * m_amountKnob;
+
+	// LFO stuff
+	knob * m_lfoPredelayKnob;
+	knob * m_lfoAttackKnob;
+	TempoSyncKnob * m_lfoSpeedKnob;
+	knob * m_lfoAmountKnob;
+	pixmapButton * m_userLfoBtn;
+	automatableButtonGroup * m_lfoWaveBtnGrp;
+
+	ledCheckBox * m_x100Cb;
+	ledCheckBox * m_controlEnvAmountCb;
+
+} ;
+
+#endif
diff --git a/lmms/include/FileDialog.h b/lmms/include/FileDialog.h
new file mode 100644
index 0000000..f4d81ea
--- /dev/null
+++ b/lmms/include/FileDialog.h
@@ -0,0 +1,44 @@
+/*
+ * FileDialog.h - declaration of class FileDialog
+ *
+ * Copyright (c) 2014 Lukas W <lukaswhl/at/gmail.com>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef FILEDIALOG_H
+#define FILEDIALOG_H
+
+#include <QtGui/QFileDialog>
+
+#include "export.h"
+
+class EXPORT FileDialog : public QFileDialog
+{
+	Q_OBJECT
+public:
+	explicit FileDialog( QWidget *parent = 0, const QString &caption = QString(),
+						const QString &directory = QString(),
+						const QString &filter = QString() );
+
+	void clearSelection();
+};
+
+#endif // FILEDIALOG_HPP
diff --git a/lmms/include/FxMixer.h b/lmms/include/FxMixer.h
new file mode 100644
index 0000000..10b6b2c
--- /dev/null
+++ b/lmms/include/FxMixer.h
@@ -0,0 +1,100 @@
+/*
+ * FxMixer.h - effect-mixer for LMMS
+ *
+ * Copyright (c) 2008-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _FX_MIXER_H
+#define _FX_MIXER_H
+
+#include "Model.h"
+#include "Mixer.h"
+#include "EffectChain.h"
+#include "JournallingObject.h"
+
+
+const int NumFxChannels = 64;
+
+
+struct FxChannel
+{
+	FxChannel( Model * _parent );
+	~FxChannel();
+
+	EffectChain m_fxChain;
+	bool m_used;
+	bool m_stillRunning;
+	float m_peakLeft;
+	float m_peakRight;
+	sampleFrame * m_buffer;
+	BoolModel m_muteModel;
+	FloatModel m_volumeModel;
+	QString m_name;
+	QMutex m_lock;
+
+} ;
+
+
+
+class FxMixer : public JournallingObject, public Model
+{
+public:
+	FxMixer();
+	virtual ~FxMixer();
+
+	void mixToChannel( const sampleFrame * _buf, fx_ch_t _ch );
+	void processChannel( fx_ch_t _ch, sampleFrame * _buf = NULL );
+
+	void prepareMasterMix();
+	void masterMix( sampleFrame * _buf );
+
+
+	void clear();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+	virtual QString nodeName() const
+	{
+		return "fxmixer";
+	}
+
+	FxChannel * effectChannel( int _ch )
+	{
+		if( _ch >= 0 && _ch <= NumFxChannels )
+		{
+			return m_fxChannels[_ch];
+		}
+		return NULL;
+	}
+
+
+private:
+	FxChannel * m_fxChannels[NumFxChannels+1];	// +1 = master
+
+
+	friend class MixerWorkerThread;
+	friend class FxMixerView;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/FxMixerView.h b/lmms/include/FxMixerView.h
new file mode 100644
index 0000000..dab34ca
--- /dev/null
+++ b/lmms/include/FxMixerView.h
@@ -0,0 +1,84 @@
+/*
+ * FxMixerView.h - effect-mixer-view for LMMS
+ *
+ * Copyright (c) 2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _FX_MIXER_VIEW_H
+#define _FX_MIXER_VIEW_H
+
+#include <QtGui/QWidget>
+
+#include "FxMixer.h"
+#include "ModelView.h"
+
+class QStackedLayout;
+class QButtonGroup;
+class fader;
+class FxLine;
+class EffectRackView;
+class pixmapButton;
+
+
+class FxMixerView : public QWidget, public ModelView,
+					public SerializingObjectHook
+{
+	Q_OBJECT
+public:
+	FxMixerView();
+	virtual ~FxMixerView();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _this );
+	virtual void loadSettings( const QDomElement & _this );
+
+	FxLine * currentFxLine()
+	{
+		return m_currentFxLine;
+	}
+	void setCurrentFxLine( FxLine * _line );
+	void setCurrentFxLine( int _line );
+
+	void clear();
+
+
+private slots:
+	void updateFaders();
+
+
+private:
+	struct FxChannelView
+	{
+		FxLine * m_fxLine;
+		EffectRackView * m_rackView;
+		pixmapButton * m_muteBtn;
+		fader * m_fader;
+	} ;
+
+	FxChannelView m_fxChannelViews[NumFxChannels+1];
+
+	QStackedLayout * m_fxRacksLayout;
+	QStackedLayout * m_fxLineBanks;
+	QButtonGroup * m_bankButtons;
+	FxLine * m_currentFxLine;
+
+} ;
+
+#endif
diff --git a/lmms/include/ImportFilter.h b/lmms/include/ImportFilter.h
new file mode 100644
index 0000000..284dfe1
--- /dev/null
+++ b/lmms/include/ImportFilter.h
@@ -0,0 +1,106 @@
+/*
+ * ImportFilter.h - declaration of class ImportFilter, the base-class for all
+ *                  file import filters
+ *
+ * Copyright (c) 2006-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _IMPORT_FILTER_H
+#define _IMPORT_FILTER_H
+
+#include <QtCore/QFile>
+
+#include "Plugin.h"
+
+
+class TrackContainer;
+
+
+class EXPORT ImportFilter : public Plugin
+{
+public:
+	ImportFilter( const QString & _file_name,
+					const Descriptor * _descriptor );
+	virtual ~ImportFilter();
+
+
+	// tries to import given file to given track-container by having all
+	// available import-filters to try to import the file
+	static void import( const QString & _file_to_import,
+						TrackContainer* tc );
+
+
+protected:
+	virtual bool tryImport( TrackContainer* tc ) = 0;
+
+	const QFile & file() const
+	{
+		return m_file;
+	}
+
+	bool openFile();
+
+	inline void closeFile()
+	{
+		m_file.close();
+	}
+
+	inline int readByte()
+	{
+		unsigned char c;
+		if( m_file.getChar( (char*) &c ) )
+		{
+			return static_cast<int>( c );
+		}
+		return -1;
+	}
+
+	inline int readBlock( char * _data, int _len )
+	{
+		return m_file.read( _data, _len );
+	}
+
+	inline void ungetChar( char _ch )
+	{
+		m_file.ungetChar( _ch );
+	}
+
+	virtual void saveSettings( QDomDocument &, QDomElement & )
+	{
+	}
+
+	virtual void loadSettings( const QDomElement & )
+	{
+	}
+
+	virtual QString nodeName() const
+	{
+		return "import_filter";
+	}
+
+
+private:
+	QFile m_file;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/InlineAutomation.h b/lmms/include/InlineAutomation.h
new file mode 100644
index 0000000..22d2aa3
--- /dev/null
+++ b/lmms/include/InlineAutomation.h
@@ -0,0 +1,92 @@
+/*
+ * InlineAutomation.h - class for automating something "inline"
+ *
+ * Copyright (c) 2008-2010 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _INLINE_AUTOMATION_H
+#define _INLINE_AUTOMATION_H
+
+#include "AutomationPattern.h"
+#include "shared_object.h"
+
+
+class InlineAutomation : public FloatModel, public sharedObject
+{
+public:
+	InlineAutomation() :
+		FloatModel(),
+		sharedObject(),
+		m_autoPattern( NULL )
+	{
+	}
+
+	virtual ~InlineAutomation()
+	{
+		if( m_autoPattern )
+		{
+			delete m_autoPattern;
+		}
+	}
+
+	virtual float defaultValue() const = 0;
+
+	bool hasAutomation() const
+	{
+		if( m_autoPattern != NULL && m_autoPattern->getTimeMap().isEmpty() == false )
+		{
+			// prevent saving inline automation if there's just one value which equals value
+			// of model which is going to be saved anyways
+			if( isAtInitValue() &&
+				m_autoPattern->getTimeMap().size() == 1 &&
+				m_autoPattern->getTimeMap().keys().first() == 0 &&
+				m_autoPattern->getTimeMap().values().first() == value() )
+			{
+				return false;
+			}
+
+			return true;
+		}
+
+		return false;
+	}
+
+	AutomationPattern * automationPattern()
+	{
+		if( m_autoPattern == NULL )
+		{
+			m_autoPattern = new AutomationPattern( NULL );
+			m_autoPattern->addObject( this );
+		}
+		return m_autoPattern;
+	}
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+
+private:
+	AutomationPattern * m_autoPattern;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/Instrument.h b/lmms/include/Instrument.h
new file mode 100644
index 0000000..987d142
--- /dev/null
+++ b/lmms/include/Instrument.h
@@ -0,0 +1,142 @@
+/*
+ * Instrument.h - declaration of class Instrument, which provides a
+ *                standard interface for all instrument plugins
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _INSTRUMENT_H
+#define _INSTRUMENT_H
+
+#include <QtGui/QWidget>
+
+#include "Plugin.h"
+#include "Mixer.h"
+
+
+// forward-declarations
+class InstrumentTrack;
+class InstrumentView;
+class MidiEvent;
+class MidiTime;
+class NotePlayHandle;
+class track;
+
+
+class EXPORT Instrument : public Plugin
+{
+public:
+	enum Flag
+	{
+		NoFlags = 0x00,
+		IsSingleStreamed = 0x01,	/*! Instrument provides a single audio stream for all notes */
+		IsMidiBased = 0x02,			/*! Instrument is controlled by MIDI events rather than NotePlayHandles */
+		IsNotBendable = 0x04,		/*! Instrument can't react to pitch bend changes */
+	};
+
+	Q_DECLARE_FLAGS(Flags, Flag);
+
+	Instrument( InstrumentTrack * _instrument_track,
+					const Descriptor * _descriptor );
+	virtual ~Instrument();
+
+	// --------------------------------------------------------------------
+	// functions that can/should be re-implemented:
+	// --------------------------------------------------------------------
+
+	// if the plugin doesn't play each note, it can create an instrument-
+	// play-handle and re-implement this method, so that it mixes its
+	// output buffer only once per mixer-period
+	virtual void play( sampleFrame * _working_buffer );
+
+	// to be implemented by actual plugin
+	virtual void playNote( NotePlayHandle * /* _note_to_play */,
+					sampleFrame * /* _working_buf */ )
+	{
+	}
+
+	// needed for deleting plugin-specific-data of a note - plugin has to
+	// cast void-ptr so that the plugin-data is deleted properly
+	// (call of dtor if it's a class etc.)
+	virtual void deleteNotePluginData( NotePlayHandle * _note_to_play );
+
+	// Get number of sample-frames that should be used when playing beat
+	// (note with unspecified length)
+	// Per default this function returns 0. In this case, channel is using
+	// the length of the longest envelope (if one active).
+	virtual f_cnt_t beatLen( NotePlayHandle * _n ) const;
+
+
+	// some instruments need a certain number of release-frames even
+	// if no envelope is active - such instruments can re-implement this
+	// method for returning how many frames they at least like to have for
+	// release
+	virtual f_cnt_t desiredReleaseFrames() const
+	{
+		return 0;
+	}
+
+	virtual Flags flags() const
+	{
+		return NoFlags;
+	}
+
+	// sub-classes can re-implement this for receiving all incoming
+	// MIDI-events
+	inline virtual bool handleMidiEvent( const MidiEvent&, const MidiTime& = MidiTime() )
+	{
+		return true;
+	}
+
+	virtual QString fullDisplayName() const;
+
+	// --------------------------------------------------------------------
+	// provided functions:
+	// --------------------------------------------------------------------
+
+	// instantiate instrument-plugin with given name or return NULL
+	// on failure
+	static Instrument * instantiate( const QString & _plugin_name,
+									InstrumentTrack * _instrument_track );
+
+	virtual bool isFromTrack( const track * _track ) const;
+
+
+protected:
+	inline InstrumentTrack * instrumentTrack() const
+	{
+		return m_instrumentTrack;
+	}
+
+	// instruments may use this to apply a soft fade out at the end of
+	// notes - method does this only if really less or equal
+	// desiredReleaseFrames() frames are left
+	void applyRelease( sampleFrame * buf, const NotePlayHandle * _n );
+
+
+private:
+	InstrumentTrack * m_instrumentTrack;
+
+} ;
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(Instrument::Flags)
+
+#endif
diff --git a/lmms/include/InstrumentFunctionViews.h b/lmms/include/InstrumentFunctionViews.h
new file mode 100644
index 0000000..2a37046
--- /dev/null
+++ b/lmms/include/InstrumentFunctionViews.h
@@ -0,0 +1,90 @@
+/*
+ * InstrumentFunctionViews.h - views for instrument-functions-tab
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _INSTRUMENT_FUNCTION_VIEWS_H
+#define _INSTRUMENT_FUNCTION_VIEWS_H
+
+#include "ModelView.h"
+
+#include <QtGui/QWidget>
+
+class QLabel;
+class comboBox;
+class groupBox;
+class knob;
+class TempoSyncKnob;
+
+class InstrumentFunctionArpeggio;
+class InstrumentFunctionNoteStacking;
+
+
+
+class InstrumentFunctionNoteStackingView : public QWidget, public ModelView
+{
+	Q_OBJECT
+public:
+	InstrumentFunctionNoteStackingView( InstrumentFunctionNoteStacking* cc, QWidget* parent = NULL );
+	virtual ~InstrumentFunctionNoteStackingView();
+
+
+private:
+	virtual void modelChanged();
+
+	InstrumentFunctionNoteStacking * m_cc;
+
+	groupBox * m_chordsGroupBox;
+	comboBox * m_chordsComboBox;
+	knob * m_chordRangeKnob;
+
+} ;
+
+
+
+
+
+class InstrumentFunctionArpeggioView : public QWidget, public ModelView
+{
+	Q_OBJECT
+public:
+	InstrumentFunctionArpeggioView( InstrumentFunctionArpeggio* arp, QWidget* parent = NULL );
+	virtual ~InstrumentFunctionArpeggioView();
+
+
+private:
+	virtual void modelChanged();
+
+	InstrumentFunctionArpeggio * m_a;
+	groupBox * m_arpGroupBox;
+	comboBox * m_arpComboBox;
+	knob * m_arpRangeKnob;
+	TempoSyncKnob * m_arpTimeKnob;
+	knob * m_arpGateKnob;
+
+	comboBox * m_arpDirectionComboBox;
+	comboBox * m_arpModeComboBox;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/InstrumentFunctions.h b/lmms/include/InstrumentFunctions.h
new file mode 100644
index 0000000..3452219
--- /dev/null
+++ b/lmms/include/InstrumentFunctions.h
@@ -0,0 +1,211 @@
+/*
+ * InstrumentFunctions.h - models for instrument-functions-tab
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _INSTRUMENT_FUNCTIONS_H
+#define _INSTRUMENT_FUNCTIONS_H
+
+#include "JournallingObject.h"
+#include "lmms_basics.h"
+#include "AutomatableModel.h"
+#include "TempoSyncKnobModel.h"
+#include "ComboBoxModel.h"
+
+
+class InstrumentTrack;
+class NotePlayHandle;
+
+
+
+class InstrumentFunctionNoteStacking : public Model, public JournallingObject
+{
+	Q_OBJECT
+
+public:
+	static const int MAX_CHORD_POLYPHONY = 13;
+
+private:
+	typedef int8_t ChordSemiTones [MAX_CHORD_POLYPHONY];
+
+public:
+	InstrumentFunctionNoteStacking( Model * _parent );
+	virtual ~InstrumentFunctionNoteStacking();
+
+	void processNote( NotePlayHandle* n );
+
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+	inline virtual QString nodeName() const
+	{
+		return "chordcreator";
+	}
+
+
+	struct Chord
+	{
+	private:
+		QString m_name;
+		ChordSemiTones m_semiTones;
+		int m_size;
+
+	public:
+		Chord() : m_size( 0 ) {}
+
+		Chord( const char * n, const ChordSemiTones & semi_tones );
+
+		int size() const
+		{
+			return m_size;
+		}
+
+		bool isScale() const
+		{
+			return size() > 6;
+		}
+
+		bool isEmpty() const
+		{
+			return size() == 0;
+		}
+
+		bool hasSemiTone( int8_t semiTone ) const;
+
+		int8_t last() const
+		{
+			return m_semiTones[size() - 1];
+		}
+
+		const QString & getName() const
+		{
+			return m_name;
+		}
+
+		int8_t operator [] ( int n ) const
+		{
+			return m_semiTones[n];
+		}
+	};
+
+
+	struct ChordTable : public QVector<Chord>
+	{
+	private:
+		ChordTable();
+
+		struct Init
+		{
+			const char * m_name;
+			ChordSemiTones m_semiTones;
+		};
+
+		static Init s_initTable[];
+
+	public:
+		static const ChordTable & getInstance()
+		{
+			static ChordTable inst;
+			return inst;
+		}
+
+		const Chord & getByName( const QString & name, bool is_scale = false ) const;
+
+		const Chord & getScaleByName( const QString & name ) const
+		{
+			return getByName( name, true );
+		}
+
+		const Chord & getChordByName( const QString & name ) const
+		{
+			return getByName( name, false );
+		}
+	};
+
+
+private:
+	BoolModel m_chordsEnabledModel;
+	ComboBoxModel m_chordsModel;
+	FloatModel m_chordRangeModel;
+
+
+	friend class InstrumentFunctionNoteStackingView;
+
+} ;
+
+
+
+
+class InstrumentFunctionArpeggio : public Model, public JournallingObject
+{
+	Q_OBJECT
+public:
+	enum ArpDirections
+	{
+		ArpDirUp,
+		ArpDirDown,
+		ArpDirUpAndDown,
+		ArpDirRandom,
+		NumArpDirections
+	} ;
+
+	InstrumentFunctionArpeggio( Model * _parent );
+	virtual ~InstrumentFunctionArpeggio();
+
+	void processNote( NotePlayHandle* n );
+
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+	inline virtual QString nodeName() const
+	{
+		return "arpeggiator";
+	}
+
+
+private:
+	enum ArpModes
+	{
+		FreeMode,
+		SortMode,
+		SyncMode
+	} ;
+
+	BoolModel m_arpEnabledModel;
+	ComboBoxModel m_arpModel;
+	FloatModel m_arpRangeModel;
+	TempoSyncKnobModel m_arpTimeModel;
+	FloatModel m_arpGateModel;
+	ComboBoxModel m_arpDirectionModel;
+	ComboBoxModel m_arpModeModel;
+
+
+	friend class FlpImport;
+	friend class InstrumentTrack;
+	friend class InstrumentFunctionArpeggioView;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/InstrumentMidiIOView.h b/lmms/include/InstrumentMidiIOView.h
new file mode 100644
index 0000000..3edd25e
--- /dev/null
+++ b/lmms/include/InstrumentMidiIOView.h
@@ -0,0 +1,65 @@
+/*
+ * InstrumentMidiIOView.h - widget in instrument-track-window for setting
+ *                          up MIDI-related stuff
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef INSTRUMENT_MIDI_IO_VIEW_H
+#define INSTRUMENT_MIDI_IO_VIEW_H
+
+#include <QtGui/QWidget>
+
+#include "ModelView.h"
+
+
+class groupBox;
+class LcdSpinBox;
+class QToolButton;
+
+
+class InstrumentMidiIOView : public QWidget, public ModelView
+{
+public:
+	InstrumentMidiIOView( QWidget* parent );
+	virtual ~InstrumentMidiIOView();
+
+
+private:
+	virtual void modelChanged();
+
+	groupBox * m_midiInputGroupBox;
+	LcdSpinBox * m_inputChannelSpinBox;
+	LcdSpinBox * m_fixedInputVelocitySpinBox;
+	QToolButton * m_rpBtn;
+
+	groupBox * m_midiOutputGroupBox;
+	LcdSpinBox * m_outputChannelSpinBox;
+	LcdSpinBox * m_fixedOutputVelocitySpinBox;
+	LcdSpinBox * m_outputProgramSpinBox;
+	LcdSpinBox * m_fixedOutputNoteSpinBox;
+	QToolButton * m_wpBtn;
+
+	LcdSpinBox* m_baseVelocitySpinBox;
+
+} ;
+
+#endif
diff --git a/lmms/include/InstrumentPlayHandle.h b/lmms/include/InstrumentPlayHandle.h
new file mode 100644
index 0000000..cf472db
--- /dev/null
+++ b/lmms/include/InstrumentPlayHandle.h
@@ -0,0 +1,67 @@
+/*
+ * InstrumentPlayHandle.h - play-handle for driving an instrument
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _INSTRUMENT_PLAY_HANDLE_H
+#define _INSTRUMENT_PLAY_HANDLE_H
+
+#include "PlayHandle.h"
+#include "Instrument.h"
+
+
+class InstrumentPlayHandle : public PlayHandle
+{
+public:
+	InstrumentPlayHandle( Instrument* instrument ) :
+		PlayHandle( TypeInstrumentPlayHandle ),
+		m_instrument( instrument )
+	{
+	}
+
+	virtual ~InstrumentPlayHandle()
+	{
+	}
+
+
+	virtual void play( sampleFrame * _working_buffer )
+	{
+		m_instrument->play( _working_buffer );
+	}
+
+	virtual bool isFinished() const
+	{
+		return false;
+	}
+
+	virtual bool isFromTrack( const track* _track ) const
+	{
+		return m_instrument->isFromTrack( _track );
+	}
+
+
+private:
+	Instrument* m_instrument;
+
+} ;
+
+#endif
diff --git a/lmms/include/InstrumentSoundShaping.h b/lmms/include/InstrumentSoundShaping.h
new file mode 100644
index 0000000..a6f812f
--- /dev/null
+++ b/lmms/include/InstrumentSoundShaping.h
@@ -0,0 +1,88 @@
+/*
+ * InstrumentSoundShaping.h - declaration of class InstrumentSoundShaping
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _INSTRUMENT_SOUND_SHAPING_H
+#define _INSTRUMENT_SOUND_SHAPING_H
+
+#include "Mixer.h"
+#include "ComboBoxModel.h"
+
+
+class InstrumentTrack;
+class EnvelopeAndLfoParameters;
+class NotePlayHandle;
+
+
+class InstrumentSoundShaping : public Model, public JournallingObject
+{
+	Q_OBJECT
+public:
+	InstrumentSoundShaping( InstrumentTrack * _instrument_track );
+	virtual ~InstrumentSoundShaping();
+
+	void processAudioBuffer( sampleFrame * _ab, const fpp_t _frames,
+							NotePlayHandle * _n );
+
+	enum Targets
+	{
+		Volume,
+		Cut,
+		Resonance,
+		NumTargets
+	} ;
+
+	f_cnt_t envFrames( const bool _only_vol = false ) const;
+	f_cnt_t releaseFrames() const;
+
+	float volumeLevel( NotePlayHandle * _n, const f_cnt_t _frame );
+
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+	inline virtual QString nodeName() const
+	{
+		return "eldata";
+	}
+
+
+private:
+	EnvelopeAndLfoParameters * m_envLfoParameters[NumTargets];
+	InstrumentTrack * m_instrumentTrack;
+
+	BoolModel m_filterEnabledModel;
+	ComboBoxModel m_filterModel;
+	FloatModel m_filterCutModel;
+	FloatModel m_filterResModel;
+
+
+	friend class InstrumentSoundShapingView;
+	friend class FlpImport;
+
+} ;
+
+
+extern const QString __targetNames[InstrumentSoundShaping::NumTargets][3];
+
+
+#endif
diff --git a/lmms/include/InstrumentSoundShapingView.h b/lmms/include/InstrumentSoundShapingView.h
new file mode 100644
index 0000000..ff0152d
--- /dev/null
+++ b/lmms/include/InstrumentSoundShapingView.h
@@ -0,0 +1,70 @@
+/*
+ * InstrumentSoundShapingView.h - view for InstrumentSoundShaping class
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _INSTRUMENT_SOUND_SHAPING_VIEW_H
+#define _INSTRUMENT_SOUND_SHAPING_VIEW_H
+
+#include <QtGui/QWidget>
+
+#include "InstrumentSoundShaping.h"
+#include "ModelView.h"
+
+class QLabel;
+
+class EnvelopeAndLfoView;
+class comboBox;
+class groupBox;
+class knob;
+class tabWidget;
+
+
+class InstrumentSoundShapingView : public QWidget, public ModelView
+{
+	Q_OBJECT
+public:
+	InstrumentSoundShapingView( QWidget * _parent );
+	virtual ~InstrumentSoundShapingView();
+
+	void setFunctionsHidden( bool hidden );
+
+
+private:
+	virtual void modelChanged();
+
+
+	InstrumentSoundShaping * m_ss;
+	tabWidget * m_targetsTabWidget;
+	EnvelopeAndLfoView * m_envLfoViews[InstrumentSoundShaping::NumTargets];
+
+	// filter-stuff
+	groupBox * m_filterGroupBox;
+	comboBox * m_filterComboBox;
+	knob * m_filterCutKnob;
+	knob * m_filterResKnob;
+
+	QLabel* m_singleStreamInfoLabel;
+
+} ;
+
+#endif
diff --git a/lmms/include/InstrumentTrack.h b/lmms/include/InstrumentTrack.h
new file mode 100644
index 0000000..6f9a0c6
--- /dev/null
+++ b/lmms/include/InstrumentTrack.h
@@ -0,0 +1,425 @@
+/*
+ * InstrumentTrack.h - declaration of class InstrumentTrack, a track + window
+ *                     which holds an instrument-plugin
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _INSTRUMENT_TRACK_H
+#define _INSTRUMENT_TRACK_H
+
+#include "AudioPort.h"
+#include "InstrumentFunctions.h"
+#include "InstrumentSoundShaping.h"
+#include "MidiEventProcessor.h"
+#include "MidiPort.h"
+#include "NotePlayHandle.h"
+#include "Piano.h"
+#include "PianoView.h"
+#include "Pitch.h"
+#include "track.h"
+
+
+class QLineEdit;
+template<class T> class QQueue;
+class InstrumentFunctionArpeggioView;
+class InstrumentFunctionNoteStackingView;
+class EffectRackView;
+class InstrumentSoundShapingView;
+class fadeButton;
+class Instrument;
+class InstrumentTrackWindow;
+class InstrumentMidiIOView;
+class knob;
+class LcdSpinBox;
+class midiPortMenu;
+class DataFile;
+class PluginView;
+class tabWidget;
+class trackLabelButton;
+
+
+class EXPORT InstrumentTrack : public track, public MidiEventProcessor
+{
+	Q_OBJECT
+	mapPropertyFromModel(int,getVolume,setVolume,m_volumeModel);
+public:
+	InstrumentTrack( TrackContainer* tc );
+	virtual ~InstrumentTrack();
+
+	// used by instrument
+	void processAudioBuffer( sampleFrame * _buf, const fpp_t _frames,
+							NotePlayHandle * _n );
+
+	MidiEvent applyMasterKey( const MidiEvent& event );
+
+	virtual void processInEvent( const MidiEvent& event, const MidiTime& time = MidiTime() );
+	virtual void processOutEvent( const MidiEvent& event, const MidiTime& time = MidiTime() );
+	// silence all running notes played by this track
+	void silenceAllNotes();
+
+	bool isSustainPedalPressed() const
+	{
+		return m_sustainPedalPressed;
+	}
+
+	f_cnt_t beatLen( NotePlayHandle * _n ) const;
+
+
+	// for capturing note-play-events -> need that for arpeggio,
+	// filter and so on
+	void playNote( NotePlayHandle * _n, sampleFrame * _working_buffer );
+
+	QString instrumentName() const;
+	const Instrument *instrument() const
+	{
+		return m_instrument;
+	}
+
+	Instrument *instrument()
+	{
+		return m_instrument;
+	}
+
+	void deleteNotePluginData( NotePlayHandle * _n );
+
+	// name-stuff
+	virtual void setName( const QString & _new_name );
+
+	// translate given key of a note-event to absolute key (i.e.
+	// add global master-pitch and base-note of this instrument track)
+	int masterKey( int _midi_key ) const;
+
+	// translate pitch to midi-pitch [0,16383]
+	int midiPitch() const
+	{
+		return static_cast<int>( ( ( m_pitchModel.value() + m_pitchModel.range()/2 ) * MidiMaxPitchBend ) / m_pitchModel.range() );
+	}
+
+	/*! \brief Returns current range for pitch bend in semitones */
+	int midiPitchRange() const
+	{
+		return m_pitchRangeModel.value();
+	}
+
+	// play everything in given frame-range - creates note-play-handles
+	virtual bool play( const MidiTime & _start, const fpp_t _frames,
+						const f_cnt_t _frame_base, int _tco_num = -1 );
+	// create new view for me
+	virtual trackView * createView( TrackContainerView* tcv );
+
+	// create new track-content-object = pattern
+	virtual trackContentObject * createTCO( const MidiTime & _pos );
+
+
+	// called by track
+	virtual void saveTrackSpecificSettings( QDomDocument & _doc,
+							QDomElement & _parent );
+	virtual void loadTrackSpecificSettings( const QDomElement & _this );
+
+	using track::setJournalling;
+
+
+	// load instrument whose name matches given one
+	Instrument * loadInstrument( const QString & _instrument_name );
+
+	AudioPort * audioPort()
+	{
+		return &m_audioPort;
+	}
+
+	MidiPort * midiPort()
+	{
+		return &m_midiPort;
+	}
+
+	const IntModel *baseNoteModel() const
+	{
+		return &m_baseNoteModel;
+	}
+
+	IntModel *baseNoteModel()
+	{
+		return &m_baseNoteModel;
+	}
+
+	Piano *pianoModel()
+	{
+		return &m_piano;
+	}
+
+	bool isArpeggioEnabled() const
+	{
+		return m_arpeggio.m_arpEnabledModel.value();
+	}
+
+	// simple helper for removing midiport-XML-node when loading presets
+	static void removeMidiPortNode( DataFile& dataFile );
+
+	FloatModel * pitchModel()
+	{
+		return &m_pitchModel;
+	}
+
+	FloatModel * volumeModel()
+	{
+		return &m_volumeModel;
+	}
+
+	FloatModel * panningModel()
+	{
+		return &m_panningModel;
+	}
+
+	IntModel* pitchRangeModel()
+	{
+		return &m_pitchRangeModel;
+	}
+
+	IntModel * effectChannelModel()
+	{
+		return &m_effectChannelModel;
+	}
+
+
+signals:
+	void instrumentChanged();
+	void newNote();
+	void midiNoteOn( const note& );
+	void midiNoteOff( const note& );
+	void nameChanged();
+
+
+protected:
+	virtual QString nodeName() const
+	{
+		return "instrumenttrack";
+	}
+
+
+protected slots:
+	void updateBaseNote();
+	void updatePitch();
+	void updatePitchRange();
+
+
+private:
+	AudioPort m_audioPort;
+	MidiPort m_midiPort;
+
+	NotePlayHandle* m_notes[NumKeys];
+	int m_runningMidiNotes[NumKeys];
+	bool m_sustainPedalPressed;
+
+	bool m_silentBuffersProcessed;
+
+	IntModel m_baseNoteModel;
+
+	NotePlayHandleList m_processHandles;
+
+	FloatModel m_volumeModel;
+	FloatModel m_panningModel;
+	FloatModel m_pitchModel;
+	IntModel m_pitchRangeModel;
+	IntModel m_effectChannelModel;
+
+
+	Instrument * m_instrument;
+	InstrumentSoundShaping m_soundShaping;
+	InstrumentFunctionArpeggio m_arpeggio;
+	InstrumentFunctionNoteStacking m_noteStacking;
+
+	Piano m_piano;
+
+
+	friend class InstrumentTrackView;
+	friend class InstrumentTrackWindow;
+	friend class NotePlayHandle;
+	friend class FlpImport;
+
+} ;
+
+
+
+
+class InstrumentTrackView : public trackView
+{
+	Q_OBJECT
+public:
+	InstrumentTrackView( InstrumentTrack * _it, TrackContainerView* tc );
+	virtual ~InstrumentTrackView();
+
+	InstrumentTrackWindow * getInstrumentTrackWindow();
+
+	InstrumentTrack * model()
+	{
+		return castModel<InstrumentTrack>();
+	}
+
+	const InstrumentTrack * model() const
+	{
+		return castModel<InstrumentTrack>();
+	}
+
+	static InstrumentTrackWindow * topLevelInstrumentTrackWindow();
+
+	QMenu * midiMenu()
+	{
+		return m_midiMenu;
+	}
+
+	void freeInstrumentTrackWindow();
+
+	static void cleanupWindowCache();
+
+
+protected:
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+
+
+private slots:
+	void toggleInstrumentWindow( bool _on );
+	void activityIndicatorPressed();
+	void activityIndicatorReleased();
+
+	void midiInSelected();
+	void midiOutSelected();
+	void midiConfigChanged();
+
+
+private:
+	InstrumentTrackWindow * m_window;
+
+	static QQueue<InstrumentTrackWindow *> s_windowCache;
+
+	// widgets in track-settings-widget
+	trackLabelButton * m_tlb;
+	knob * m_volumeKnob;
+	knob * m_panningKnob;
+	fadeButton * m_activityIndicator;
+
+	QMenu * m_midiMenu;
+
+	QAction * m_midiInputAction;
+	QAction * m_midiOutputAction;
+
+	QPoint m_lastPos;
+
+
+	friend class InstrumentTrackWindow;
+
+} ;
+
+
+
+
+class InstrumentTrackWindow : public QWidget, public ModelView,
+								public SerializingObjectHook
+{
+	Q_OBJECT
+public:
+	InstrumentTrackWindow( InstrumentTrackView * _tv );
+	virtual ~InstrumentTrackWindow();
+
+	// parent for all internal tab-widgets
+	tabWidget * tabWidgetParent()
+	{
+		return m_tabWidget;
+	}
+
+	InstrumentTrack * model()
+	{
+		return castModel<InstrumentTrack>();
+	}
+
+	const InstrumentTrack * model() const
+	{
+		return castModel<InstrumentTrack>();
+	}
+
+	void setInstrumentTrackView( InstrumentTrackView * _tv );
+
+	PianoView * pianoView()
+	{
+		return m_pianoView;
+	}
+
+	static void dragEnterEventGeneric( QDragEnterEvent * _dee );
+
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+
+
+public slots:
+	void textChanged( const QString & _new_name );
+	void toggleVisibility( bool _on );
+	void updateName();
+	void updateInstrumentView();
+
+
+protected:
+	// capture close-events for toggling instrument-track-button
+	virtual void closeEvent( QCloseEvent * _ce );
+	virtual void focusInEvent( QFocusEvent * _fe );
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _this );
+	virtual void loadSettings( const QDomElement & _this );
+
+
+protected slots:
+	void saveSettingsBtnClicked();
+
+
+private:
+	virtual void modelChanged();
+
+	InstrumentTrack * m_track;
+	InstrumentTrackView * m_itv;
+
+	// widgets on the top of an instrument-track-window
+	QLineEdit * m_nameLineEdit;
+	knob * m_volumeKnob;
+	knob * m_panningKnob;
+	knob * m_pitchKnob;
+	LcdSpinBox* m_pitchRangeSpinBox;
+	LcdSpinBox * m_effectChannelNumber;
+
+
+	// tab-widget with all children
+	tabWidget * m_tabWidget;
+	PluginView * m_instrumentView;
+	InstrumentSoundShapingView * m_ssView;
+	InstrumentFunctionNoteStackingView* m_noteStackingView;
+	InstrumentFunctionArpeggioView* m_arpeggioView;
+	InstrumentMidiIOView * m_midiView;
+	EffectRackView * m_effectView;
+
+	// test-piano at the bottom of every instrument-settings-window
+	PianoView * m_pianoView;
+
+	friend class InstrumentView;
+
+} ;
+
+
+
+#endif
diff --git a/lmms/include/InstrumentView.h b/lmms/include/InstrumentView.h
new file mode 100644
index 0000000..8c4c4c8
--- /dev/null
+++ b/lmms/include/InstrumentView.h
@@ -0,0 +1,58 @@
+/*
+ * instrument_view.h - definition of instrumentView-class
+ *
+ * Copyright (c) 2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _INSTRUMENT_VIEW_H
+#define _INSTRUMENT_VIEW_H
+
+#include "Instrument.h"
+#include "PluginView.h"
+
+class InstrumentTrackWindow;
+
+
+class EXPORT InstrumentView : public PluginView
+{
+public:
+	InstrumentView( Instrument * _instrument, QWidget * _parent );
+	virtual ~InstrumentView();
+
+	Instrument * model()
+	{
+		return( castModel<Instrument>() );
+	}
+
+	const Instrument * model() const
+	{
+		return( castModel<Instrument>() );
+	}
+
+	virtual void setModel( Model * _model, bool = FALSE );
+
+	InstrumentTrackWindow * instrumentTrackWindow();
+
+} ;
+
+
+#endif
diff --git a/lmms/include/JournallingObject.h b/lmms/include/JournallingObject.h
new file mode 100644
index 0000000..df99025
--- /dev/null
+++ b/lmms/include/JournallingObject.h
@@ -0,0 +1,185 @@
+/*
+ * JournallingObject.h - declaration of class JournallingObject
+ *
+ * Copyright (c) 2006-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _JOURNALLING_OBJECT_H
+#define _JOURNALLING_OBJECT_H
+
+#include "lmms_basics.h"
+#include "export.h"
+#include "SerializingObject.h"
+
+#include <QtCore/QVariant>
+#include <QtCore/QVector>
+#include <QtCore/QStack>
+
+
+typedef uint32_t t_action_id;
+
+
+class JournalEntry
+{
+public:
+	JournalEntry( const t_action_id _action_id, const QVariant & _data ) :
+		m_actionID( _action_id ),
+		m_data( _data )
+	{
+	}
+
+	JournalEntry() :
+		m_actionID( 0 ),
+		m_data( 0 )
+	{
+	}
+
+	~JournalEntry()
+	{
+	}
+
+	t_action_id actionID() const
+	{
+		return m_actionID;
+	}
+	
+	t_action_id & actionID()
+	{
+		return m_actionID;
+	}
+	
+	const QVariant & data() const
+	{
+		return m_data;
+	}
+
+	QVariant & data()
+	{
+		return m_data;
+	}
+
+
+private:
+	t_action_id m_actionID;
+	QVariant m_data;
+
+} ;
+
+
+typedef QVector<JournalEntry> JournalEntryVector;
+
+
+class EXPORT JournallingObject : public SerializingObject
+{
+public:
+	JournallingObject();
+	virtual ~JournallingObject();
+
+	inline jo_id_t id() const
+	{
+		return m_id;
+	}
+
+	void undo();
+	void redo();
+
+	void clear()
+	{
+		m_journalEntries.clear();
+		m_currentJournalEntry = m_journalEntries.end();
+	}
+
+	void clearRedoSteps()
+	{
+		m_journalEntries.erase( m_currentJournalEntry,
+						m_journalEntries.end() );
+		m_currentJournalEntry = m_journalEntries.end();
+		
+	}
+
+	void saveJournallingState( const bool _new_state )
+	{
+		m_journallingStateStack.push( m_journalling );
+		m_journalling = _new_state;
+	}
+
+	void restoreJournallingState()
+	{
+		m_journalling = m_journallingStateStack.pop();
+	}
+
+	virtual QDomElement saveState( QDomDocument & _doc,
+							QDomElement & _parent );
+
+	virtual void restoreState( const QDomElement & _this );
+
+
+	inline bool isJournalling() const
+	{
+		return m_journalling;
+	}
+
+	inline void setJournalling( const bool _sr )
+	{
+		m_journalling = _sr;
+	}
+
+	inline bool testAndSetJournalling( const bool _sr )
+	{
+		const bool oldJournalling = m_journalling;
+		m_journalling = _sr;
+		return oldJournalling;
+	}
+
+
+protected:
+	void changeID( jo_id_t _id );
+
+	void addJournalEntry( const JournalEntry & _je );
+
+	// to be implemented by sub-objects
+	virtual void undoStep( JournalEntry & )
+	{
+	}
+	virtual void redoStep( JournalEntry & )
+	{
+	}
+
+
+private:
+	void saveJournal( QDomDocument & _doc, QDomElement & _parent );
+	void loadJournal( const QDomElement & _this );
+
+
+	jo_id_t m_id;
+
+	JournalEntryVector m_journalEntries;
+	JournalEntryVector::Iterator m_currentJournalEntry;
+
+	bool m_journalling;
+
+	QStack<bool> m_journallingStateStack;
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/LadspaBase.h b/lmms/include/LadspaBase.h
new file mode 100644
index 0000000..4b77083
--- /dev/null
+++ b/lmms/include/LadspaBase.h
@@ -0,0 +1,85 @@
+/*
+ * LadspaBase.h - basic declarations concerning LADSPA
+ *
+ * Copyright (c) 2006-2007 Danny McRae <khjklujn/at/users.sourceforge.net>
+ * Copyright (c) 2006-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _LADSPA_BASE_H
+#define _LADSPA_BASE_H
+
+#include "ladspa_manager.h"
+#include "Plugin.h"
+
+class LadspaControl;
+
+
+typedef enum BufferRates
+{
+	CHANNEL_IN,
+	CHANNEL_OUT,
+	AUDIO_RATE_INPUT,
+	AUDIO_RATE_OUTPUT,
+	CONTROL_RATE_INPUT,
+	CONTROL_RATE_OUTPUT
+} buffer_rate_t;
+
+typedef enum BufferData
+{
+	TOGGLED,
+	INTEGER,
+	FLOATING,
+	TIME,
+	NONE
+} buffer_data_t;
+
+typedef struct PortDescription
+{
+	QString name;
+	ch_cnt_t proc;
+	uint16_t port_id;
+	uint16_t control_id;
+	buffer_rate_t rate;
+	buffer_data_t data_type;
+	float scale;
+	LADSPA_Data max;
+	LADSPA_Data min;
+	LADSPA_Data def;
+	LADSPA_Data value;
+	LADSPA_Data * buffer;
+	LadspaControl * control;
+} port_desc_t;
+
+
+inline Plugin::Descriptor::SubPluginFeatures::Key ladspaKeyToSubPluginKey(
+						const Plugin::Descriptor * _desc,
+						const QString & _name,
+						const ladspa_key_t & _key )
+{
+	Plugin::Descriptor::SubPluginFeatures::Key::AttributeMap m;
+	QString file = _key.first;
+	m["file"] = file.remove( QRegExp( "\\.so$" ) ).remove( QRegExp( "\\.dll$" ) );
+	m["plugin"] = _key.second;
+	return Plugin::Descriptor::SubPluginFeatures::Key( _desc, _name, m );
+}
+
+
+#endif
diff --git a/lmms/include/LadspaControl.h b/lmms/include/LadspaControl.h
new file mode 100644
index 0000000..8180ce7
--- /dev/null
+++ b/lmms/include/LadspaControl.h
@@ -0,0 +1,120 @@
+/*
+ * LadspaControl.h - model for controlling a LADSPA port
+ *
+ * Copyright (c) 2008-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * Copyright (c) 2006-2008 Danny McRae <khjklujn/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef LADSPA_CONTROL_H
+#define LADSPA_CONTROL_H
+
+#include <ladspa.h>
+
+#include "AutomatableModel.h"
+#include "TempoSyncKnobModel.h"
+
+
+typedef struct PortDescription port_desc_t;
+
+
+class EXPORT LadspaControl : public Model, public JournallingObject
+{
+	Q_OBJECT
+public:
+	LadspaControl( Model * _parent, port_desc_t * _port,
+							bool _link = false );
+	~LadspaControl();
+
+	LADSPA_Data value();
+	void setValue( LADSPA_Data _value );
+	void setLink( bool _state );
+
+	void linkControls( LadspaControl * _control );
+	void unlinkControls( LadspaControl * _control );
+
+	inline BoolModel * toggledModel()
+	{
+		return &m_toggledModel;
+	}
+
+	inline FloatModel * knobModel()
+	{
+		return &m_knobModel;
+	}
+
+	inline TempoSyncKnobModel * tempoSyncKnobModel()
+	{
+		return &m_tempoSyncKnobModel;
+	}
+
+	inline port_desc_t * port()
+	{
+		return m_port;
+	}
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent, const QString & _name );
+	virtual void loadSettings( const QDomElement & _this, const QString & _name );
+	inline virtual QString nodeName() const
+	{
+		return "port";
+	}
+
+
+signals:
+	void changed( int _port, LADSPA_Data _value );
+	void linkChanged( int _port, bool _state );
+
+
+protected slots:
+	void ledChanged();
+	void knobChanged();
+	void tempoKnobChanged();
+	void linkStateChanged();
+
+protected:
+	virtual void saveSettings( QDomDocument& doc, QDomElement& element )
+	{
+		Q_UNUSED(doc)
+		Q_UNUSED(element)
+	}
+
+	virtual void loadSettings( const QDomElement& element )
+	{
+		Q_UNUSED(element)
+	}
+
+
+
+private:
+	bool m_link;
+	port_desc_t * m_port;
+
+	BoolModel m_linkEnabledModel;
+	BoolModel m_toggledModel;
+	FloatModel m_knobModel;
+	TempoSyncKnobModel m_tempoSyncKnobModel;
+
+
+	friend class LadspaControlView;
+
+} ;
+
+#endif
diff --git a/lmms/include/LadspaControlView.h b/lmms/include/LadspaControlView.h
new file mode 100644
index 0000000..5bfdcb0
--- /dev/null
+++ b/lmms/include/LadspaControlView.h
@@ -0,0 +1,48 @@
+/*
+ * LadspaControlView.h - widget for controlling a LADSPA port
+ *
+ * Copyright (c) 2006-2008 Danny McRae <khjklujn/at/users.sourceforge.net>
+ * Copyright (c) 2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _LADSPA_CONTROL_VIEW_H
+#define _LADSPA_CONTROL_VIEW_H
+
+#include <QtGui/QWidget>
+
+#include "ModelView.h"
+
+class LadspaControl;
+
+
+class EXPORT LadspaControlView : public QWidget, public ModelView
+{
+	Q_OBJECT
+public:
+	LadspaControlView( QWidget * _parent, LadspaControl * _ctl );
+	virtual ~LadspaControlView();
+	
+private:
+	LadspaControl * m_ctl;
+
+} ;
+
+#endif
diff --git a/lmms/include/LcdSpinBox.h b/lmms/include/LcdSpinBox.h
new file mode 100644
index 0000000..c95bad4
--- /dev/null
+++ b/lmms/include/LcdSpinBox.h
@@ -0,0 +1,88 @@
+/*
+ * LcdSpinBox.h - class LcdSpinBox, an improved QLCDNumber
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef LCD_SPINBOX_H
+#define LCD_SPINBOX_H
+
+#include "LcdWidget.h"
+#include "AutomatableModelView.h"
+
+
+class EXPORT LcdSpinBox : public LcdWidget, public IntModelView
+{
+	Q_OBJECT
+public:
+	LcdSpinBox( int numDigits, QWidget* parent, const QString& name = QString::null );
+
+	LcdSpinBox( int numDigits, const QString& style, QWidget* parent, const QString& name = QString::null );
+
+	virtual ~LcdSpinBox();
+
+	virtual void modelChanged()
+	{
+		ModelView::modelChanged();
+		update();
+	}
+
+	/*! Sets an offset which is always added to value of model so we can
+	    display values in a user-friendly way if they internally start at 0 */
+	void setDisplayOffset( int offset )
+	{
+		m_displayOffset = offset;
+	}
+
+	/*! \brief Returns internal offset for displaying values */
+	int displayOffset() const
+	{
+		return m_displayOffset;
+	}
+
+
+public slots:
+	virtual void update();
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseMoveEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+	virtual void wheelEvent( QWheelEvent * _we );
+	virtual void mouseDoubleClickEvent( QMouseEvent * _me );
+
+private:
+	bool m_mouseMoving;
+	QPoint m_origMousePos;
+	int m_displayOffset;
+	void enterValue();
+
+signals:
+	void manualChange();
+
+} ;
+
+typedef IntModel LcdSpinBoxModel;
+
+#endif
diff --git a/lmms/include/LcdWidget.h b/lmms/include/LcdWidget.h
new file mode 100644
index 0000000..de90f1f
--- /dev/null
+++ b/lmms/include/LcdWidget.h
@@ -0,0 +1,87 @@
+/*
+ * LcdWidget.h - a widget for displaying numbers in LCD style
+ *
+ * Copyright (c) 2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _LCD_WIDGET_H
+#define _LCD_WIDGET_H
+
+#include <QtCore/QMap>
+#include <QtGui/QWidget>
+
+#include "export.h"
+
+class EXPORT LcdWidget : public QWidget
+{
+	Q_OBJECT
+public:
+	LcdWidget( int numDigits, QWidget* parent, const QString& name = QString::null );
+
+	LcdWidget( int numDigits, const QString& style, QWidget* parent, const QString& name = QString::null );
+
+	virtual ~LcdWidget();
+
+	void setValue( int value );
+	void setLabel( const QString& label );
+
+	void addTextForValue( int value, const QString& text )
+	{
+		m_textForValue[value] = text;
+		update();
+	}
+
+
+public slots:
+	virtual void setMarginWidth( int _width );
+
+
+protected:
+	virtual void paintEvent( QPaintEvent * _me );
+	
+	virtual void updateSize();
+
+	int cellHeight() const
+	{
+		return m_cellHeight;
+	}
+
+
+private:
+
+	static const int charsPerPixmap = 12;
+
+	QMap<int, QString> m_textForValue;
+
+	QString m_display;
+
+	QString m_label;
+	QPixmap* m_lcdPixmap;
+
+	int m_cellWidth;
+	int m_cellHeight;
+	int m_numDigits;
+	int m_marginWidth;
+
+} ;
+
+#endif
diff --git a/lmms/include/LfoController.h b/lmms/include/LfoController.h
new file mode 100644
index 0000000..59bea86
--- /dev/null
+++ b/lmms/include/LfoController.h
@@ -0,0 +1,121 @@
+/*
+ * LfoController.h - A LFO-based controller and dialog
+ *
+ * Copyright (c) 2008 Paul Giblock <drfaygo/at/gmail.com>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _LFO_CONTROLLER_H
+#define _LFO_CONTROLLER_H
+
+#include <QtGui/QWidget>
+
+#include "Model.h"
+#include "AutomatableModel.h"
+#include "Controller.h"
+#include "ControllerDialog.h"
+#include "TempoSyncKnobModel.h"
+#include "Oscillator.h"
+
+class automatableButtonGroup;
+class knob;
+class ledCheckBox;
+class TempoSyncKnob;
+class pixmapButton;
+
+
+class LfoController : public Controller 
+{
+	Q_OBJECT
+public:
+	LfoController( Model * _parent );
+
+	virtual ~LfoController();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _this );
+	virtual void loadSettings( const QDomElement & _this );
+	virtual QString nodeName() const;
+
+
+public slots:
+	virtual ControllerDialog * createDialog( QWidget * _parent );
+
+
+protected:
+	// The internal per-controller get-value function
+	virtual float value( int _offset );
+
+	FloatModel m_baseModel;
+	TempoSyncKnobModel m_speedModel;
+	FloatModel m_amountModel;
+	FloatModel m_phaseModel;
+	IntModel m_waveModel;
+	IntModel m_multiplierModel;
+
+	int m_duration;
+	int m_phaseCorrection;
+	int m_phaseOffset;
+	
+	sample_t (*m_sampleFunction)( const float );
+
+private:
+	SampleBuffer * m_userDefSampleBuffer;
+
+protected slots:
+	void updateSampleFunction();
+
+	friend class LfoControllerDialog;
+
+} ;
+
+
+
+class LfoControllerDialog : public ControllerDialog
+{
+	Q_OBJECT
+public:
+	LfoControllerDialog( Controller * _controller, QWidget * _parent );
+	virtual ~LfoControllerDialog();
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+	virtual void modelChanged();
+
+	LfoController * m_lfo;
+
+	knob * m_baseKnob;
+	TempoSyncKnob * m_speedKnob;
+	knob * m_amountKnob;
+	knob * m_phaseKnob;
+	pixmapButton * m_userLfoBtn;
+	automatableButtonGroup * m_waveBtnGrp;
+	automatableButtonGroup * m_multiplierBtnGrp;
+
+
+private:
+	pixmapButton * m_userWaveBtn;
+
+private slots:
+	void askUserDefWave();
+
+} ;
+
+#endif
diff --git a/lmms/include/LmmsStyle.h b/lmms/include/LmmsStyle.h
new file mode 100644
index 0000000..7b74a06
--- /dev/null
+++ b/lmms/include/LmmsStyle.h
@@ -0,0 +1,97 @@
+/*
+ * LmmsStyle.h - the graphical style used by LMMS to create a consistent
+ *                interface
+ *
+ * Copyright (c) 2007-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _LMMS_STYLE_H
+#define _LMMS_STYLE_H
+
+#include <QtGui/QPlastiqueStyle>
+
+
+class LmmsStyle : public QPlastiqueStyle
+{
+public:
+	enum ColorRole
+	{
+		AutomationBarFill,
+		AutomationBarValue,
+		AutomationSelectedBarFill,
+		AutomationCrosshair,
+		PianoRollStepNote,
+		PianoRollSelectedNote,
+		PianoRollDefaultNote,
+		PianoRollFrozenNote,
+		PianoRollMutedNote,
+		PianoRollEditHandle,
+		PianoRollVolumeLevel,
+		PianoRollPanningLevel,
+		PianoRollSelectedLevel,
+		TimelineForecolor,
+		StandardGraphLine,
+		StandardGraphHandle,
+		StandardGraphHandleBorder,
+		StandardGraphCrosshair,
+		TextFloatForecolor,
+		TextFloatFill,
+		VisualizationLevelLow,
+		VisualizationLevelMid,
+		VisualizationLevelPeak,
+		NumColorRoles
+	};
+
+	LmmsStyle();
+	virtual ~LmmsStyle()
+	{
+	}
+
+	virtual QPalette standardPalette( void ) const;
+
+//	virtual void drawControl( ControlElement element, const QStyleOption* option, QPainter* painter, const QWidget* widget ) const;
+
+	virtual void drawComplexControl(
+				ComplexControl control,
+				const QStyleOptionComplex * option,
+					QPainter *painter,
+						const QWidget *widget ) const;
+	virtual void drawPrimitive( PrimitiveElement element,
+					const QStyleOption *option,
+					QPainter *painter,
+					const QWidget *widget = 0 ) const;
+
+	virtual int pixelMetric( PixelMetric metric,
+					const QStyleOption * option = 0, 
+					const QWidget * widget = 0 ) const;
+
+//	QSize sizeFromContents( ContentsType type, const QStyleOption* option, const QSize& size, const QWidget* widget ) const;
+//	QRect subControlRect( ComplexControl control, const QStyleOptionComplex *option, SubControl subControl, const QWidget *widget ) const;
+
+private:
+	QImage colorizeXpm( const char * const * xpm, const QBrush& fill ) const;
+	void hoverColors( bool sunken, bool hover, bool active, QColor& color, QColor& blend ) const;
+	QColor m_colors[ LmmsStyle::NumColorRoles ];
+
+} ;
+
+#endif
diff --git a/lmms/include/MainWindow.h b/lmms/include/MainWindow.h
new file mode 100644
index 0000000..c621059
--- /dev/null
+++ b/lmms/include/MainWindow.h
@@ -0,0 +1,182 @@
+/*
+ * MainWindow.h - declaration of class MainWindow, the main window of LMMS
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef MAIN_WINDOW_H
+#define MAIN_WINDOW_H
+
+#include <QtCore/QBasicTimer>
+#include <QtCore/QTimer>
+#include <QtCore/QList>
+#include <QtGui/QMainWindow>
+
+class QAction;
+class QDomElement;
+class QGridLayout;
+class QMdiArea;
+
+class configManager;
+class PluginView;
+class toolButton;
+
+
+class MainWindow : public QMainWindow
+{
+	Q_OBJECT
+public:
+	QMdiArea* workspace()
+	{
+		return m_workspace;
+	}
+
+	QWidget* toolBar()
+	{
+		return m_toolBar;
+	}
+
+	int addWidgetToToolBar( QWidget * _w, int _row = -1, int _col = -1 );
+	void addSpacingToToolBar( int _size );
+
+
+	// every function that replaces current file (e.g. creates new file,
+	// opens another file...) has to call this before and may only process
+	// if this function returns true
+	bool mayChangeProject();
+
+
+	void clearKeyModifiers();
+
+	bool isCtrlPressed()
+	{
+		return m_keyMods.m_ctrl;
+	}
+
+	bool isShiftPressed()
+	{
+		return m_keyMods.m_shift;
+	}
+
+	bool isAltPressed()
+	{
+		return m_keyMods.m_alt;
+	}
+
+	static void saveWidgetState( QWidget * _w, QDomElement & _de );
+	static void restoreWidgetState( QWidget * _w, const QDomElement & _de );
+
+
+public slots:
+	void resetWindowTitle();
+
+	void emptySlot();
+	void enterWhatsThisMode();
+	void createNewProject();
+	void createNewProjectFromTemplate( QAction * _idx );
+	void openProject();
+	bool saveProject();
+	bool saveProjectAs();
+	bool saveProjectAsNewVersion();
+	void showSettingsDialog();
+	void aboutLMMS();
+	void help();
+	void toggleAutomationEditorWin();
+	void toggleBBEditorWin( bool forceShow = false );
+	void toggleSongEditorWin();
+	void toggleProjectNotesWin();
+	void toggleFxMixerWin();
+	void togglePianoRollWin();
+	void toggleControllerRack();
+
+	void updatePlayPauseIcons();
+
+	void undo();
+	void redo();
+
+
+protected:
+	virtual void closeEvent( QCloseEvent * _ce );
+	virtual void focusOutEvent( QFocusEvent * _fe );
+	virtual void keyPressEvent( QKeyEvent * _ke );
+	virtual void keyReleaseEvent( QKeyEvent * _ke );
+	virtual void timerEvent( QTimerEvent * _ev );
+
+
+private:
+	MainWindow();
+	MainWindow( const MainWindow & );
+	virtual ~MainWindow();
+
+	void finalize();
+
+	void toggleWindow( QWidget *window, bool forceShow = false );
+
+
+	QMdiArea * m_workspace;
+
+	QWidget * m_toolBar;
+	QGridLayout * m_toolBarLayout;
+
+	QMenu * m_templatesMenu;
+	QMenu * m_recentlyOpenedProjectsMenu;
+	int m_custom_templates_count;
+
+	struct keyModifiers
+	{
+		keyModifiers() :
+			m_ctrl( false ),
+			m_shift( false ),
+			m_alt( false )
+		{
+		}
+		bool m_ctrl;
+		bool m_shift;
+		bool m_alt;
+	} m_keyMods;
+
+	QMenu * m_toolsMenu;
+	QList<PluginView *> m_tools;
+
+	QBasicTimer m_updateTimer;
+	QTimer m_autoSaveTimer;
+
+
+	friend class engine;
+
+
+private slots:
+	void browseHelp();
+	void fillTemplatesMenu();
+	void openRecentlyOpenedProject( QAction * _action );
+	void showTool( QAction * _idx );
+	void updateRecentlyOpenedProjectsMenu();
+
+
+	void autoSave();
+
+signals:
+	void periodicUpdate();
+
+} ;
+
+#endif
+
diff --git a/lmms/include/MeterDialog.h b/lmms/include/MeterDialog.h
new file mode 100644
index 0000000..698c6ce
--- /dev/null
+++ b/lmms/include/MeterDialog.h
@@ -0,0 +1,51 @@
+/*
+ * MeterDialog.h - dialog for entering meter settings
+ *
+ * Copyright (c) 2006-2008 Danny McRae <khjklujn/at/yahoo.com>
+ * Copyright (c) 2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _METER_DIALOG_H
+#define _METER_DIALOG_H
+
+#include <QtGui/QWidget>
+
+#include "ModelView.h"
+
+class LcdSpinBox;
+
+
+class MeterDialog : public QWidget, public ModelView
+{
+public:
+	MeterDialog( QWidget * _parent, bool _simple = false );
+	virtual ~MeterDialog();
+
+	virtual void modelChanged();
+
+
+private:
+	LcdSpinBox * m_numerator;
+	LcdSpinBox * m_denominator;
+
+} ;
+
+#endif
diff --git a/lmms/include/MeterModel.h b/lmms/include/MeterModel.h
new file mode 100644
index 0000000..4f12060
--- /dev/null
+++ b/lmms/include/MeterModel.h
@@ -0,0 +1,65 @@
+/*
+ * MeterModel.h - model for meter specification
+ *
+ * Copyright (c) 2008-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _METER_MODEL_H
+#define _METER_MODEL_H
+
+#include "AutomatableModel.h"
+
+
+class MeterModel : public Model
+{
+	Q_OBJECT
+	mapPropertyFromModel(int,getNumerator,setNumerator,m_numeratorModel);
+	mapPropertyFromModel(int,getDenominator,setDenominator,m_denominatorModel);
+public:
+	MeterModel( Model * _parent );
+	~MeterModel();
+
+	void saveSettings( QDomDocument & _doc, QDomElement & _this,
+						const QString & _name );
+	void loadSettings( const QDomElement & _this, const QString & _name );
+
+	void reset();
+
+	// Must have the sub-models exposed to programatically connect
+	// to automation or controllers
+	IntModel & numeratorModel()
+	{
+		return m_numeratorModel;
+	}
+
+	IntModel & denominatorModel()
+	{
+		return m_denominatorModel;
+	}
+
+
+private:
+	IntModel m_numeratorModel;
+	IntModel m_denominatorModel;
+
+} ;
+
+#endif
diff --git a/lmms/include/MicroTimer.h b/lmms/include/MicroTimer.h
new file mode 100644
index 0000000..5676a46
--- /dev/null
+++ b/lmms/include/MicroTimer.h
@@ -0,0 +1,70 @@
+/*
+ * MicroTimer.h - simple high-precision timer
+ *
+ * Copyright (c) 2005-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MICRO_TIMER
+#define _MICRO_TIMER
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+#include <cstdlib>
+#include "lmms_basics.h"
+
+
+class MicroTimer
+{
+public:
+	inline MicroTimer()
+	{
+		reset();
+	}
+
+	inline ~MicroTimer()
+	{
+	}
+
+	inline void reset()
+	{
+		gettimeofday( &begin, NULL );
+	}
+
+	inline int elapsed() const
+	{
+		struct timeval now;
+		gettimeofday( &now, NULL );
+		return ( now.tv_sec - begin.tv_sec ) * 1000 * 1000 +
+					( now.tv_usec - begin.tv_usec );
+	}
+
+
+private:
+	struct timeval begin;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/Midi.h b/lmms/include/Midi.h
new file mode 100644
index 0000000..96c66ea
--- /dev/null
+++ b/lmms/include/Midi.h
@@ -0,0 +1,140 @@
+/*
+ * Midi.h - constants, structs etc. concerning MIDI
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_H
+#define _MIDI_H
+
+#include "lmms_basics.h"
+
+
+enum MidiEventTypes
+{
+	// messages
+	MidiNoteOff = 0x80,
+	MidiNoteOn = 0x90,
+	MidiKeyPressure = 0xA0,
+	MidiControlChange = 0xB0,
+	MidiProgramChange = 0xC0,
+	MidiChannelPressure = 0xD0,
+	MidiPitchBend = 0xE0,
+	// system exclusive
+	MidiSysEx= 0xF0,
+	// system common - never in midi files
+	MidiTimeCode= 0xF1,
+	MidiSongPosition = 0xF2,
+	MidiSongSelect = 0xF3,
+	MidiTuneRequest = 0xF6,
+	MidiEOX= 0xF7,
+	// system real-time - never in midi files
+	MidiSync = 0xF8,
+	MidiTick = 0xF9,
+	MidiStart = 0xFA,
+	MidiContinue = 0xFB,
+	MidiStop = 0xFC,
+	MidiActiveSensing = 0xFE,
+	MidiSystemReset = 0xFF,
+	// meta event - for midi files only
+	MidiMetaEvent = 0xFF
+} ;
+
+enum MidiMetaEventTypes
+{
+	MidiMetaInvalid = 0x00,
+	MidiCopyright = 0x02,
+	MidiTrackName = 0x03,
+	MidiInstName = 0x04,
+	MidiLyric = 0x05,
+	MidiMarker = 0x06,
+	MidiCuePoint = 0x07,
+	MidiPortNumber = 0x21,
+	MidiEOT = 0x2f,
+	MidiSetTempo = 0x51,
+	MidiSMPTEOffset = 0x54,
+	MidiTimeSignature = 0x58,
+	MidiKeySignature = 0x59,
+	MidiSequencerEvent = 0x7f,
+	MidiMetaCustom = 0x80,
+	MidiNotePanning
+} ;
+typedef MidiMetaEventTypes MidiMetaEventType;
+
+
+enum MidiStandardControllers
+{
+	MidiControllerBankSelect = 0,
+	MidiControllerModulationWheel = 1,
+	MidiControllerBreathController = 2,
+	MidiControllerFootController = 4,
+	MidiControllerPortamentoTime = 5,
+	MidiControllerDataEntry = 6,
+	MidiControllerMainVolume = 7,
+	MidiControllerBalance = 8,
+	MidiControllerPan = 10,
+	MidiControllerEffectControl1 = 12,
+	MidiControllerEffectControl2 = 13,
+	MidiControllerSustain = 64,
+	MidiControllerPortamento = 65,
+	MidiControllerSostenuto = 66,
+	MidiControllerSoftPedal = 67,
+	MidiControllerLegatoFootswitch = 68,
+	MidiControllerRegisteredParameterNumberLSB = 100,
+	MidiControllerRegisteredParameterNumberMSB = 101,
+	// Channel Mode Messages are controllers too...
+	MidiControllerAllSoundOff = 120,
+	MidiControllerResetAllControllers = 121,
+	MidiControllerLocalControl = 122,
+	MidiControllerAllNotesOff = 123,
+	MidiControllerOmniOn = 124,
+	MidiControllerOmniOff = 125,
+	MidiControllerMonoOn = 126,
+	MidiControllerPolyOn = 127,
+
+};
+
+enum MidiControllerRegisteredParameterNumbers
+{
+	MidiPitchBendSensitivityRPN = 0x0000,
+	MidiChannelFineTuningRPN = 0x0001,
+	MidiChannelCoarseTuningRPN = 0x0002,
+	MidiTuningProgramChangeRPN = 0x0003,
+	MidiTuningBankSelectRPN = 0x0004,
+	MidiModulationDepthRangeRPN = 0x0005,
+	MidiNullFunctionNumberRPN = 0x7F7F
+};
+
+const int MidiChannelCount = 16;
+const int MidiControllerCount = 128;
+const int MidiProgramCount = 128;
+const int MidiMaxVelocity = 127;
+const int MidiDefaultVelocity = MidiMaxVelocity / 2;
+const int MidiMaxControllerValue = 127;
+const int MidiMaxNote = 127;
+
+const int MidiMaxPanning = 127;
+const int MidiMinPanning = -128;
+
+const int MidiMinPitchBend = 0;
+const int MidiMaxPitchBend = 16383;
+
+#endif
diff --git a/lmms/include/MidiAlsaRaw.h b/lmms/include/MidiAlsaRaw.h
new file mode 100644
index 0000000..9c99435
--- /dev/null
+++ b/lmms/include/MidiAlsaRaw.h
@@ -0,0 +1,90 @@
+/*
+ * MidiAlsaRaw.h - MIDI client for RawMIDI via ALSA
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_ALSA_RAW_H
+#define _MIDI_ALSA_RAW_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_ALSA
+
+#include <alsa/asoundlib.h>
+
+#include <QtCore/QThread>
+
+#include "MidiClient.h"
+
+
+struct pollfd;
+class QLineEdit;
+
+
+class MidiAlsaRaw : public MidiClientRaw , public QThread
+{
+public:
+	MidiAlsaRaw();
+	virtual ~MidiAlsaRaw();
+
+	static QString probeDevice();
+
+
+	inline static QString name()
+	{
+		return QT_TRANSLATE_NOOP( "setupWidget",
+			"ALSA Raw-MIDI (Advanced Linux Sound Architecture)" );
+	}
+
+
+	class setupWidget : public MidiClientRaw::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent );
+		virtual ~setupWidget();
+
+		virtual void saveSettings();
+
+	private:
+		QLineEdit * m_device;
+
+	} ;
+
+
+protected:
+	virtual void sendByte( const unsigned char c );
+	virtual void run();
+
+
+private:
+	snd_rawmidi_t * m_input, * * m_inputp;
+	snd_rawmidi_t * m_output, * * m_outputp;
+	int m_npfds;
+	pollfd * m_pfds;
+
+	volatile bool m_quit;
+
+} ;
+
+#endif
+
+#endif
diff --git a/lmms/include/MidiAlsaSeq.h b/lmms/include/MidiAlsaSeq.h
new file mode 100644
index 0000000..70640ae
--- /dev/null
+++ b/lmms/include/MidiAlsaSeq.h
@@ -0,0 +1,163 @@
+/*
+ * MidiAlsaSeq.h - ALSA-sequencer-client
+ *
+ * Copyright (c) 2005-2013 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_ALSA_SEQ_H
+#define _MIDI_ALSA_SEQ_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_ALSA
+#include <alsa/asoundlib.h>
+#endif
+
+#include <QtCore/QMutex>
+#include <QtCore/QThread>
+#include <QtCore/QTimer>
+
+
+#include "MidiClient.h"
+
+
+struct pollfd;
+class QLineEdit;
+
+
+class MidiAlsaSeq : public QThread, public MidiClient
+{
+	Q_OBJECT
+public:
+	MidiAlsaSeq();
+	virtual ~MidiAlsaSeq();
+
+	static QString probeDevice();
+
+
+	inline static QString name()
+	{
+		return QT_TRANSLATE_NOOP( "setupWidget",
+			"ALSA-Sequencer (Advanced Linux Sound "
+							"Architecture)" );
+	}
+
+
+
+	virtual void processOutEvent( const MidiEvent & _me,
+						const MidiTime & _time,
+						const MidiPort * _port );
+
+	virtual void applyPortMode( MidiPort * _port );
+	virtual void applyPortName( MidiPort * _port );
+
+	virtual void removePort( MidiPort * _port );
+
+
+	// list seq-ports from ALSA 
+	virtual QStringList readablePorts() const
+	{
+		return m_readablePorts;
+	}
+
+	virtual QStringList writablePorts() const
+	{
+		return m_writablePorts;
+	}
+
+	// return name of port which specified MIDI event came from
+	virtual QString sourcePortName( const MidiEvent & ) const;
+
+	// (un)subscribe given MidiPort to/from destination-port 
+	virtual void subscribeReadablePort( MidiPort * _port,
+						const QString & _dest,
+						bool _subscribe = true );
+	virtual void subscribeWritablePort( MidiPort * _port,
+						const QString & _dest,
+						bool _subscribe = true );
+	virtual void connectRPChanged( QObject * _receiver,
+							const char * _member )
+	{
+		connect( this, SIGNAL( readablePortsChanged() ),
+							_receiver, _member );
+	}
+
+	virtual void connectWPChanged( QObject * _receiver,
+							const char * _member )
+	{
+		connect( this, SIGNAL( writablePortsChanged() ),
+							_receiver, _member );
+	}
+
+
+	class setupWidget : public MidiClient::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent );
+		virtual ~setupWidget();
+
+		virtual void saveSettings();
+
+	private:
+		QLineEdit * m_device;
+
+	} ;
+
+
+private slots:
+	void changeQueueTempo( bpm_t _bpm );
+	void updatePortList();
+
+
+private:
+	virtual void run();
+
+#ifdef LMMS_HAVE_ALSA
+	QMutex m_seqMutex;
+	snd_seq_t * m_seqHandle;
+	struct Ports
+	{
+		Ports() { p[0] = -1; p[1] = -1; }
+		int & operator[]( const int _i ) { return p[_i]; }
+		private: int p[2];
+	} ;
+	QMap<MidiPort *, Ports> m_portIDs;
+#endif
+
+	int m_queueID;
+
+	volatile bool m_quit;
+
+	QTimer m_portListUpdateTimer;
+	QStringList m_readablePorts;
+	QStringList m_writablePorts;
+
+	int m_pipe[2];
+
+
+signals:
+	void readablePortsChanged();
+	void writablePortsChanged();
+
+} ;
+
+#endif
+
diff --git a/lmms/include/MidiClient.h b/lmms/include/MidiClient.h
new file mode 100644
index 0000000..2888999
--- /dev/null
+++ b/lmms/include/MidiClient.h
@@ -0,0 +1,198 @@
+/*
+ * MidiClient.h - base-class for MIDI clients like ALSA-sequencer-client
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_CLIENT_H
+#define _MIDI_CLIENT_H
+
+#include <QtCore/QStringList>
+#include <QtCore/QVector>
+
+
+#include "MidiEvent.h"
+#include "MidiEventProcessor.h"
+#include "tab_widget.h"
+
+
+class MidiPort;
+
+
+// base-class for all MIDI-clients
+class MidiClient
+{
+public:
+	MidiClient();
+	virtual ~MidiClient();
+
+	// to be implemented by sub-classes
+	virtual void processOutEvent( const MidiEvent & _me,
+						const MidiTime & _time,
+						const MidiPort * _port ) = 0;
+
+	// inheriting classes can re-implement this for being able to update
+	// their internal port-structures etc.
+	virtual void applyPortMode( MidiPort * _port );
+	virtual void applyPortName( MidiPort * _port );
+
+	virtual void addPort( MidiPort * _port );
+
+	// re-implemented methods HAVE to call removePort() of base-class!!
+	virtual void removePort( MidiPort * _port );
+
+
+	// returns whether client works with raw-MIDI, only needs to be
+	// re-implemented by MidiClientRaw for returning true
+	virtual bool isRaw() const
+	{
+		return false;
+	}
+
+	// if not raw-client, return all readable/writable ports
+	virtual QStringList readablePorts() const
+	{
+		return QStringList();
+	}
+	virtual QStringList writablePorts() const
+	{
+		return QStringList();
+	}
+
+	// return name of port which specified MIDI event came from
+	virtual QString sourcePortName( const MidiEvent & ) const
+	{
+		return QString();
+	}
+
+
+	// (un)subscribe given MidiPort to/from destination-port
+	virtual void subscribeReadablePort( MidiPort * _port,
+						const QString & _dest,
+						bool _subscribe = true );
+	virtual void subscribeWritablePort( MidiPort * _port,
+						const QString & _dest,
+						bool _subscribe = true );
+
+	// qobject-derived classes can use this for make a slot being
+	// connected to signal of non-raw-MIDI-client if port-lists change
+	virtual void connectRPChanged( QObject *, const char * )
+	{
+	}
+
+	virtual void connectWPChanged( QObject *, const char * )
+	{
+	}
+
+	// tries to open either MIDI-driver from config-file or (if it fails)
+	// any other working
+	static MidiClient * openMidiClient();
+
+
+	class setupWidget : public tabWidget
+	{
+	public:
+		setupWidget( const QString & _caption, QWidget * _parent ) :
+			tabWidget( tabWidget::tr( "Settings for %1" ).arg(
+					tr( _caption.toAscii() ) ).toUpper(),
+								_parent )
+		{
+		}
+
+		virtual ~setupWidget()
+		{
+		}
+
+		virtual void saveSettings() = 0;
+
+		virtual void show()
+		{
+			parentWidget()->show();
+			QWidget::show();
+		}
+
+	} ;
+
+
+protected:
+	QVector<MidiPort *> m_midiPorts;
+
+} ;
+
+
+
+
+const uint32_t RAW_MIDI_PARSE_BUF_SIZE = 16;
+
+
+class MidiClientRaw : public MidiClient
+{
+public:
+	MidiClientRaw();
+	virtual ~MidiClientRaw();
+
+	// we are raw-clients for sure!
+	virtual bool isRaw() const
+	{
+		return true;
+	}
+
+
+protected:
+	// generic raw-MIDI-parser which generates appropriate MIDI-events
+	void parseData( const unsigned char c );
+
+	// to be implemented by actual client-implementation
+	virtual void sendByte( const unsigned char c ) = 0;
+
+
+private:
+	// this does MIDI-event-process
+	void processParsedEvent();
+	virtual void processOutEvent( const MidiEvent& event, const MidiTime& time, const MidiPort* port );
+
+	// small helper function returning length of a certain event - this
+	// is necessary for parsing raw-MIDI-data
+	static int eventLength( const unsigned char event );
+
+
+	// data being used for parsing
+	struct midiParserData
+	{
+		uint8_t m_status;		// identifies the type of event, that
+					// is currently received ('Noteon',
+					// 'Pitch Bend' etc).
+		uint8_t m_channel;	// The channel of the event that is
+					// received (in case of a channel event)
+		uint32_t m_bytes;		// How many bytes have been read for
+					// the current event?
+		uint32_t m_bytesTotal;	// How many bytes does the current
+					// event type include?
+		uint32_t m_buffer[RAW_MIDI_PARSE_BUF_SIZE];
+					// buffer for incoming data
+		MidiEvent m_midiEvent;	// midi-event
+	} m_midiParseData;
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/MidiController.h b/lmms/include/MidiController.h
new file mode 100644
index 0000000..2271e86
--- /dev/null
+++ b/lmms/include/MidiController.h
@@ -0,0 +1,84 @@
+/*
+ * MidiController.h - A controller to receive MIDI control-changes
+ *
+ * Copyright (c) 2008 Paul Giblock <drfaygo/at/gmail.com>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_CONTROLLER_H
+#define _MIDI_CONTROLLER_H
+
+#include <QtGui/QWidget>
+
+#include "AutomatableModel.h"
+#include "Controller.h"
+#include "MidiEventProcessor.h"
+#include "MidiPort.h"
+
+
+class MidiPort;
+
+
+class MidiController : public Controller, public MidiEventProcessor
+{
+	Q_OBJECT
+public:
+	MidiController( Model * _parent );
+	virtual ~MidiController();
+
+	virtual void processInEvent( const MidiEvent & _me,
+					const MidiTime & _time );
+
+	virtual void processOutEvent( const MidiEvent& _me,
+					const MidiTime & _time)
+	{
+		// No output yet
+	}
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _this );
+	virtual void loadSettings( const QDomElement & _this );
+	virtual QString nodeName() const;
+
+	// Used by controllerConnectionDialog to copy
+	void subscribeReadablePorts( const MidiPort::Map & _map );
+
+
+public slots:
+	virtual ControllerDialog * createDialog( QWidget * _parent );
+	void updateName();
+
+
+protected:
+	// The internal per-controller get-value function
+	virtual float value( int _offset );
+
+
+	MidiPort m_midiPort;
+
+
+	float m_lastValue;
+
+	friend class ControllerConnectionDialog;
+	friend class AutoDetectMidiController;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/MidiDummy.h b/lmms/include/MidiDummy.h
new file mode 100644
index 0000000..cba725f
--- /dev/null
+++ b/lmms/include/MidiDummy.h
@@ -0,0 +1,81 @@
+/*
+ * MidiDummy.h - dummy MIDI-driver
+ *
+ * Copyright (c) 2005-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_DUMMY_H
+#define _MIDI_DUMMY_H
+
+#include "MidiClient.h"
+
+
+class MidiDummy : public MidiClientRaw
+{
+public:
+	MidiDummy()
+	{
+	}
+	virtual ~MidiDummy()
+	{
+	}
+
+	inline static QString name()
+	{
+		return( QT_TRANSLATE_NOOP( "setupWidget",
+			"Dummy (no MIDI support)" ) );
+	}
+
+
+	class setupWidget : public MidiClient::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent ) :
+			MidiClientRaw::setupWidget( MidiDummy::name(), _parent )
+		{
+		}
+
+		virtual ~setupWidget()
+		{
+		}
+
+		virtual void saveSettings()
+		{
+		}
+
+		virtual void show()
+		{
+			parentWidget()->hide();
+			QWidget::show();
+		}
+
+	} ;
+
+
+protected:
+	virtual void sendByte( const unsigned char )
+	{
+	}
+
+} ;
+
+
+#endif
diff --git a/lmms/include/MidiEvent.h b/lmms/include/MidiEvent.h
new file mode 100644
index 0000000..c87d042
--- /dev/null
+++ b/lmms/include/MidiEvent.h
@@ -0,0 +1,210 @@
+/*
+ * MidiEvent.h - MidiEvent class
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_EVENT_H
+#define _MIDI_EVENT_H
+
+#include <cstdlib>
+#include "Midi.h"
+#include "panning_constants.h"
+#include "volume.h"
+
+class MidiEvent
+{
+public:
+	MidiEvent( MidiEventTypes type = MidiActiveSensing,
+				int8_t channel = 0,
+				int16_t param1 = 0,
+				int16_t param2 = 0,
+				const void* sourcePort = NULL ) :
+		m_type( type ),
+		m_metaEvent( MidiMetaInvalid ),
+		m_channel( channel ),
+		m_sysExData( NULL ),
+		m_sourcePort( sourcePort )
+	{
+		m_data.m_param[0] = param1;
+		m_data.m_param[1] = param2;
+	}
+
+	MidiEvent( MidiEventTypes type, const char* sysExData, int dataLen ) :
+		m_type( type ),
+		m_metaEvent( MidiMetaInvalid ),
+		m_channel( 0 ),
+		m_sysExData( sysExData ),
+		m_sourcePort( NULL )
+	{
+		m_data.m_sysExDataLen = dataLen;
+	}
+
+	MidiEvent( const MidiEvent& other ) :
+		m_type( other.m_type ),
+		m_metaEvent( other.m_metaEvent ),
+		m_channel( other.m_channel ),
+		m_data( other.m_data ),
+		m_sysExData( other.m_sysExData ),
+		m_sourcePort( other.m_sourcePort )
+	{
+	}
+
+	MidiEventTypes type() const
+	{
+		return m_type;
+	}
+
+	void setType( MidiEventTypes type )
+	{
+		m_type = type;
+	}
+
+	void setMetaEvent( MidiMetaEventType metaEvent )
+	{
+		m_metaEvent = metaEvent;
+	}
+
+	MidiMetaEventType metaEvent() const
+	{
+		return m_metaEvent;
+	}
+
+	int8_t channel() const
+	{
+		return m_channel;
+	}
+
+	void setChannel( int8_t channel )
+	{
+		m_channel = channel;
+	}
+
+	int16_t param( int i ) const
+	{
+		return m_data.m_param[i];
+	}
+
+	void setParam( int i, uint16_t value )
+	{
+		m_data.m_param[i] = value;
+	}
+
+	int16_t key() const
+	{
+		return param( 0 );
+	}
+
+	void setKey( int16_t key )
+	{
+		m_data.m_param[0] = key;
+	}
+
+	uint8_t velocity() const
+	{
+		return m_data.m_param[1] & 0x7F;
+	}
+
+	void setVelocity( int16_t velocity )
+	{
+		m_data.m_param[1] = velocity;
+	}
+
+	panning_t panning() const
+	{
+		return (panning_t) ( PanningLeft +
+			( (float)( midiPanning() - MidiMinPanning ) ) / 
+			( (float)( MidiMaxPanning - MidiMinPanning ) ) *
+			( (float)( PanningRight - PanningLeft ) ) );
+	}
+	int16_t midiPanning() const
+	{
+		return m_data.m_param[1];
+	}
+
+	volume_t volume( int midiBaseVelocity ) const
+	{
+		return (volume_t)( velocity() * DefaultVolume / midiBaseVelocity );
+	}
+
+	const void* sourcePort() const
+	{
+		return m_sourcePort;
+	}
+
+	uint8_t controllerNumber() const
+	{
+		return param( 0 ) & 0x7F;
+	}
+
+	void setControllerNumber( uint8_t num )
+	{
+		setParam( 0, num );
+	}
+
+	uint8_t controllerValue() const
+	{
+		return param( 1 );
+	}
+
+	void setControllerValue( uint8_t value )
+	{
+		setParam( 1, value );
+	}
+
+	uint8_t program() const
+	{
+		return param( 0 );
+	}
+
+	uint8_t channelPressure() const
+	{
+		return param( 0 );
+	}
+
+	int16_t pitchBend() const
+	{
+		return param( 0 );
+	}
+
+	void setPitchBend( uint16_t pitchBend )
+	{
+		setParam( 0, pitchBend );
+	}
+
+
+private:
+	MidiEventTypes m_type;		// MIDI event type
+	MidiMetaEventType m_metaEvent;	// Meta event (mostly unused)
+	int8_t m_channel;		// MIDI channel
+	union
+	{
+		int16_t m_param[2];	// first/second parameter (key/velocity)
+		uint8_t m_bytes[4];		// raw bytes
+		int32_t m_sysExDataLen;	// len of m_sysExData
+	} m_data;
+
+	const char* m_sysExData;
+	const void* m_sourcePort;
+
+} ;
+
+#endif
diff --git a/lmms/include/MidiEventProcessor.h b/lmms/include/MidiEventProcessor.h
new file mode 100644
index 0000000..dafcfb6
--- /dev/null
+++ b/lmms/include/MidiEventProcessor.h
@@ -0,0 +1,50 @@
+/*
+ * MidiEventProcessor.h - base-class for midi-processing classes
+ *
+ * Copyright (c) 2005-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_EVENT_PROCESSOR_H
+#define _MIDI_EVENT_PROCESSOR_H
+
+#include "MidiEvent.h"
+#include "MidiTime.h"
+
+
+// all classes being able to process MIDI-events should inherit from this
+class MidiEventProcessor
+{
+public:
+	MidiEventProcessor()
+	{
+	}
+
+	virtual ~MidiEventProcessor()
+	{
+	}
+
+	// to be implemented by inheriting classes
+	virtual void processInEvent( const MidiEvent& event, const MidiTime& time = MidiTime() ) = 0;
+	virtual void processOutEvent( const MidiEvent& event, const MidiTime& time = MidiTime() ) = 0;
+
+} ;
+
+#endif
diff --git a/lmms/include/MidiOss.h b/lmms/include/MidiOss.h
new file mode 100644
index 0000000..0790096
--- /dev/null
+++ b/lmms/include/MidiOss.h
@@ -0,0 +1,86 @@
+/*
+ * MidiOss.h - OSS raw MIDI client
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_OSS_H
+#define _MIDI_OSS_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_OSS
+
+#include <QtCore/QThread>
+#include <QtCore/QFile>
+
+#include "MidiClient.h"
+
+
+class QLineEdit;
+
+
+class MidiOss : public MidiClientRaw, public QThread
+{
+public:
+	MidiOss();
+	virtual ~MidiOss();
+
+	static QString probeDevice();
+
+
+	inline static QString name()
+	{
+		return( QT_TRANSLATE_NOOP( "setupWidget",
+			"OSS Raw-MIDI (Open Sound System)" ) );
+	}
+
+
+	class setupWidget : public MidiClientRaw::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent );
+		virtual ~setupWidget();
+
+		virtual void saveSettings();
+
+	private:
+		QLineEdit * m_device;
+
+	} ;
+
+
+protected:
+	virtual void sendByte( const unsigned char c );
+	virtual void run();
+
+
+private:
+	QFile m_midiDev;
+
+	volatile bool m_quit;
+
+} ;
+
+#endif
+
+
+#endif
diff --git a/lmms/include/MidiPort.h b/lmms/include/MidiPort.h
new file mode 100644
index 0000000..8101654
--- /dev/null
+++ b/lmms/include/MidiPort.h
@@ -0,0 +1,178 @@
+/*
+ * MidiPort.h - abstraction of MIDI ports which are part of LMMS' MIDI
+ *              sequencing system
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_PORT_H
+#define _MIDI_PORT_H
+
+#include <QtCore/QString>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+
+#include "Midi.h"
+#include "MidiTime.h"
+#include "AutomatableModel.h"
+
+
+class MidiClient;
+class MidiEvent;
+class MidiEventProcessor;
+class MidiPortMenu;
+
+
+// class for abstraction of MIDI-port
+class MidiPort : public Model, public SerializingObject
+{
+	Q_OBJECT
+	mapPropertyFromModel(int,inputChannel,setInputChannel,m_inputChannelModel);
+	mapPropertyFromModel(int,outputChannel,setOutputChannel,m_outputChannelModel);
+	mapPropertyFromModel(int,inputController,setInputController,m_inputControllerModel);
+	mapPropertyFromModel(int,outputController,setOutputController,m_outputControllerModel);
+	mapPropertyFromModel(int,fixedInputVelocity,setFixedInputVelocity,m_fixedInputVelocityModel);
+	mapPropertyFromModel(int,fixedOutputVelocity,setFixedOutputVelocity,m_fixedOutputVelocityModel);
+	mapPropertyFromModel(int,fixedOutputNote,setFixedOutputNote,m_fixedOutputNoteModel);
+	mapPropertyFromModel(int,outputProgram,setOutputProgram,m_outputProgramModel);
+	mapPropertyFromModel(int,baseVelocity,setBaseVelocity,m_baseVelocityModel);
+	mapPropertyFromModel(bool,isReadable,setReadable,m_readableModel);
+	mapPropertyFromModel(bool,isWritable,setWritable,m_writableModel);
+public:
+	typedef QMap<QString, bool> Map;
+
+	enum Modes
+	{
+		Disabled,	// don't route any MIDI-events (default)
+		Input,		// from MIDI-client to MIDI-event-processor
+		Output,		// from MIDI-event-processor to MIDI-client
+		Duplex		// both directions
+	} ;
+	typedef Modes Mode;
+
+	MidiPort( const QString& name,
+			MidiClient* client,
+			MidiEventProcessor* eventProcessor,
+			Model* parent = NULL,
+			Mode mode = Disabled );
+	virtual ~MidiPort();
+
+	void setName( const QString& name );
+
+	Mode mode() const
+	{
+		return m_mode;
+	}
+
+	void setMode( Mode mode );
+
+	bool isInputEnabled() const
+	{
+		return mode() == Input || mode() == Duplex;
+	}
+
+	bool isOutputEnabled() const
+	{
+		return mode() == Output || mode() == Duplex;
+	}
+
+	int realOutputChannel() const
+	{
+		return outputChannel() - 1;
+	}
+
+	void processInEvent( const MidiEvent& event, const MidiTime& time = MidiTime() );
+	void processOutEvent( const MidiEvent& event, const MidiTime& time = MidiTime() );
+
+
+	virtual void saveSettings( QDomDocument& doc, QDomElement& thisElement );
+	virtual void loadSettings( const QDomElement& thisElement );
+
+	virtual QString nodeName() const
+	{
+		return "midiport";
+	}
+
+	void subscribeReadablePort( const QString& port, bool subscribe = true );
+	void subscribeWritablePort( const QString& port, bool subscribe = true );
+
+	const Map& readablePorts() const
+	{
+		return m_readablePorts;
+	}
+
+	const Map& writablePorts() const
+	{
+		return m_writablePorts;
+	}
+
+	MidiPortMenu* m_readablePortsMenu;
+	MidiPortMenu* m_writablePortsMenu;
+
+
+public slots:
+	void updateMidiPortMode();
+
+
+private slots:
+	void updateReadablePorts();
+	void updateWritablePorts();
+	void updateOutputProgram();
+
+
+private:
+	MidiClient* m_midiClient;
+	MidiEventProcessor* m_midiEventProcessor;
+
+	Mode m_mode;
+
+	IntModel m_inputChannelModel;
+	IntModel m_outputChannelModel;
+	IntModel m_inputControllerModel;
+	IntModel m_outputControllerModel;
+	IntModel m_fixedInputVelocityModel;
+	IntModel m_fixedOutputVelocityModel;
+	IntModel m_fixedOutputNoteModel;
+	IntModel m_outputProgramModel;
+	IntModel m_baseVelocityModel;
+	BoolModel m_readableModel;
+	BoolModel m_writableModel;
+
+	Map m_readablePorts;
+	Map m_writablePorts;
+
+
+	friend class ControllerConnectionDialog;
+	friend class InstrumentMidiIOView;
+
+
+signals:
+	void readablePortsChanged();
+	void writablePortsChanged();
+	void modeChanged();
+
+} ;
+
+
+typedef QList<MidiPort *> MidiPortList;
+
+
+#endif
diff --git a/lmms/include/MidiPortMenu.h b/lmms/include/MidiPortMenu.h
new file mode 100644
index 0000000..55e61ee
--- /dev/null
+++ b/lmms/include/MidiPortMenu.h
@@ -0,0 +1,61 @@
+/*
+ * MidiPortMenu.h - a menu for subscribing a MidiPort to several external
+ *                  MIDI ports
+ *
+ * Copyright (c) 2008-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_PORT_MENU_H
+#define _MIDI_PORT_MENU_H
+
+#include <QtGui/QMenu>
+
+#include "ModelView.h"
+#include "MidiPort.h"
+
+class QAction;
+
+
+class MidiPortMenu : public QMenu, public ModelView
+{
+	Q_OBJECT
+public:
+	MidiPortMenu( MidiPort::Modes _mode );
+	virtual ~MidiPortMenu();
+
+
+public slots:
+	void updateMenu();
+
+
+protected slots:
+	void activatedPort( QAction * _item );
+
+
+private:
+	virtual void modelChanged();
+
+	MidiPort::Modes m_mode;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/MidiTime.h b/lmms/include/MidiTime.h
new file mode 100644
index 0000000..9a86f3b
--- /dev/null
+++ b/lmms/include/MidiTime.h
@@ -0,0 +1,153 @@
+/*
+ * MidiTime.h - declaration of class MidiTime which provides data type for
+ *              position- and length-variables
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _MIDI_TIME_H
+#define _MIDI_TIME_H
+
+#include "lmms_basics.h"
+#include "export.h"
+
+const int DefaultTicksPerTact = 192;
+const int DefaultStepsPerTact = 16;
+const int DefaultBeatsPerTact = DefaultTicksPerTact / DefaultStepsPerTact;
+
+
+class EXPORT MidiTime
+{
+public:
+	MidiTime( const tact_t tact, const tick_t ticks ) :
+		m_ticks( tact * s_ticksPerTact + ticks )
+	{
+	}
+
+	MidiTime( const tick_t ticks = 0 ) :
+		m_ticks( ticks )
+	{
+	}
+
+	MidiTime( const MidiTime& time ) :
+		m_ticks( time.m_ticks )
+	{
+	}
+
+	MidiTime toNearestTact() const
+	{
+		if( m_ticks % s_ticksPerTact >= s_ticksPerTact/2 )
+		{
+			return ( getTact() + 1 ) * s_ticksPerTact;
+		}
+		return getTact() * s_ticksPerTact;
+	}
+
+	MidiTime& operator=( const MidiTime& time )
+	{
+		m_ticks = time.m_ticks;
+		return *this;
+	}
+
+	MidiTime& operator+=( const MidiTime& time )
+	{
+		m_ticks += time.m_ticks;
+		return *this;
+	}
+
+	MidiTime& operator-=( const MidiTime& time )
+	{
+		m_ticks -= time.m_ticks;
+		return *this;
+	}
+
+	tact_t getTact() const
+	{
+		return m_ticks / s_ticksPerTact;
+	}
+
+	tact_t nextFullTact() const
+	{
+		if( m_ticks % s_ticksPerTact == 0 )
+		{
+			return m_ticks / s_ticksPerTact;
+		}
+		return m_ticks / s_ticksPerTact + 1;
+	}
+
+	void setTicks( tick_t ticks )
+	{
+		m_ticks = ticks;
+	}
+
+	tick_t getTicks() const
+	{
+		return m_ticks;
+	}
+
+	operator int() const
+	{
+		return m_ticks;
+	}
+
+	// calculate number of frame that are needed this time
+	f_cnt_t frames( const float framesPerTick ) const
+	{
+		if( m_ticks >= 0 )
+		{
+			return static_cast<f_cnt_t>( m_ticks * framesPerTick );
+		}
+		return 0;
+	}
+
+	static MidiTime fromFrames( const f_cnt_t frames, const float framesPerTick )
+	{
+		return MidiTime( static_cast<int>( frames / framesPerTick ) );
+	}
+
+
+	static tick_t ticksPerTact()
+	{
+		return s_ticksPerTact;
+	}
+
+	static int stepsPerTact()
+	{
+		return qMax( 1, ticksPerTact() / DefaultBeatsPerTact );
+	}
+
+	static void setTicksPerTact( tick_t _tpt )
+	{
+		s_ticksPerTact = _tpt;
+	}
+
+
+private:
+	tick_t m_ticks;
+
+	static tick_t s_ticksPerTact;
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/MidiWinMM.h b/lmms/include/MidiWinMM.h
new file mode 100644
index 0000000..54b6bdf
--- /dev/null
+++ b/lmms/include/MidiWinMM.h
@@ -0,0 +1,155 @@
+/*
+ * MidiWinMM.h - WinMM MIDI client
+ *
+ * Copyright (c) 2008-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIDI_WINMM_H
+#define _MIDI_WINMM_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_BUILD_WIN32
+#include <windows.h>
+#include <mmsystem.h>
+#endif
+
+#include "MidiClient.h"
+#include "MidiPort.h"
+
+
+class QLineEdit;
+
+
+class MidiWinMM : public QObject, public MidiClient
+{
+	Q_OBJECT
+public:
+	MidiWinMM();
+	virtual ~MidiWinMM();
+
+	static QString probeDevice();
+
+
+	inline static QString name()
+	{
+		return QT_TRANSLATE_NOOP( "setupWidget", "WinMM MIDI" );
+	}
+
+
+
+	virtual void processOutEvent( const MidiEvent & _me,
+						const MidiTime & _time,
+						const MidiPort * _port );
+
+	virtual void applyPortMode( MidiPort * _port );
+	virtual void removePort( MidiPort * _port );
+
+
+#ifdef LMMS_BUILD_WIN32
+	// list devices as ports
+	virtual QStringList readablePorts() const
+	{
+		return m_inputDevices.values();
+	}
+
+	virtual QStringList writablePorts() const
+	{
+		return m_outputDevices.values();
+	}
+#endif
+
+	// return name of port which specified MIDI event came from
+	virtual QString sourcePortName( const MidiEvent & ) const;
+
+	// (un)subscribe given MidiPort to/from destination-port 
+	virtual void subscribeReadablePort( MidiPort * _port,
+						const QString & _dest,
+						bool _subscribe = true );
+	virtual void subscribeWritablePort( MidiPort * _port,
+						const QString & _dest,
+						bool _subscribe = true );
+	virtual void connectRPChanged( QObject * _receiver,
+							const char * _member )
+	{
+		connect( this, SIGNAL( readablePortsChanged() ),
+							_receiver, _member );
+	}
+
+	virtual void connectWPChanged( QObject * _receiver,
+							const char * _member )
+	{
+		connect( this, SIGNAL( writablePortsChanged() ),
+							_receiver, _member );
+	}
+
+	virtual bool isRaw() const
+	{
+		return false;
+	}
+
+
+	class setupWidget : public MidiClient::setupWidget
+	{
+	public:
+		setupWidget( QWidget * _parent );
+		virtual ~setupWidget();
+
+		virtual void saveSettings()
+		{
+		}
+
+	} ;
+
+
+private:// slots:
+	void updateDeviceList();
+
+
+private:
+	void openDevices();
+	void closeDevices();
+
+#ifdef LMMS_BUILD_WIN32
+	static void WINAPI CALLBACK inputCallback( HMIDIIN _hm, UINT _msg,
+						DWORD_PTR _inst,
+						DWORD_PTR _param1,
+							DWORD_PTR _param2 );
+	void handleInputEvent( HMIDIIN _hm, DWORD _ev );
+
+	QMap<HMIDIIN, QString> m_inputDevices;
+	QMap<HMIDIOUT, QString> m_outputDevices;
+#endif
+
+	// subscriptions
+	typedef QMap<QString, MidiPortList> SubMap;
+	SubMap m_inputSubs;
+	SubMap m_outputSubs;
+
+
+signals:
+	void readablePortsChanged();
+	void writablePortsChanged();
+
+} ;
+
+#endif
+
diff --git a/lmms/include/MixHelpers.h b/lmms/include/MixHelpers.h
new file mode 100644
index 0000000..a1ddd33
--- /dev/null
+++ b/lmms/include/MixHelpers.h
@@ -0,0 +1,55 @@
+/*
+ * MixHelpers.h - helper functions for mixing buffers
+ *
+ * Copyright (c) 2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIX_HELPERS_H
+#define _MIX_HELPERS_H
+
+#include "lmms_basics.h"
+
+namespace MixHelpers
+{
+
+bool isSilent( const sampleFrame* src, int frames );
+
+/*! \brief Add samples from src to dst */
+void add( sampleFrame* dst, const sampleFrame* src, int frames );
+
+
+/*! \brief Add samples from src multiplied by coeffSrc to dst */
+void addMultiplied( sampleFrame* dst, const sampleFrame* src, float coeffSrc, int frames );
+
+
+/*! \brief Add samples from src multiplied by coeffSrcLeft/coeffSrcRight to dst */
+void addMultipliedStereo( sampleFrame* dst, const sampleFrame* src, float coeffSrcLeft, float coeffSrcRight, int frames );
+
+/*! \brief Multiply dst by coeffDst and add samples from src multiplied by coeffSrc */
+void multiplyAndAddMultiplied( sampleFrame* dst, const sampleFrame* src, float coeffDst, float coeffSrc, int frames );
+
+/*! \brief Multiply dst by coeffDst and add samples from srcLeft/srcRight multiplied by coeffSrc */
+void multiplyAndAddMultipliedJoined( sampleFrame* dst, const sample_t* srcLeft, const sample_t* srcRight, float coeffDst, float coeffSrc, int frames );
+
+}
+
+#endif
+
diff --git a/lmms/include/Mixer.h b/lmms/include/Mixer.h
new file mode 100644
index 0000000..f35c24b
--- /dev/null
+++ b/lmms/include/Mixer.h
@@ -0,0 +1,474 @@
+/*
+ * Mixer.h - audio-device-independent mixer for LMMS
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _MIXER_H
+#define _MIXER_H
+
+#include "lmmsconfig.h"
+
+#ifndef LMMS_USE_3RDPARTY_LIBSRC
+#include <samplerate.h>
+#else
+#ifndef OUT_OF_TREE_BUILD
+#include "src/3rdparty/samplerate/samplerate.h"
+#else
+#include <samplerate.h>
+#endif
+#endif
+
+
+#include <QtCore/QMutex>
+#include <QtCore/QThread>
+#include <QtCore/QVector>
+#include <QtCore/QWaitCondition>
+
+
+#include "lmms_basics.h"
+#include "note.h"
+#include "fifo_buffer.h"
+
+
+class AudioDevice;
+class MidiClient;
+class AudioPort;
+
+
+const fpp_t DEFAULT_BUFFER_SIZE = 256;
+
+const int BYTES_PER_SAMPLE = sizeof( sample_t );
+const int BYTES_PER_INT_SAMPLE = sizeof( int_sample_t );
+const int BYTES_PER_FRAME = sizeof( sampleFrame );
+const int BYTES_PER_SURROUND_FRAME = sizeof( surroundSampleFrame );
+
+const float OUTPUT_SAMPLE_MULTIPLIER = 32767.0f;
+
+
+const float BaseFreq = 440.0f;
+const Keys BaseKey = Key_A;
+const Octaves BaseOctave = DefaultOctave;
+
+
+#include "PlayHandle.h"
+
+
+class MixerWorkerThread;
+
+
+class EXPORT Mixer : public QObject
+{
+	Q_OBJECT
+public:
+	struct qualitySettings
+	{
+		enum Mode
+		{
+			Mode_Draft,
+			Mode_HighQuality,
+			Mode_FinalMix
+		} ;
+
+		enum Interpolation
+		{
+			Interpolation_Linear,
+			Interpolation_SincFastest,
+			Interpolation_SincMedium,
+			Interpolation_SincBest
+		} ; 
+
+		enum Oversampling
+		{
+			Oversampling_None,
+			Oversampling_2x,
+			Oversampling_4x,
+			Oversampling_8x
+		} ;
+
+		Interpolation interpolation;
+		Oversampling oversampling;
+		bool sampleExactControllers;
+		bool aliasFreeOscillators;
+
+		qualitySettings( Mode _m )
+		{
+			switch( _m )
+			{
+				case Mode_Draft:
+					interpolation = Interpolation_Linear;
+					oversampling = Oversampling_None;
+					sampleExactControllers = false;
+					aliasFreeOscillators = false;
+					break;
+				case Mode_HighQuality:
+					interpolation =
+						Interpolation_SincFastest;
+					oversampling = Oversampling_2x;
+					sampleExactControllers = true;
+					aliasFreeOscillators = false;
+					break;
+				case Mode_FinalMix:
+					interpolation = Interpolation_SincBest;
+					oversampling = Oversampling_8x;
+					sampleExactControllers = true;
+					aliasFreeOscillators = true;
+					break;
+			}
+		}
+
+		qualitySettings( Interpolation _i, Oversampling _o, bool _sec,
+								bool _afo ) :
+			interpolation( _i ),
+			oversampling( _o ),
+			sampleExactControllers( _sec ),
+			aliasFreeOscillators( _afo )
+		{
+		}
+
+		int sampleRateMultiplier() const
+		{
+			switch( oversampling )
+			{
+				case Oversampling_None: return 1;
+				case Oversampling_2x: return 2;
+				case Oversampling_4x: return 4;
+				case Oversampling_8x: return 8;
+			}
+			return 1;
+		}
+
+		int libsrcInterpolation() const
+		{
+			switch( interpolation )
+			{
+				case Interpolation_Linear:
+					return SRC_ZERO_ORDER_HOLD;
+				case Interpolation_SincFastest:
+					return SRC_SINC_FASTEST;
+				case Interpolation_SincMedium:
+					return SRC_SINC_MEDIUM_QUALITY;
+				case Interpolation_SincBest:
+					return SRC_SINC_BEST_QUALITY;
+			}
+			return SRC_LINEAR;
+		}
+	} ;
+
+	void initDevices();
+	void clear();
+
+
+	// audio-device-stuff
+	inline const QString & audioDevName() const
+	{
+		return m_audioDevName;
+	}
+
+	void setAudioDevice( AudioDevice * _dev );
+	void setAudioDevice( AudioDevice * _dev,
+				const struct qualitySettings & _qs,
+							bool _needs_fifo );
+	void restoreAudioDevice();
+	inline AudioDevice * audioDev()
+	{
+		return m_audioDev;
+	}
+
+
+	// audio-port-stuff
+	inline void addAudioPort( AudioPort * _port )
+	{
+		lock();
+		m_audioPorts.push_back( _port );
+		unlock();
+	}
+
+	void removeAudioPort( AudioPort * _port );
+
+
+	// MIDI-client-stuff
+	inline const QString & midiClientName() const
+	{
+		return m_midiClientName;
+	}
+
+	inline MidiClient * midiClient()
+	{
+		return m_midiClient;
+	}
+
+
+	// play-handle stuff
+	bool addPlayHandle( PlayHandle* handle )
+	{
+		if( criticalXRuns() == false )
+		{
+			lock();
+			m_playHandles.push_back( handle );
+			unlock();
+			return true;
+		}
+
+		delete handle;
+
+		return false;
+	}
+
+	void removePlayHandle( PlayHandle* handle );
+
+	inline PlayHandleList& playHandles()
+	{
+		return m_playHandles;
+	}
+
+	void removePlayHandles( track * _track );
+
+	bool hasNotePlayHandles();
+
+
+	// methods providing information for other classes
+	inline fpp_t framesPerPeriod() const
+	{
+		return m_framesPerPeriod;
+	}
+
+	inline const surroundSampleFrame * currentReadBuffer() const
+	{
+		return m_readBuf;
+	}
+
+
+	inline int cpuLoad() const
+	{
+		return m_cpuLoad;
+	}
+
+	const qualitySettings & currentQualitySettings() const
+	{
+		return m_qualitySettings;
+	}
+
+
+	sample_rate_t baseSampleRate() const;
+	sample_rate_t outputSampleRate() const;
+	sample_rate_t inputSampleRate() const;
+	sample_rate_t processingSampleRate() const;
+
+
+	inline float masterGain() const
+	{
+		return m_masterGain;
+	}
+
+	inline void setMasterGain( const float _mo )
+	{
+		m_masterGain = _mo;
+	}
+
+
+	static inline sample_t clip( const sample_t _s )
+	{
+		if( _s > 1.0f )
+		{
+			return 1.0f;
+		}
+		else if( _s < -1.0f )
+		{
+			return -1.0f;
+		}
+		return _s;
+	}
+
+
+	// methods needed by other threads to alter knob values, waveforms, etc
+	void lock()
+	{
+		m_globalMutex.lock();
+	}
+
+	void unlock()
+	{
+		m_globalMutex.unlock();
+	}
+
+	void lockInputFrames()
+	{
+		m_inputFramesMutex.lock();
+	}
+
+	void unlockInputFrames()
+	{
+		m_inputFramesMutex.unlock();
+	}
+
+	// audio-buffer-mgm
+	void bufferToPort( const sampleFrame * _buf,
+					const fpp_t _frames,
+					const f_cnt_t _offset,
+					stereoVolumeVector _volume_vector,
+					AudioPort * _port );
+
+	static void clearAudioBuffer( sampleFrame * _ab,
+						const f_cnt_t _frames,
+						const f_cnt_t _offset = 0 );
+#ifndef LMMS_DISABLE_SURROUND
+	static void clearAudioBuffer( surroundSampleFrame * _ab,
+						const f_cnt_t _frames,
+						const f_cnt_t _offset = 0 );
+#endif
+
+	static float peakValueLeft( sampleFrame * _ab, const f_cnt_t _frames );
+	static float peakValueRight( sampleFrame * _ab, const f_cnt_t _frames );
+
+
+	bool criticalXRuns() const;
+
+	inline bool hasFifoWriter() const
+	{
+		return m_fifoWriter != NULL;
+	}
+
+	void pushInputFrames( sampleFrame * _ab, const f_cnt_t _frames );
+	
+	inline const sampleFrame * inputBuffer()
+	{
+		return m_inputBuffer[ m_inputBufferRead ];
+	}
+
+	inline f_cnt_t inputBufferFrames() const
+	{
+		return m_inputBufferFrames[ m_inputBufferRead ];
+	}
+
+	inline const surroundSampleFrame * nextBuffer()
+	{
+		return hasFifoWriter() ? m_fifo->read() : renderNextBuffer();
+	}
+
+	void changeQuality( const struct qualitySettings & _qs );
+
+
+signals:
+	void qualitySettingsChanged();
+	void sampleRateChanged();
+	void nextAudioBuffer();
+
+
+private:
+	typedef fifoBuffer<surroundSampleFrame *> fifo;
+
+	class fifoWriter : public QThread
+	{
+	public:
+		fifoWriter( Mixer * _mixer, fifo * _fifo );
+
+		void finish();
+
+
+	private:
+		Mixer * m_mixer;
+		fifo * m_fifo;
+		volatile bool m_writing;
+
+		virtual void run();
+
+	} ;
+
+
+	Mixer();
+	virtual ~Mixer();
+
+	void startProcessing( bool _needs_fifo = true );
+	void stopProcessing();
+
+
+	AudioDevice * tryAudioDevices();
+	MidiClient * tryMidiClients();
+
+
+	const surroundSampleFrame * renderNextBuffer();
+
+
+
+	QVector<AudioPort *> m_audioPorts;
+
+	fpp_t m_framesPerPeriod;
+
+	sampleFrame * m_workingBuf;
+
+	sampleFrame * m_inputBuffer[2];
+	f_cnt_t m_inputBufferFrames[2];
+	f_cnt_t m_inputBufferSize[2];
+	int m_inputBufferRead;
+	int m_inputBufferWrite;
+	
+	surroundSampleFrame * m_readBuf;
+	surroundSampleFrame * m_writeBuf;
+	
+	QVector<surroundSampleFrame *> m_bufferPool;
+	int m_readBuffer;
+	int m_writeBuffer;
+	int m_poolDepth;
+
+	surroundSampleFrame m_maxClip;
+	surroundSampleFrame m_previousSample;
+	fpp_t m_halfStart[SURROUND_CHANNELS];
+	bool m_oldBuffer[SURROUND_CHANNELS];
+	bool m_newBuffer[SURROUND_CHANNELS];
+	
+	int m_cpuLoad;
+	QVector<MixerWorkerThread *> m_workers;
+	int m_numWorkers;
+	QWaitCondition m_queueReadyWaitCond;
+
+
+	PlayHandleList m_playHandles;
+	ConstPlayHandleList m_playHandlesToRemove;
+
+	struct qualitySettings m_qualitySettings;
+	float m_masterGain;
+
+
+	AudioDevice * m_audioDev;
+	AudioDevice * m_oldAudioDev;
+	QString m_audioDevName;
+
+
+	MidiClient * m_midiClient;
+	QString m_midiClientName;
+
+
+	QMutex m_globalMutex;
+	QMutex m_inputFramesMutex;
+
+
+	fifo * m_fifo;
+	fifoWriter * m_fifoWriter;
+
+
+	friend class engine;
+	friend class MixerWorkerThread;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/Model.h b/lmms/include/Model.h
new file mode 100644
index 0000000..94883c6
--- /dev/null
+++ b/lmms/include/Model.h
@@ -0,0 +1,92 @@
+/*
+ * Model.h - declaration of Model base class
+ *
+ * Copyright (c) 2007-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef MODEL_H
+#define MODEL_H
+
+#include <QtCore/QObject>
+#include <QtCore/QPointer>
+
+#include "export.h"
+
+
+class EXPORT Model : public QObject
+{
+	Q_OBJECT
+public:
+	Model( Model * _parent, QString _display_name = QString::null,
+					bool _default_constructed = false ) :
+		QObject( _parent ),
+		m_displayName( _display_name ),
+		m_defaultConstructed( _default_constructed )
+	{
+	}
+
+	virtual ~Model()
+	{
+	}
+
+	bool isDefaultConstructed()
+	{
+		return m_defaultConstructed;
+	}
+
+	Model* parentModel() const
+	{
+		return static_cast<Model *>( parent() );
+	}
+
+	virtual QString displayName() const
+	{
+		return m_displayName;
+	}
+
+	virtual void setDisplayName( const QString& displayName )
+	{
+		m_displayName = displayName;
+	}
+
+	virtual QString fullDisplayName() const;
+
+
+private:
+	QString m_displayName;
+	bool m_defaultConstructed;
+
+
+signals:
+	// emitted if actual data of the model (e.g. values) have changed
+	void dataChanged();
+
+	// emitted in case new data was not set as it's been equal to old data
+	void dataUnchanged();
+
+	// emitted if properties of the model (e.g. ranges) have changed
+	void propertiesChanged();
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/ModelView.h b/lmms/include/ModelView.h
new file mode 100644
index 0000000..9f8cd9e
--- /dev/null
+++ b/lmms/include/ModelView.h
@@ -0,0 +1,84 @@
+/*
+ * ModelView.h - declaration of ModelView base class
+ *
+ * Copyright (c) 2007-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef MODEL_VIEW_H
+#define MODEL_VIEW_H
+
+#include "Model.h"
+
+
+class EXPORT ModelView
+{
+public:
+	ModelView( Model* model, QWidget* widget );
+	virtual ~ModelView();
+
+	virtual void setModel( Model* model, bool isOldModelValid = true );
+
+	Model* model()
+	{
+		return m_model;
+	}
+
+	const Model* model() const
+	{
+		return m_model;
+	}
+
+	template<class T>
+	T* castModel()
+	{
+		return dynamic_cast<T*>( model() );
+	}
+
+	template<class T>
+	const T* castModel() const
+	{
+		return dynamic_cast<const T*>( model() );
+	}
+
+
+protected:
+	// sub-classes can re-implement this to track model-changes
+	virtual void modelChanged()
+	{
+	}
+
+	QWidget* widget()
+	{
+		return m_widget;
+	}
+
+	virtual void doConnections();
+
+
+private:
+	QWidget* m_widget;
+	QPointer<Model> m_model;
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/NotePlayHandle.h b/lmms/include/NotePlayHandle.h
new file mode 100644
index 0000000..a20aaa3
--- /dev/null
+++ b/lmms/include/NotePlayHandle.h
@@ -0,0 +1,296 @@
+/*
+ * NotePlayHandle.h - declaration of class NotePlayHandle which manages
+ *                    playback of a single note by an instrument
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef NOTE_PLAY_HANDLE_H
+#define NOTE_PLAY_HANDLE_H
+
+#include "lmmsconfig.h"
+#include "note.h"
+#include "PlayHandle.h"
+#include "track.h"
+
+
+class InstrumentTrack;
+class NotePlayHandle;
+
+template<ch_cnt_t=DEFAULT_CHANNELS> class basicFilters;
+typedef QList<NotePlayHandle *> NotePlayHandleList;
+typedef QList<const NotePlayHandle *> ConstNotePlayHandleList;
+
+
+class EXPORT NotePlayHandle : public PlayHandle, public note
+{
+public:
+	void * m_pluginData;
+	basicFilters<> * m_filter;
+
+	// specifies origin of NotePlayHandle
+	enum Origins
+	{
+		OriginPattern,		/*! playback of a note from a pattern */
+		OriginMidiInput,	/*! playback of a MIDI note input event */
+		OriginCount
+	};
+	typedef Origins Origin;
+
+	NotePlayHandle( InstrumentTrack* instrumentTrack,
+					const f_cnt_t offset,
+					const f_cnt_t frames,
+					const note& noteToPlay,
+					NotePlayHandle* parent = NULL,
+					const bool isPartOfArp = false,
+					int midiEventChannel = -1,
+					Origin origin = OriginPattern );
+	virtual ~NotePlayHandle();
+
+	virtual void setVolume( volume_t volume );
+	virtual void setPanning( panning_t panning );
+
+	int midiKey() const;
+	int midiChannel() const
+	{
+		return m_midiChannel;
+	}
+
+	const float& frequency() const
+	{
+		return m_frequency;
+	}
+
+	void updateFrequency();
+
+	/*! Returns frequency without pitch wheel influence */
+	float unpitchedFrequency() const
+	{
+		return m_unpitchedFrequency;
+	}
+
+	/*! Renders one chunk using the attached instrument into the buffer */
+	virtual void play( sampleFrame* buffer );
+
+	/*! Returns whether playback of note is finished and thus handle can be deleted */
+	virtual bool isFinished() const
+	{
+		return m_released && framesLeft() <= 0;
+	}
+
+	/*! Returns number of frames left for playback */
+	f_cnt_t framesLeft() const;
+
+	/*! Returns how many frames have to be rendered in current period */
+	fpp_t framesLeftForCurrentPeriod() const;
+
+	/*! Returns whether the play handle plays on a certain track */
+	virtual bool isFromTrack( const track* _track ) const;
+
+	/*! Releases the note (and plays release frames */
+	void noteOff( const f_cnt_t offset = 0 );
+
+	/*! Returns number of frames to be played until the note is going to be released */
+	f_cnt_t framesBeforeRelease() const
+	{
+		return m_framesBeforeRelease;
+	}
+
+	/*! Returns how many frames were played since release */
+	f_cnt_t releaseFramesDone() const
+	{
+		return m_releaseFramesDone;
+	}
+
+	/*! Returns the number of frames to be played after release according to
+	    the release times in the envelopes */
+	f_cnt_t actualReleaseFramesToDo() const;
+
+	/*! Returns total numbers of frames to play (including release frames) */
+	f_cnt_t frames() const
+	{
+		return m_frames;
+	}
+
+	/*! Sets the total number of frames to play (including release frames) */
+	void setFrames( const f_cnt_t _frames );
+
+	/*! Returns whether note was released */
+	bool isReleased() const
+	{
+		return m_released;
+	}
+
+	/*! Returns total numbers of frames played so far */
+	f_cnt_t totalFramesPlayed() const
+	{
+		return m_totalFramesPlayed;
+	}
+
+	/*! Returns volume level at given frame (envelope/LFO) */
+	float volumeLevel( const f_cnt_t frame );
+
+	/*! Returns instrument track which is being played by this handle (const version) */
+	const InstrumentTrack* instrumentTrack() const
+	{
+		return m_instrumentTrack;
+	}
+
+	/*! Returns instrument track which is being played by this handle */
+	InstrumentTrack* instrumentTrack()
+	{
+		return m_instrumentTrack;
+	}
+
+	/*! Returns whether note is a top note, e.g. is not part of an arpeggio or a chord */
+	bool isTopNote() const
+	{
+		return m_topNote;
+	}
+
+	/*! Returns whether note is part of an arpeggio playback */
+	bool isPartOfArpeggio() const
+	{
+		return m_partOfArpeggio;
+	}
+
+	/*! Sets whether note is part of an arpeggio playback */
+	void setPartOfArpeggio( const bool _on )
+	{
+		m_partOfArpeggio = _on;
+	}
+
+	/*! Returns whether note is base note for arpeggio */
+	bool isArpeggioBaseNote() const;
+
+	/*! Returns whether note is muted */
+	bool isMuted() const
+	{
+		return m_muted;
+	}
+
+	/*! Mutes playback of note */
+	void mute();
+
+	/*! Returns index of NotePlayHandle in vector of note-play-handles
+        belonging to this instrument track - used by arpeggiator */
+	int index() const;
+
+	/*! returns list of note-play-handles belonging to given instrument track,
+	    if allPlayHandles = true, also released note-play-handles are returned */
+	static ConstNotePlayHandleList nphsOfInstrumentTrack( const InstrumentTrack* track, bool allPlayHandles = false );
+
+	/*! Returns whether given NotePlayHandle instance is equal to *this */
+	bool operator==( const NotePlayHandle & _nph ) const;
+
+	/*! Returns whether NotePlayHandle belongs to BB track and BB track is muted */
+	bool isBbTrackMuted()
+	{
+		return m_bbTrack && m_bbTrack->isMuted();
+	}
+
+	/*! Sets attached BB track */
+	void setBBTrack( track* t )
+	{
+		m_bbTrack = t;
+	}
+
+	/*! Process note detuning automation */
+	void processMidiTime( const MidiTime& time );
+
+	/*! Updates total length (m_frames) depending on a new tempo */
+	void resize( const bpm_t newTempo );
+
+	/*! Set song-global offset (relative to containing pattern) in order to properly perform the note detuning */
+	void setSongGlobalParentOffset( const MidiTime& offset )
+	{
+		m_songGlobalParentOffset = offset;
+	}
+
+	/*! Returns song-global offset */
+	const MidiTime& songGlobalParentOffset() const
+	{
+		return m_songGlobalParentOffset;
+	}
+
+
+private:
+	class BaseDetuning
+	{
+	public:
+		BaseDetuning( DetuningHelper* detuning );
+
+		void setValue( float val )
+		{
+			m_value = val;
+		}
+
+		float value() const
+		{
+			return m_value;
+		}
+
+
+	private:
+		float m_value;
+
+	} ;
+
+	InstrumentTrack* m_instrumentTrack;		// needed for calling
+											// InstrumentTrack::playNote
+	f_cnt_t m_frames;						// total frames to play
+	f_cnt_t m_totalFramesPlayed;			// total frame-counter - used for
+											// figuring out whether a whole note
+											// has been played
+	f_cnt_t m_framesBeforeRelease;			// number of frames after which note
+											// is released
+	f_cnt_t m_releaseFramesToDo;			// total numbers of frames to be
+											// played after release
+	f_cnt_t m_releaseFramesDone;			// number of frames done after
+											// release of note
+	NotePlayHandleList m_subNotes;			// used for chords and arpeggios
+	volatile bool m_released;				// indicates whether note is released
+	bool m_topNote;							// indicates whether note is a
+											// base-note (i.e. no sub-note)
+	bool m_partOfArpeggio;					// indicates whether note is part of
+											// an arpeggio (either base-note or
+											// sub-note)
+	bool m_muted;							// indicates whether note is muted
+	track* m_bbTrack;						// related BB track
+
+	// tempo reaction
+	bpm_t m_origTempo;						// original tempo
+	f_cnt_t m_origFrames;					// original m_frames
+
+	const int m_origBaseNote;
+
+	float m_frequency;
+	float m_unpitchedFrequency;
+
+	BaseDetuning* m_baseDetuning;
+	MidiTime m_songGlobalParentOffset;
+
+	const int m_midiChannel;
+	const Origin m_origin;
+
+} ;
+
+#endif
diff --git a/lmms/include/Oscillator.h b/lmms/include/Oscillator.h
new file mode 100644
index 0000000..cca73ab
--- /dev/null
+++ b/lmms/include/Oscillator.h
@@ -0,0 +1,215 @@
+/*
+ * Oscillator.h - declaration of class Oscillator
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _OSCILLATOR_H
+#define _OSCILLATOR_H
+
+#include "lmmsconfig.h"
+
+#include <math.h>
+
+#ifdef LMMS_HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "SampleBuffer.h"
+#include "lmms_constants.h"
+
+
+class SampleBuffer;
+class IntModel;
+
+
+class EXPORT Oscillator
+{
+public:
+	enum WaveShapes
+	{
+		SineWave,
+		TriangleWave,
+		SawWave,
+		SquareWave,
+		MoogSawWave,
+		ExponentialWave,
+		WhiteNoise,
+		UserDefinedWave,
+		NumWaveShapes
+	} ;
+
+	enum ModulationAlgos
+	{
+		PhaseModulation,
+		AmplitudeModulation,
+		SignalMix,
+		SynchronizedBySubOsc,
+		FrequencyModulation,
+		NumModulationAlgos
+	} ;
+
+
+	Oscillator( const IntModel * _wave_shape_model,
+			const IntModel * _mod_algo_model,
+			const float & _freq,
+			const float & _detuning,
+			const float & _phase_offset,
+			const float & _volume,
+			Oscillator * _m_subOsc = NULL );
+	virtual ~Oscillator()
+	{
+		delete m_subOsc;
+	}
+
+
+	inline void setUserWave( const SampleBuffer * _wave )
+	{
+		m_userWave = _wave;
+	}
+
+	void update( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+
+	// now follow the wave-shape-routines...
+
+	static inline sample_t sinSample( const float _sample )
+	{
+		return sinf( _sample * F_2PI );
+	}
+
+	static inline sample_t triangleSample( const float _sample )
+	{
+		const float ph = fraction( _sample );
+		if( ph <= 0.25f )
+		{
+			return ph * 4.0f;
+		}
+		else if( ph <= 0.75f )
+		{
+			return 2.0f - ph * 4.0f;
+		}
+		return ph * 4.0f - 4.0f;
+	}
+
+	static inline sample_t sawSample( const float _sample )
+	{
+		return -1.0f + fraction( _sample ) * 2.0f;
+	}
+
+	static inline sample_t squareSample( const float _sample )
+	{
+		return ( fraction( _sample ) > 0.5f ) ? -1.0f : 1.0f;
+	}
+
+	static inline sample_t moogSawSample( const float _sample )
+	{
+		const float ph = fraction( _sample );
+		if( ph < 0.5f )
+		{
+			return -1.0f + ph * 4.0f;
+		}
+		return 1.0f - 2.0f * ph;
+	}
+
+	static inline sample_t expSample( const float _sample )
+	{
+		float ph = fraction( _sample );
+		if( ph > 0.5f )
+		{
+			ph = 1.0f - ph;
+		}
+		return -1.0f + 8.0f * ph * ph;
+	}
+
+	static inline sample_t noiseSample( const float )
+	{
+		// Precise implementation
+//		return 1.0f - rand() * 2.0f / RAND_MAX;
+
+		// Fast implementation
+		return 1.0f - fast_rand() * 2.0f / FAST_RAND_MAX;
+	}
+
+	inline sample_t userWaveSample( const float _sample ) const
+	{
+		return m_userWave->userWaveSample( _sample );
+	}
+
+
+private:
+	const IntModel * m_waveShapeModel;
+	const IntModel * m_modulationAlgoModel;
+	const float & m_freq;
+	const float & m_detuning;
+	const float & m_volume;
+	const float & m_ext_phaseOffset;
+	Oscillator * m_subOsc;
+	float m_phaseOffset;
+	float m_phase;
+	const SampleBuffer * m_userWave;
+
+
+	void updateNoSub( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	void updatePM( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	void updateAM( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	void updateMix( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	void updateSync( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	void updateFM( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+
+	float syncInit( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	inline bool syncOk( float _osc_coeff );
+
+	template<WaveShapes W>
+	void updateNoSub( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	template<WaveShapes W>
+	void updatePM( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	template<WaveShapes W>
+	void updateAM( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	template<WaveShapes W>
+	void updateMix( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	template<WaveShapes W>
+	void updateSync( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+	template<WaveShapes W>
+	void updateFM( sampleFrame * _ab, const fpp_t _frames,
+							const ch_cnt_t _chnl );
+
+	template<WaveShapes W>
+	inline sample_t getSample( const float _sample );
+
+	inline void recalcPhase();
+
+} ;
+
+
+#endif
diff --git a/lmms/include/PeakController.h b/lmms/include/PeakController.h
new file mode 100644
index 0000000..89691aa
--- /dev/null
+++ b/lmms/include/PeakController.h
@@ -0,0 +1,99 @@
+/*
+ * PeakController.h - peak-controller class
+ *
+ * Copyright (c) 2008-2009 Paul Giblock <drfaygo/at/gmail.com>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PEAK_CONTROLLER_H
+#define _PEAK_CONTROLLER_H
+
+#include <QtGui/QWidget>
+
+#include "Model.h"
+#include "AutomatableModel.h"
+#include "Controller.h"
+#include "ControllerDialog.h"
+
+class automatableButtonGroup;
+class knob;
+class PeakControllerEffect;
+
+typedef QVector<PeakControllerEffect *> PeakControllerEffectVector;
+
+
+class EXPORT PeakController : public Controller
+{
+	Q_OBJECT
+public:
+	PeakController( Model * _parent,
+		PeakControllerEffect *_peak_effect = NULL );
+
+
+	virtual ~PeakController();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _this );
+	virtual void loadSettings( const QDomElement & _this );
+	virtual QString nodeName() const;
+
+	static void initGetControllerBySetting();
+	static PeakController * getControllerBySetting( const QDomElement & _this );
+
+	static PeakControllerEffectVector s_effects;
+
+
+public slots:
+	virtual ControllerDialog * createDialog( QWidget * _parent );
+	void handleDestroyedEffect( ); 
+
+protected:
+	// The internal per-controller get-value function
+	virtual float value( int _offset );
+
+	PeakControllerEffect * m_peakEffect;
+
+	friend class PeakControllerDialog;
+
+private:
+	//backward compatibility for <= 0.4.15
+	static int m_getCount;
+	static int m_loadCount;
+	static bool m_buggedFile;
+} ;
+
+
+
+class PeakControllerDialog : public ControllerDialog
+{
+	Q_OBJECT
+public:
+	PeakControllerDialog( Controller * _controller, QWidget * _parent );
+	virtual ~PeakControllerDialog();
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void modelChanged();
+
+	PeakController * m_peakController;
+
+} ;
+
+#endif
diff --git a/lmms/include/Piano.h b/lmms/include/Piano.h
new file mode 100644
index 0000000..8e86622
--- /dev/null
+++ b/lmms/include/Piano.h
@@ -0,0 +1,80 @@
+/*
+ * Piano.h - declaration of class Piano
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef PIANO_H
+#define PIANO_H
+
+#include "note.h"
+#include "Model.h"
+
+class InstrumentTrack;
+class MidiEventProcessor;
+
+class Piano : public Model
+{
+public:
+	enum KeyTypes
+	{
+		WhiteKey,
+		BlackKey
+	} ;
+
+	Piano( InstrumentTrack* track );
+	virtual ~Piano();
+
+	void setKeyState( int key, bool state );
+
+	bool isKeyPressed( int key ) const
+	{
+		return m_pressedKeys[key];
+	}
+
+	void handleKeyPress( int key, int midiVelocity = -1 );
+	void handleKeyRelease( int key );
+
+	InstrumentTrack* instrumentTrack() const
+	{
+		return m_instrumentTrack;
+	}
+
+	MidiEventProcessor* midiEventProcessor() const
+	{
+		return m_midiEvProc;
+	}
+
+
+private:
+	static bool isValidKey( int key )
+	{
+		return key >= 0 && key < NumKeys;
+	}
+
+	InstrumentTrack* m_instrumentTrack;
+	MidiEventProcessor* m_midiEvProc;
+	bool m_pressedKeys[NumKeys];
+
+} ;
+
+#endif
+
diff --git a/lmms/include/PianoRoll.h b/lmms/include/PianoRoll.h
new file mode 100644
index 0000000..cdd1986
--- /dev/null
+++ b/lmms/include/PianoRoll.h
@@ -0,0 +1,354 @@
+/*
+ * PianoRoll.h - declaration of class PianoRoll which is a window where you
+ *               can set and edit notes in an easy way
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * Copyright (c) 2008 Andrew Kelley <superjoe30/at/gmail/dot/com>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef PIANO_ROLL_H
+#define PIANO_ROLL_H
+
+#include <QtGui/QWidget>
+
+#include "ComboBoxModel.h"
+#include "SerializingObject.h"
+#include "note.h"
+#include "lmms_basics.h"
+#include "song.h"
+
+
+class QPainter;
+class QPixmap;
+class QScrollBar;
+class QString;
+class QMenu;
+class QSignalMapper;
+
+class comboBox;
+class NotePlayHandle;
+class pattern;
+class timeLine;
+class toolButton;
+
+class PianoRoll : public QWidget, public SerializingObject
+{
+	Q_OBJECT
+public:
+	void setCurrentPattern( pattern * _new_pattern );
+
+	inline void stopRecording()
+	{
+		m_recording = false;
+	}
+
+	inline bool isRecording() const
+	{
+		return m_recording;
+	}
+
+	inline const pattern * currentPattern() const
+	{
+		return m_pattern;
+	}
+
+	inline bool validPattern() const
+	{
+		return m_pattern != NULL;
+	}
+
+	song::PlayModes desiredPlayModeForAccompany() const;
+
+	int quantization() const;
+
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+	inline virtual QString nodeName() const
+	{
+		return "pianoroll";
+	}
+
+	void setPauseIcon( bool pause );
+
+
+protected:
+	virtual void closeEvent( QCloseEvent * _ce );
+	virtual void keyPressEvent( QKeyEvent * _ke );
+	virtual void keyReleaseEvent( QKeyEvent * _ke );
+	virtual void leaveEvent( QEvent * _e );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseDoubleClickEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+	virtual void mouseMoveEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void resizeEvent( QResizeEvent * _re );
+	virtual void wheelEvent( QWheelEvent * _we );
+
+	int getKey( int _y ) const;
+	static inline void drawNoteRect( QPainter & _p, int _x, int _y,
+					int  _width, note * _n );
+	void removeSelection();
+	void selectAll();
+	void getSelectedNotes( NoteVector & _selected_notes );
+
+
+protected slots:
+	void play();
+	void record();
+	void recordAccompany();
+	void stop();
+
+	void startRecordNote( const note & _n );
+	void finishRecordNote( const note & _n );
+
+	void horScrolled( int _new_pos );
+	void verScrolled( int _new_pos );
+
+	void drawButtonToggled();
+	void eraseButtonToggled();
+	void selectButtonToggled();
+	void detuneButtonToggled();
+
+	void copySelectedNotes();
+	void cutSelectedNotes();
+	void pasteNotes();
+	void deleteSelectedNotes();
+
+	void updatePosition( const MidiTime & _t );
+	void updatePositionAccompany( const MidiTime & _t );
+
+	void zoomingChanged();
+	void quantizeChanged();
+
+	void updateSemiToneMarkerMenu();
+
+	void changeNoteEditMode( int i );
+	void markSemiTone( int i );
+
+
+signals:
+	void currentPatternChanged();
+	void semiToneMarkerMenuScaleSetEnabled(bool);
+	void semiToneMarkerMenuChordSetEnabled(bool);
+
+
+private:
+	enum editModes
+	{
+		ModeDraw,
+		ModeErase,
+		ModeSelect,
+		ModeEditDetuning,
+	};
+
+	enum actions
+	{
+		ActionNone,
+		ActionMoveNote,
+		ActionResizeNote,
+		ActionSelectNotes,
+		ActionChangeNoteProperty,
+		ActionResizeNoteEditArea
+	};
+
+	enum noteEditMode
+	{
+		NoteEditVolume,
+		NoteEditPanning,
+		NoteEditCount // make sure this one is always last
+	};
+
+	enum semiToneMarkerAction
+	{
+		stmaUnmarkAll,
+		stmaMarkCurrentSemiTone,
+		stmaMarkCurrentScale,
+		stmaMarkCurrentChord,
+	};
+
+	enum PianoRollKeyTypes
+	{
+		PR_WHITE_KEY_SMALL,
+		PR_WHITE_KEY_BIG,
+		PR_BLACK_KEY
+	};
+
+	QVector<QString> m_nemStr; // gui names of each edit mode
+	QMenu * m_noteEditMenu; // when you right click below the key area
+
+	QList<int> m_markedSemiTones;
+	QMenu * m_semiToneMarkerMenu; // when you right click on the key area
+
+	PianoRoll();
+	PianoRoll( const PianoRoll & );
+	virtual ~PianoRoll();
+
+	void autoScroll( const MidiTime & _t );
+
+	MidiTime newNoteLen() const;
+
+	void shiftPos(int amount);
+	void shiftSemiTone(int amount);
+	bool isSelection() const;
+	int selectionCount() const;
+	void testPlayNote( note * n );
+	void testPlayKey( int _key, int _vol, int _pan );
+	void pauseTestNotes( bool _pause = true );
+
+	inline int noteEditTop() const;
+	inline int keyAreaBottom() const;
+	inline int noteEditBottom() const;
+	inline int keyAreaTop() const;
+	inline int noteEditRight() const;
+	inline int noteEditLeft() const;
+
+	void dragNotes( int x, int y, bool alt, bool shift );
+
+	static const int cm_scrollAmtHoriz = 10;
+	static const int cm_scrollAmtVert = 1;
+
+	static QPixmap * s_whiteKeyBigPm;
+	static QPixmap * s_whiteKeyBigPressedPm;
+	static QPixmap * s_whiteKeySmallPm;
+	static QPixmap * s_whiteKeySmallPressedPm;
+	static QPixmap * s_blackKeyPm;
+	static QPixmap * s_blackKeyPressedPm;
+	static QPixmap * s_toolDraw;
+	static QPixmap * s_toolErase;
+	static QPixmap * s_toolSelect;
+	static QPixmap * s_toolMove;
+	static QPixmap * s_toolOpen;
+
+	static PianoRollKeyTypes prKeyOrder[];
+
+
+	QWidget * m_toolBar;
+
+	toolButton * m_playButton;
+	toolButton * m_recordButton;
+	toolButton * m_recordAccompanyButton;
+	toolButton * m_stopButton;
+
+	toolButton * m_drawButton;
+	toolButton * m_eraseButton;
+	toolButton * m_selectButton;
+	toolButton * m_detuneButton;
+
+	toolButton * m_cutButton;
+	toolButton * m_copyButton;
+	toolButton * m_pasteButton;
+
+	comboBox * m_zoomingComboBox;
+	comboBox * m_quantizeComboBox;
+	comboBox * m_noteLenComboBox;
+	comboBox * m_scaleComboBox;
+	comboBox * m_chordComboBox;
+
+	ComboBoxModel m_zoomingModel;
+	ComboBoxModel m_quantizeModel;
+	ComboBoxModel m_noteLenModel;
+	ComboBoxModel m_scaleModel;
+	ComboBoxModel m_chordModel;
+
+
+
+	pattern * m_pattern;
+	QScrollBar * m_leftRightScroll;
+	QScrollBar * m_topBottomScroll;
+
+	MidiTime m_currentPosition;
+	bool m_recording;
+	QList<note> m_recordingNotes;
+
+	note * m_currentNote;
+	actions m_action;
+	noteEditMode m_noteEditMode;
+
+	int m_selectStartTick;
+	int m_selectedTick;
+	int m_selectStartKey;
+	int m_selectedKeys;
+
+	// boundary box around all selected notes when dragging
+	int m_moveBoundaryLeft;
+	int m_moveBoundaryTop;
+	int m_moveBoundaryRight;
+	int m_moveBoundaryBottom;
+
+	// remember where the scrolling started when dragging so that
+	// we can handle dragging while scrolling with arrow keys
+	int m_mouseDownKey;
+	int m_mouseDownTick;
+
+	// remember the last x and y of a mouse movement
+	int m_lastMouseX;
+	int m_lastMouseY;
+
+	// x,y of when the user starts a drag
+	int m_moveStartX;
+	int m_moveStartY;
+
+	int m_oldNotesEditHeight;
+	int m_notesEditHeight;
+	int m_ppt;
+	int m_totalKeysToScroll;
+
+	// remember these values to use them
+	// for the next note that is set
+	MidiTime m_lenOfNewNotes;
+	volume_t m_lastNoteVolume;
+	panning_t m_lastNotePanning;
+
+	int m_startKey;			// first key when drawing
+	int m_lastKey;
+
+	editModes m_editMode;
+	editModes m_ctrlMode; // mode they were in before they hit ctrl
+
+	bool m_mouseDownLeft; //true if left click is being held down
+	bool m_mouseDownRight; //true if right click is being held down
+
+	timeLine * m_timeLine;
+	bool m_scrollBack;
+
+	void copy_to_clipboard( const NoteVector & _notes ) const;
+
+	void drawDetuningInfo( QPainter & _p, note * _n, int _x, int _y );
+	bool mouseOverNote();
+	note * noteUnderMouse();
+
+	// turn a selection rectangle into selected notes
+	void computeSelectedNotes( bool shift );
+	void clearSelectedNotes();
+
+	friend class engine;
+
+
+signals:
+	void positionChanged( const MidiTime & );
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/PianoView.h b/lmms/include/PianoView.h
new file mode 100644
index 0000000..3f99fbc
--- /dev/null
+++ b/lmms/include/PianoView.h
@@ -0,0 +1,89 @@
+/*
+ * PianoView.h - declaration of PianoView, an interactive piano/keyboard-widget
+ *
+ * Copyright (c) 2004-2010 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PIANO_VIEW_H
+#define _PIANO_VIEW_H
+
+#include <QtGui/QPixmap>
+#include <QtGui/QScrollBar>
+
+#include "ModelView.h"
+
+class Piano;
+
+
+class PianoView : public QWidget, public ModelView
+{
+	Q_OBJECT
+public:
+	PianoView( QWidget * _parent );
+	virtual ~PianoView();
+
+	static int getKeyFromKeyEvent( QKeyEvent * _ke );
+
+
+public:
+	virtual void keyPressEvent( QKeyEvent * ke );
+	virtual void keyReleaseEvent( QKeyEvent * ke );
+
+
+protected:
+	virtual void modelChanged();
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+	virtual void paintEvent( QPaintEvent * );
+	virtual void mousePressEvent( QMouseEvent * me );
+	virtual void mouseReleaseEvent( QMouseEvent * me );
+	virtual void mouseMoveEvent( QMouseEvent * me );
+	virtual void focusOutEvent( QFocusEvent * _fe );
+	virtual void resizeEvent( QResizeEvent * _event );
+
+
+private:
+	int getKeyFromMouse( const QPoint & _p ) const;
+	int getKeyX( int _key_num ) const;
+
+	static QPixmap * s_whiteKeyPm;
+	static QPixmap * s_blackKeyPm;
+	static QPixmap * s_whiteKeyPressedPm;
+	static QPixmap * s_blackKeyPressedPm;
+
+	Piano * m_piano;
+
+	QScrollBar * m_pianoScroll;
+	int m_startKey;			// first key when drawing
+	int m_lastKey;
+
+
+private slots:
+	void pianoScrolled( int _new_pos );
+
+signals:
+	void keyPressed( int );
+	void baseNoteChanged();
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/Pitch.h b/lmms/include/Pitch.h
new file mode 100644
index 0000000..dc47985
--- /dev/null
+++ b/lmms/include/Pitch.h
@@ -0,0 +1,38 @@
+/*
+ * Pitch.h - declaration of some constants and types concerning instrument pitch
+ *
+ * Copyright (c) 2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PITCH_H
+#define _PITCH_H
+
+#include "lmms_basics.h"
+#include "Midi.h"
+
+typedef int16_t pitch_t;
+
+const pitch_t CentsPerSemitone = 100;
+const pitch_t MinPitchDefault = -CentsPerSemitone;
+const pitch_t MaxPitchDefault = CentsPerSemitone;
+const pitch_t DefaultPitch = 0;
+
+#endif
diff --git a/lmms/include/PlayHandle.h b/lmms/include/PlayHandle.h
new file mode 100644
index 0000000..f4d3257
--- /dev/null
+++ b/lmms/include/PlayHandle.h
@@ -0,0 +1,106 @@
+/*
+ * PlayHandle.h - base class PlayHandle - core of rendering engine
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef PLAY_HANDLE_H
+#define PLAY_HANDLE_H
+
+#include <QtCore/QThread>
+#include <QtCore/QVector>
+
+#include "lmms_basics.h"
+
+class track;
+
+
+class PlayHandle
+{
+public:
+	enum Types
+	{
+		TypeNotePlayHandle,
+		TypeInstrumentPlayHandle,
+		TypeSamplePlayHandle,
+		TypePresetPreviewHandle,
+		TypeCount
+	} ;
+	typedef Types Type;
+
+	PlayHandle( const Type type, f_cnt_t offset = 0 ) :
+		m_type( type ),
+		m_offset( offset ),
+		m_affinity( QThread::currentThread() )
+	{
+	}
+
+	virtual ~PlayHandle()
+	{
+	}
+
+	virtual bool affinityMatters() const
+	{
+		return false;
+	}
+
+	const QThread* affinity() const
+	{
+		return m_affinity;
+	}
+
+	Type type() const
+	{
+		return m_type;
+	}
+
+	virtual void play( sampleFrame* buffer ) = 0;
+	virtual bool isFinished( void ) const = 0;
+
+	// returns how many frames this play-handle is aligned ahead, i.e.
+	// at which position it is inserted in the according buffer
+	f_cnt_t offset() const
+	{
+		return m_offset;
+	}
+
+	void setOffset( f_cnt_t _offset )
+	{
+		m_offset = _offset;
+	}
+
+
+	virtual bool isFromTrack( const track * _track ) const = 0;
+
+
+private:
+	Type m_type;
+	f_cnt_t m_offset;
+	const QThread* m_affinity;
+
+} ;
+
+
+typedef QList<PlayHandle *> PlayHandleList;
+typedef QList<const PlayHandle *> ConstPlayHandleList;
+
+
+#endif
diff --git a/lmms/include/Plugin.h b/lmms/include/Plugin.h
new file mode 100644
index 0000000..1deb6a6
--- /dev/null
+++ b/lmms/include/Plugin.h
@@ -0,0 +1,204 @@
+/*
+ * Plugin.h - class plugin, the base-class and generic interface for all plugins
+ *
+ * Copyright (c) 2005-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PLUGIN_H
+#define _PLUGIN_H
+
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QList>
+#include <QtXml/QDomDocument>
+
+#include "JournallingObject.h"
+#include "Model.h"
+#include "base64.h"
+
+
+
+class QWidget;
+
+class PixmapLoader;
+class PluginView;
+class AutomatableModel;
+
+
+class EXPORT Plugin : public JournallingObject, public Model
+{
+public:
+	enum PluginTypes
+	{
+		Instrument,	// instrument being used in channel-track
+		Effect,		// effect-plugin for effect-board
+		ImportFilter,	// filter for importing a file
+		ExportFilter,	// filter for exporting a file
+		Tool,		// additional tool (level-meter etc)
+		Library,	// simple library holding a code-base for
+				// several other plugins (e.g. VST-support)
+		Other,
+		Undefined = 255
+	} ;
+
+	// descriptor holds information about a plugin - every external plugin
+	// has to instantiate such a descriptor in an extern "C"-section so that
+	// the plugin-loader is able to access information about the plugin
+	struct Descriptor
+	{
+		const char * name;
+		const char * displayName;
+		const char * description;
+		const char * author;
+		int version;
+		PluginTypes type;
+		const PixmapLoader * logo;
+		const char * supportedFileTypes;
+		inline bool supportsFileType( const QString & _ext ) const
+		{
+			return QString( supportedFileTypes ).
+						split( QChar( ',' ) ).
+							contains( _ext );
+		}
+		class EXPORT SubPluginFeatures
+		{
+		public:
+			struct Key
+			{
+				typedef QMap<QString, QString> AttributeMap;
+
+				inline Key( const Plugin::Descriptor * _desc = NULL,
+							const QString & _name = QString(),
+							const AttributeMap & _am = AttributeMap() )
+					:
+					desc( _desc ),
+					name( _name ),
+					attributes( _am )
+				{
+				}
+
+				Key( const QDomElement & _key );
+
+				QDomElement saveXML( QDomDocument & _doc ) const;
+
+				inline bool isValid() const
+				{
+					return desc != NULL &&
+							name != QString::null;
+				}
+
+				const Plugin::Descriptor * desc;
+				QString name;
+				AttributeMap attributes;
+			} ;
+
+			typedef QList<Key> KeyList;
+
+
+			SubPluginFeatures( Plugin::PluginTypes _type ) :
+				m_type( _type )
+			{
+			}
+
+			virtual ~SubPluginFeatures()
+			{
+			}
+
+			virtual void fillDescriptionWidget( QWidget *, const Key * ) const
+			{
+			}
+
+			virtual void listSubPluginKeys( const Plugin::Descriptor *,
+															KeyList & ) const
+			{
+			}
+
+
+		protected:
+			const Plugin::PluginTypes m_type;
+		} ;
+
+		SubPluginFeatures * subPluginFeatures;
+
+	} ;
+
+	// typedef a list so we can easily work with list of plugin descriptors
+	typedef QList<Descriptor> DescriptorList;
+
+	// contructor of a plugin
+	Plugin( const Descriptor * _descriptor, Model * _parent );
+	virtual ~Plugin();
+
+	// returns display-name out of descriptor
+	virtual QString displayName() const
+	{
+		return Model::displayName().isEmpty() ?
+					m_descriptor->displayName :
+							Model::displayName();
+	}
+
+	// return plugin-type
+	inline PluginTypes type( void ) const
+	{
+		return m_descriptor->type;
+	}
+
+	// return plugin-descriptor for further information
+	inline const Descriptor * descriptor() const
+	{
+		return m_descriptor;
+	}
+
+	// can be called if a file matching supportedFileTypes should be
+	// loaded/processed with the help of this plugin
+	virtual void loadFile( const QString & _file );
+
+	// Called if external source needs to change something but we cannot
+	// reference the class header.  Should return null if not key not found.
+	virtual AutomatableModel * childModel( const QString & _modelName );
+
+	// returns an instance of a plugin whose name matches to given one
+	// if specified plugin couldn't be loaded, it creates a dummy-plugin
+	static Plugin * instantiate( const QString & _plugin_name,
+									Model * _parent, void * _data );
+
+	// fills given list with descriptors of all available plugins
+	static void getDescriptorsOfAvailPlugins( DescriptorList & _plugin_descs );
+
+	// create a view for the model 
+	PluginView * createView( QWidget * _parent );
+
+
+protected:
+	// create a view for the model 
+	virtual PluginView * instantiateView( QWidget * ) = 0;
+
+
+private:
+	const Descriptor * m_descriptor;
+
+	// pointer to instantiation-function in plugin
+	typedef Plugin * ( * instantiationHook )( Model *, void * );
+
+} ;
+
+
+#endif
diff --git a/lmms/include/PluginView.h b/lmms/include/PluginView.h
new file mode 100644
index 0000000..0f17ff2
--- /dev/null
+++ b/lmms/include/PluginView.h
@@ -0,0 +1,46 @@
+/*
+ * PluginView.h - declaration of class PluginView
+ *
+ * Copyright (c) 2008-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PLUGIN_VIEW_H
+#define _PLUGIN_VIEW_H
+
+#include <QtGui/QWidget>
+
+#include "Plugin.h"
+#include "ModelView.h"
+
+
+class EXPORT PluginView  : public QWidget, public ModelView
+{
+public:
+	PluginView( Plugin * _plugin, QWidget * _parent ) :
+		QWidget( _parent ),
+		ModelView( _plugin, this )
+	{
+	}
+
+} ;
+
+
+#endif
diff --git a/lmms/include/PresetPreviewPlayHandle.h b/lmms/include/PresetPreviewPlayHandle.h
new file mode 100644
index 0000000..19b3e46
--- /dev/null
+++ b/lmms/include/PresetPreviewPlayHandle.h
@@ -0,0 +1,61 @@
+/*
+ * PresetPreviewPlayHandle.h - a PlayHandle specialization for playback of a short
+ *                             preview of a preset or a file processed by a plugin
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PRESET_PREVIEW_PLAY_HANDLE_H
+#define _PRESET_PREVIEW_PLAY_HANDLE_H
+
+#include "NotePlayHandle.h"
+
+
+class InstrumentTrack;
+class PreviewTrackContainer;
+
+class EXPORT PresetPreviewPlayHandle : public PlayHandle
+{
+public:
+	PresetPreviewPlayHandle( const QString& presetFile, bool loadByPlugin = false );
+	virtual ~PresetPreviewPlayHandle();
+
+	virtual void play( sampleFrame* buffer );
+	virtual bool isFinished() const;
+
+	virtual bool isFromTrack( const track * _track ) const;
+
+	static void init();
+	static void cleanup();
+	static ConstNotePlayHandleList nphsOfInstrumentTrack( const InstrumentTrack* instrumentTrack );
+
+	static bool isPreviewing();
+
+
+private:
+	static PreviewTrackContainer* s_previewTC;
+
+	NotePlayHandle* m_previewNote;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/ProjectJournal.h b/lmms/include/ProjectJournal.h
new file mode 100644
index 0000000..041f750
--- /dev/null
+++ b/lmms/include/ProjectJournal.h
@@ -0,0 +1,106 @@
+/*
+ * ProjectJournal.h - declaration of class ProjectJournal
+ *
+ * Copyright (c) 2006-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PROJECT_JOURNAL_H
+#define _PROJECT_JOURNAL_H
+
+#include <QtCore/QHash>
+#include <QtCore/QVariant>
+#include <QtCore/QVector>
+
+#include "lmms_basics.h"
+
+class JournallingObject;
+
+
+class ProjectJournal
+{
+public:
+	ProjectJournal();
+	virtual ~ProjectJournal();
+
+	void undo();
+	void redo();
+
+	// tell history that a new journal entry was added to object with ID _id
+	void journalEntryAdded( const jo_id_t _id );
+
+	bool isJournalling() const
+	{
+		return m_journalling;
+	}
+
+	void setJournalling( const bool _on )
+	{
+		m_journalling = _on;
+	}
+
+	// alloc new ID and register object _obj to it
+	jo_id_t allocID( JournallingObject * _obj );
+
+	// if there's already something known about ID _id, but it is currently
+	// unused (e.g. after jouralling object was deleted), register object
+	// _obj to this id
+	void reallocID( const jo_id_t _id, JournallingObject * _obj );
+
+	// make ID _id unused, but keep all global journalling information
+	// (order of journalling entries etc.) referring to _id - needed for
+	// restoring a journalling object later
+	void freeID( const jo_id_t _id )
+	{
+		reallocID( _id, NULL );
+	}
+
+	// completely remove everything linked with ID _id - all global
+	// journalling information about the ID get's lost
+	void forgetAboutID( const jo_id_t _id );
+
+	void clearJournal();
+
+	JournallingObject * journallingObject( const jo_id_t _id )
+	{
+		if( m_joIDs.contains( _id ) )
+		{
+			return m_joIDs[_id];
+		}
+		return NULL;
+	}
+
+
+private:
+	typedef QHash<jo_id_t, JournallingObject *> JoIdMap;
+	typedef QVector<jo_id_t> JournalEntryVector;
+
+	JoIdMap m_joIDs;
+
+	JournalEntryVector m_journalEntries;
+	JournalEntryVector::Iterator m_currentJournalEntry;
+
+	bool m_journalling;
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/ProjectRenderer.h b/lmms/include/ProjectRenderer.h
new file mode 100644
index 0000000..afee328
--- /dev/null
+++ b/lmms/include/ProjectRenderer.h
@@ -0,0 +1,118 @@
+/*
+ * ProjectRenderer.h - ProjectRenderer class for easily rendering projects
+ *
+ * Copyright (c) 2008-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PROJECT_RENDERER_H
+#define _PROJECT_RENDERER_H
+
+#include "AudioFileDevice.h"
+#include "lmmsconfig.h"
+
+
+class ProjectRenderer : public QThread
+{
+	Q_OBJECT
+public:
+	enum ExportFileFormats
+	{
+		WaveFile,
+		OggFile,
+		NumFileFormats
+	} ;
+
+	enum Depths
+	{
+		Depth_16Bit,
+		Depth_32Bit,
+		NumDepths
+	} ;
+
+	struct OutputSettings
+	{
+		sample_rate_t samplerate;
+		bool vbr;
+		int bitrate;
+		Depths depth;
+
+		OutputSettings( sample_rate_t _sr, bool _vbr, int _bitrate,
+								Depths _d ) :
+			samplerate( _sr ),
+			vbr( _vbr ),
+			bitrate( _bitrate ),
+			depth( _d )
+		{
+		}
+	} ;
+
+
+	ProjectRenderer( const Mixer::qualitySettings & _qs,
+				const OutputSettings & _os,
+				ExportFileFormats _file_format,
+				const QString & _out_file );
+	virtual ~ProjectRenderer();
+
+	bool isReady() const
+	{
+		return m_fileDev != NULL;
+	}
+
+	static ExportFileFormats getFileFormatFromExtension(
+							const QString & _ext );
+
+
+public slots:
+	void startProcessing();
+	void abortProcessing();
+
+	void updateConsoleProgress();
+
+
+signals:
+	void progressChanged( int );
+
+
+private:
+	virtual void run();
+
+	AudioFileDevice * m_fileDev;
+	Mixer::qualitySettings m_qualitySettings;
+	Mixer::qualitySettings m_oldQualitySettings;
+
+	volatile int m_progress;
+	volatile bool m_abort;
+
+} ;
+
+
+struct FileEncodeDevice
+{
+	ProjectRenderer::ExportFileFormats m_fileFormat;
+	const char * m_description;
+	const char * m_extension;
+	AudioFileDeviceInstantiaton m_getDevInst;
+} ;
+
+
+extern FileEncodeDevice __fileEncodeDevices[];
+
+#endif
diff --git a/lmms/include/RemotePlugin.h b/lmms/include/RemotePlugin.h
new file mode 100644
index 0000000..edf09ef
--- /dev/null
+++ b/lmms/include/RemotePlugin.h
@@ -0,0 +1,1222 @@
+/*
+ * RemotePlugin.h - base class providing RPC like mechanisms
+ *
+ * Copyright (c) 2008-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _REMOTE_PLUGIN_H
+#define _REMOTE_PLUGIN_H
+
+#include "export.h"
+#include "MidiEvent.h"
+#include "VstSyncData.h"
+
+#include <vector>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <string>
+#include <cassert>
+
+#ifdef LMMS_BUILD_WIN32
+#define USE_QT_SEMAPHORES
+#define USE_QT_SHMEM
+#endif
+
+#ifdef LMMS_BUILD_APPLE
+#define USE_QT_SEMAPHORES
+#endif
+
+
+#ifdef USE_QT_SEMAPHORES
+
+#ifdef LMMS_HAVE_PROCESS_H
+#include <process.h>
+#endif
+
+#include <Qt/qglobal.h>
+
+#if QT_VERSION >= 0x040400
+#include <QtCore/QSystemSemaphore>
+#else
+#error building LMMS on this platform requires at least Qt 4.4.0
+#endif
+
+#else /* USE_QT_SEMAPHORES */
+
+#ifdef LMMS_HAVE_SYS_IPC_H
+#include <sys/ipc.h>
+#endif
+
+#ifdef LMMS_HAVE_SEMAPHORE_H
+#include <semaphore.h>
+#endif
+
+#endif
+
+
+#ifdef USE_QT_SHMEM
+
+#include <Qt/qglobal.h>
+
+#if QT_VERSION >= 0x040400
+#include <QtCore/QSharedMemory>
+#else
+#error building LMMS on this platform requires at least Qt 4.4.0
+#endif
+
+typedef int32_t key_t;
+
+#else /* USE_QT_SHMEM */
+
+#ifdef LMMS_HAVE_SYS_SHM_H
+#include <sys/shm.h>
+#endif
+
+#ifdef LMMS_HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#endif
+
+
+
+#ifdef LMMS_HAVE_LOCALE_H
+#include <locale.h>
+#endif
+
+
+#ifdef BUILD_REMOTE_PLUGIN_CLIENT
+#undef EXPORT
+#define EXPORT
+#define COMPILE_REMOTE_PLUGIN_BASE
+#else
+#include <QtCore/QMutex>
+#include <QtCore/QProcess>
+#include <QtCore/QThread>
+#endif
+
+// sometimes we need to exchange bigger messages (e.g. for VST parameter dumps)
+// so set a usable value here
+const int SHM_FIFO_SIZE = 512*1024;
+
+
+// implements a FIFO inside a shared memory segment
+class shmFifo
+{
+	// need this union to handle different sizes of sem_t on 32 bit
+	// and 64 bit platforms
+	union sem32_t
+	{
+#ifndef USE_QT_SEMAPHORES
+		sem_t sem;
+#endif
+		int semKey;
+		char fill[32];
+	} ;
+	struct shmData
+	{
+		sem32_t dataSem;	// semaphore for locking this
+					// FIFO management data
+		sem32_t messageSem;	// semaphore for incoming messages
+		volatile int32_t startPtr; // current start of FIFO in memory
+		volatile int32_t endPtr;   // current end of FIFO in memory
+		char data[SHM_FIFO_SIZE];  // actual data
+	} ;
+
+public:
+	// constructor for master-side
+	shmFifo() :
+		m_invalid( false ),
+		m_master( true ),
+		m_shmKey( 0 ),
+#ifdef USE_QT_SHMEM
+		m_shmObj(),
+#else
+		m_shmID( -1 ),
+#endif
+		m_data( NULL ),
+#ifdef USE_QT_SEMAPHORES
+		m_dataSem( QString::null ),
+		m_messageSem( QString::null ),
+#else
+		m_dataSem( NULL ),
+		m_messageSem( NULL ),
+#endif
+		m_lockDepth( 0 )
+	{
+#ifdef USE_QT_SHMEM
+		do
+		{
+			m_shmObj.setKey( QString( "%1" ).arg( ++m_shmKey ) );
+			m_shmObj.create( sizeof( shmData ) );
+		} while( m_shmObj.error() != QSharedMemory::NoError );
+
+		m_data = (shmData *) m_shmObj.data();
+#else
+		while( ( m_shmID = shmget( ++m_shmKey, sizeof( shmData ),
+					IPC_CREAT | IPC_EXCL | 0600 ) ) == -1 )
+		{
+		}
+		m_data = (shmData *) shmat( m_shmID, 0, 0 );
+#endif
+		assert( m_data != NULL );
+		m_data->startPtr = m_data->endPtr = 0;
+#ifdef USE_QT_SEMAPHORES
+		static int k = 0;
+		m_data->dataSem.semKey = ( getpid()<<10 ) + ++k;
+		m_data->messageSem.semKey = ( getpid()<<10 ) + ++k;
+		m_dataSem.setKey( QString::number( m_data->dataSem.semKey ),
+						1, QSystemSemaphore::Create );
+		m_messageSem.setKey( QString::number(
+						m_data->messageSem.semKey ),
+						0, QSystemSemaphore::Create );
+#else
+		m_dataSem = &m_data->dataSem.sem;
+		m_messageSem = &m_data->messageSem.sem;
+
+		if( sem_init( m_dataSem, 1, 1 ) )
+		{
+			fprintf( stderr, "could not initialize m_dataSem\n" );
+		}
+		if( sem_init( m_messageSem, 1, 0 ) )
+		{
+			fprintf( stderr, "could not initialize "
+							"m_messageSem\n" );
+		}
+#endif
+	}
+
+	// constructor for remote-/client-side - use _shm_key for making up
+	// the connection to master
+	shmFifo( key_t _shm_key ) :
+		m_invalid( false ),
+		m_master( false ),
+		m_shmKey( 0 ),
+#ifdef USE_QT_SHMEM
+		m_shmObj( QString::number( _shm_key ) ),
+#else
+		m_shmID( shmget( _shm_key, 0, 0 ) ),
+#endif
+		m_data( NULL ),
+#ifdef USE_QT_SEMAPHORES
+		m_dataSem( QString::null ),
+		m_messageSem( QString::null ),
+#else
+		m_dataSem( NULL ),
+		m_messageSem( NULL ),
+#endif
+		m_lockDepth( 0 )
+	{
+#ifdef USE_QT_SHMEM
+		if( m_shmObj.attach() )
+		{
+			m_data = (shmData *) m_shmObj.data();
+		}
+#else
+		if( m_shmID != -1 )
+		{
+			m_data = (shmData *) shmat( m_shmID, 0, 0 );
+		}
+#endif
+		assert( m_data != NULL );
+#ifdef USE_QT_SEMAPHORES
+		m_dataSem.setKey( QString::number( m_data->dataSem.semKey ) );
+		m_messageSem.setKey( QString::number(
+						m_data->messageSem.semKey ) );
+#else
+		m_dataSem = &m_data->dataSem.sem;
+		m_messageSem = &m_data->messageSem.sem;
+#endif
+	}
+
+	~shmFifo()
+	{
+#ifndef USE_QT_SHMEM
+		shmdt( m_data );
+#endif
+		// master?
+		if( m_master )
+		{
+#ifndef USE_QT_SHMEM
+			shmctl( m_shmID, IPC_RMID, NULL );
+#endif
+#ifndef USE_QT_SEMAPHORES
+			sem_destroy( m_dataSem );
+			sem_destroy( m_messageSem );
+#endif
+		}
+	}
+
+	inline bool isInvalid() const
+	{
+		return m_invalid;
+	}
+
+	void invalidate()
+	{
+		m_invalid = true;
+	}
+
+	// do we act as master (i.e. not as remote-process?)
+	inline bool isMaster() const
+	{
+		return m_master;
+	}
+
+	// recursive lock
+	inline void lock()
+	{
+		if( !isInvalid() && __sync_add_and_fetch( &m_lockDepth, 1 ) == 1 )
+		{
+#ifdef USE_QT_SEMAPHORES
+			m_dataSem.acquire();
+#else
+			sem_wait( m_dataSem );
+#endif
+		}
+	}
+
+	// recursive unlock
+	inline void unlock()
+	{
+		if( __sync_sub_and_fetch( &m_lockDepth, 1) <= 0 )
+		{
+#ifdef USE_QT_SEMAPHORES
+			m_dataSem.release();
+#else
+			sem_post( m_dataSem );
+#endif
+		}
+	}
+
+	// wait until message-semaphore is available
+	inline void waitForMessage()
+	{
+		if( !isInvalid() )
+		{
+#ifdef USE_QT_SEMAPHORES
+			m_messageSem.acquire();
+#else
+			sem_wait( m_messageSem );
+#endif
+		}
+	}
+
+	// increase message-semaphore
+	inline void messageSent()
+	{
+#ifdef USE_QT_SEMAPHORES
+		m_messageSem.release();
+#else
+		sem_post( m_messageSem );
+#endif
+	}
+
+
+	inline int32_t readInt()
+	{
+		int32_t i;
+		read( &i, sizeof( i ) );
+		return i;
+	}
+
+	inline void writeInt( const int32_t & _i )
+	{
+		write( &_i, sizeof( _i ) );
+	}
+
+	inline std::string readString()
+	{
+		const int len = readInt();
+		if( len )
+		{
+			char * sc = new char[len + 1];
+			read( sc, len );
+			sc[len] = 0;
+			std::string s( sc );
+			delete[] sc;
+			return s;
+		}
+		return std::string();
+	}
+
+
+	inline void writeString( const std::string & _s )
+	{
+		const int len = _s.size();
+		writeInt( len );
+		write( _s.c_str(), len );
+	}
+
+
+	inline bool messagesLeft()
+	{
+		if( isInvalid() )
+		{
+			return false;
+		}
+#ifdef USE_QT_SEMAPHORES
+		lock();
+		const bool empty = ( m_data->startPtr == m_data->endPtr );
+		unlock();
+		return !empty;
+#else
+		int v;
+		sem_getvalue( m_messageSem, &v );
+		return v > 0;
+#endif
+	}
+
+
+	inline int shmKey() const
+	{
+		return m_shmKey;
+	}
+
+
+private:
+	static inline void fastMemCpy( void * _dest, const void * _src,
+							const int _len )
+	{
+		// calling memcpy() for just an integer is obsolete overhead
+		if( _len == 4 )
+		{
+			*( (int32_t *) _dest ) = *( (int32_t *) _src );
+		}
+		else
+		{
+			memcpy( _dest, _src, _len );
+		}
+	}
+
+	void read( void * _buf, int _len )
+	{
+		if( isInvalid() )
+		{
+			memset( _buf, 0, _len );
+			return;
+		}
+		lock();
+		while( isInvalid() == false &&
+				_len > m_data->endPtr - m_data->startPtr )
+		{
+			unlock();
+#ifndef LMMS_BUILD_WIN32
+			usleep( 5 );
+#endif
+			lock();
+		}
+		fastMemCpy( _buf, m_data->data + m_data->startPtr, _len );
+		m_data->startPtr += _len;
+		// nothing left?
+		if( m_data->startPtr == m_data->endPtr )
+		{
+			// then reset to 0
+			m_data->startPtr = m_data->endPtr = 0;
+		}
+		unlock();
+	}
+
+	void write( const void * _buf, int _len )
+	{
+		if( isInvalid() || _len > SHM_FIFO_SIZE )
+		{
+			return;
+		}
+		lock();
+		while( _len > SHM_FIFO_SIZE - m_data->endPtr )
+		{
+			// if no space is left, try to move data to front
+			if( m_data->startPtr > 0 )
+			{
+				memmove( m_data->data,
+					m_data->data + m_data->startPtr,
+					m_data->endPtr - m_data->startPtr );
+				m_data->endPtr = m_data->endPtr -
+							m_data->startPtr;
+				m_data->startPtr = 0;
+			}
+			unlock();
+#ifndef LMMS_BUILD_WIN32
+			usleep( 5 );
+#endif
+			lock();
+		}
+		fastMemCpy( m_data->data + m_data->endPtr, _buf, _len );
+		m_data->endPtr += _len;
+		unlock();
+	}
+
+	volatile bool m_invalid;
+	bool m_master;
+	key_t m_shmKey;
+#ifdef USE_QT_SHMEM
+	QSharedMemory m_shmObj;
+#else
+	int m_shmID;
+#endif
+	shmData * m_data;
+#ifdef USE_QT_SEMAPHORES
+	QSystemSemaphore m_dataSem;
+	QSystemSemaphore m_messageSem;
+#else
+	sem_t * m_dataSem;
+	sem_t * m_messageSem;
+#endif
+	volatile int m_lockDepth;
+
+} ;
+
+
+
+enum RemoteMessageIDs
+{
+	IdUndefined,
+	IdInitDone,
+	IdQuit,
+	IdSampleRateInformation,
+	IdBufferSizeInformation,
+	IdMidiEvent,
+	IdStartProcessing,
+	IdProcessingDone,
+	IdChangeSharedMemoryKey,
+	IdChangeInputCount,
+	IdChangeOutputCount,
+	IdShowUI,
+	IdHideUI,
+	IdSaveSettingsToString,
+	IdSaveSettingsToFile,
+	IdLoadSettingsFromString,
+	IdLoadSettingsFromFile,
+	IdSavePresetFile,
+	IdLoadPresetFile,
+	IdDebugMessage,
+	IdUserBase = 64
+} ;
+
+
+
+class EXPORT RemotePluginBase
+{
+public:
+	struct message
+	{
+		message() :
+			id( IdUndefined ),
+			data()
+		{
+		}
+
+		message( const message & _m ) :
+			id( _m.id ),
+			data( _m.data )
+		{
+		}
+
+		message( int _id ) :
+			id( _id ),
+			data()
+		{
+		}
+
+		inline message & addString( const std::string & _s )
+		{
+			data.push_back( _s );
+			return *this;
+		}
+
+		message & addInt( int _i )
+		{
+			char buf[32];
+			sprintf( buf, "%d", _i );
+			data.push_back( std::string( buf ) );
+			return *this;
+		}
+
+		message & addFloat( float _f )
+		{
+			char buf[32];
+			sprintf( buf, "%f", _f );
+			data.push_back( std::string( buf ) );
+			return *this;
+		}
+
+		inline std::string getString( int _p = 0 ) const
+		{
+			return data[_p];
+		}
+
+#ifndef BUILD_REMOTE_PLUGIN_CLIENT
+		inline QString getQString( int _p = 0 ) const
+		{
+			return QString::fromStdString( getString( _p ) );
+		}
+#endif
+
+		inline int getInt( int _p = 0 ) const
+		{
+			return atoi( data[_p].c_str() );
+		}
+
+		inline float getFloat( int _p ) const
+		{
+			return (float) atof( data[_p].c_str() );
+		}
+
+		inline bool operator==( const message & _m ) const
+		{
+			return( id == _m.id );
+		}
+
+		int id;
+
+	private:
+		std::vector<std::string> data;
+
+		friend class RemotePluginBase;
+
+	} ;
+
+	RemotePluginBase( shmFifo * _in, shmFifo * _out );
+	virtual ~RemotePluginBase();
+
+	void reset( shmFifo *in, shmFifo *out )
+	{
+		delete m_in;
+		delete m_out;
+		m_in = in;
+		m_out = out;
+	}
+
+	int sendMessage( const message & _m );
+	message receiveMessage();
+
+	inline bool isInvalid() const
+	{
+		return m_in->isInvalid() || m_out->isInvalid();
+	}
+
+	inline bool messagesLeft()
+	{
+		return m_in->messagesLeft();
+	}
+
+
+	message waitForMessage( const message & _m,
+						bool _busy_waiting = false );
+
+	inline message fetchAndProcessNextMessage()
+	{
+		message m = receiveMessage();
+		processMessage( m );
+		return m;
+	}
+
+	inline void fetchAndProcessAllMessages()
+	{
+		while( messagesLeft() )
+		{
+			fetchAndProcessNextMessage();
+		}
+	}
+
+	virtual bool processMessage( const message & _m ) = 0;
+
+
+protected:
+	inline const shmFifo * in() const
+	{
+		return m_in;
+	}
+
+	inline const shmFifo * out() const
+	{
+		return m_out;
+	}
+
+	inline void invalidate()
+	{
+		m_in->invalidate();
+		m_out->invalidate();
+		m_in->messageSent();
+	}
+
+
+private:
+	shmFifo * m_in;
+	shmFifo * m_out;
+
+} ;
+
+
+
+#ifndef BUILD_REMOTE_PLUGIN_CLIENT
+
+
+class RemotePlugin;
+
+class ProcessWatcher : public QThread
+{
+public:
+	ProcessWatcher( RemotePlugin * );
+	virtual ~ProcessWatcher()
+	{
+	}
+
+
+	void quit()
+	{
+		m_quit = true;
+	}
+
+private:
+	virtual void run();
+
+	RemotePlugin * m_plugin;
+	volatile bool m_quit;
+
+} ;
+
+
+class EXPORT RemotePlugin : public RemotePluginBase
+{
+public:
+	RemotePlugin();
+	virtual ~RemotePlugin();
+
+	inline bool isRunning()
+	{
+#ifdef DEBUG_REMOTE_PLUGIN
+		return true;
+#else
+		return m_process.state() != QProcess::NotRunning;
+#endif
+	}
+
+	bool init( const QString &pluginExecutable, bool waitForInitDoneMsg );
+
+	inline void waitForInitDone( bool _busyWaiting = true )
+	{
+		m_failed = waitForMessage( IdInitDone, _busyWaiting ).id != IdInitDone;
+	}
+
+	virtual bool processMessage( const message & _m );
+
+	bool process( const sampleFrame * _in_buf, sampleFrame * _out_buf );
+
+	void processMidiEvent( const MidiEvent&, const f_cnt_t _offset );
+
+	void updateSampleRate( sample_rate_t _sr )
+	{
+		lock();
+		sendMessage( message( IdSampleRateInformation ).addInt( _sr ) );
+		unlock();
+	}
+
+	void showUI()
+	{
+		lock();
+		sendMessage( IdShowUI );
+		unlock();
+	}
+
+	void hideUI()
+	{
+		lock();
+		sendMessage( IdHideUI );
+		unlock();
+	}
+
+	inline bool failed() const
+	{
+		return m_failed;
+	}
+
+	inline void lock()
+	{
+		if( !isInvalid() )
+		{
+			m_commMutex.lock();
+		}
+	}
+
+	inline void unlock()
+	{
+		if( !isInvalid() )
+		{
+			m_commMutex.unlock();
+		}
+	}
+
+
+protected:
+	inline void setSplittedChannels( bool _on )
+	{
+		m_splitChannels = _on;
+	}
+
+
+private:
+	void resizeSharedProcessingMemory();
+
+
+	bool m_failed;
+
+	QProcess m_process;
+	ProcessWatcher m_watcher;
+
+	QMutex m_commMutex;
+	bool m_splitChannels;
+#ifdef USE_QT_SHMEM
+	QSharedMemory m_shmObj;
+#else
+	int m_shmID;
+#endif
+	size_t m_shmSize;
+	float * m_shm;
+
+	int m_inputCount;
+	int m_outputCount;
+
+	friend class ProcessWatcher;
+} ;
+
+#endif
+
+
+#ifdef BUILD_REMOTE_PLUGIN_CLIENT
+
+class RemotePluginClient : public RemotePluginBase
+{
+public:
+	RemotePluginClient( key_t _shm_in, key_t _shm_out );
+	virtual ~RemotePluginClient();
+#ifdef USE_QT_SHMEM
+	VstSyncData * getQtVSTshm();
+#endif
+	virtual bool processMessage( const message & _m );
+
+	virtual void process( const sampleFrame * _in_buf,
+					sampleFrame * _out_buf ) = 0;
+
+	virtual void processMidiEvent( const MidiEvent&, const f_cnt_t /* _offset */ )
+	{
+	}
+
+	inline float * sharedMemory()
+	{
+		return m_shm;
+	}
+
+	virtual void updateSampleRate()
+	{
+	}
+
+	virtual void updateBufferSize()
+	{
+	}
+
+	inline sample_rate_t sampleRate() const
+	{
+		return m_sampleRate;
+	}
+
+	inline fpp_t bufferSize() const
+	{
+		return m_bufferSize;
+	}
+
+	void setInputCount( int _i )
+	{
+		m_inputCount = _i;
+		sendMessage( message( IdChangeInputCount ).addInt( _i ) );
+	}
+
+	void setOutputCount( int _i )
+	{
+		m_outputCount = _i;
+		sendMessage( message( IdChangeOutputCount ).addInt( _i ) );
+	}
+
+	virtual int inputCount() const
+	{
+		return m_inputCount;
+	}
+
+	virtual int outputCount() const
+	{
+		return m_outputCount;
+	}
+
+	void debugMessage( const std::string & _s )
+	{
+		sendMessage( message( IdDebugMessage ).addString( _s ) );
+	}
+
+
+private:
+	void setShmKey( key_t _key, int _size );
+	void doProcessing();
+
+#ifdef USE_QT_SHMEM
+	QSharedMemory m_shmObj;
+	QSharedMemory m_shmQtID;
+#endif
+	VstSyncData * m_vstSyncData;
+	float * m_shm;
+
+	int m_inputCount;
+	int m_outputCount;
+
+	sample_rate_t m_sampleRate;
+	fpp_t m_bufferSize;
+
+} ;
+
+#endif
+
+
+
+
+
+#ifdef COMPILE_REMOTE_PLUGIN_BASE
+
+#ifndef BUILD_REMOTE_PLUGIN_CLIENT
+#include <QtCore/QCoreApplication>
+#endif
+
+
+RemotePluginBase::RemotePluginBase( shmFifo * _in, shmFifo * _out ) :
+	m_in( _in ),
+	m_out( _out )
+{
+#ifdef LMMS_HAVE_LOCALE_H
+	// make sure, we're using common ways to print/scan
+	// floats to/from strings (',' vs. '.' for decimal point etc.)
+	setlocale( LC_NUMERIC, "C" );
+#endif
+}
+
+
+
+
+RemotePluginBase::~RemotePluginBase()
+{
+	delete m_in;
+	delete m_out;
+}
+
+
+
+
+int RemotePluginBase::sendMessage( const message & _m )
+{
+	m_out->lock();
+	m_out->writeInt( _m.id );
+	m_out->writeInt( _m.data.size() );
+	int j = 8;
+	for( unsigned int i = 0; i < _m.data.size(); ++i )
+	{
+		m_out->writeString( _m.data[i] );
+		j += 4 + _m.data[i].size();
+	}
+	m_out->unlock();
+	m_out->messageSent();
+
+	return j;
+}
+
+
+
+
+RemotePluginBase::message RemotePluginBase::receiveMessage()
+{
+	m_in->waitForMessage();
+	m_in->lock();
+	message m;
+	m.id = m_in->readInt();
+	const int s = m_in->readInt();
+	for( int i = 0; i < s; ++i )
+	{
+		m.data.push_back( m_in->readString() );
+	}
+	m_in->unlock();
+	return m;
+}
+
+
+
+
+RemotePluginBase::message RemotePluginBase::waitForMessage(
+							const message & _wm,
+							bool _busy_waiting )
+{
+	while( !isInvalid() )
+	{
+#ifndef BUILD_REMOTE_PLUGIN_CLIENT
+		if( _busy_waiting && !messagesLeft() )
+		{
+			QCoreApplication::processEvents(
+				QEventLoop::ExcludeUserInputEvents, 50 );
+			continue;
+		}
+#endif
+		message m = receiveMessage();
+		processMessage( m );
+		if( m.id == _wm.id )
+		{
+			return m;
+		}
+		else if( m.id == IdUndefined )
+		{
+			return m;
+		}
+	}
+
+	return message();
+}
+
+
+#endif
+
+
+
+
+
+#ifdef BUILD_REMOTE_PLUGIN_CLIENT
+
+
+RemotePluginClient::RemotePluginClient( key_t _shm_in, key_t _shm_out ) :
+	RemotePluginBase( new shmFifo( _shm_in ), new shmFifo( _shm_out ) ),
+#ifdef USE_QT_SHMEM
+	m_shmObj(),
+	m_shmQtID( "/usr/bin/lmms" ),
+#endif
+	m_vstSyncData( NULL ),
+	m_shm( NULL ),
+	m_inputCount( 0 ),
+	m_outputCount( 0 ),
+	m_sampleRate( 44100 ),
+	m_bufferSize( 0 )
+{
+#ifdef USE_QT_SHMEM
+	if( m_shmQtID.attach( QSharedMemory::ReadOnly ) )
+	{
+		m_vstSyncData = (VstSyncData *) m_shmQtID.data();
+		m_bufferSize = m_vstSyncData->m_bufferSize;
+		m_sampleRate = m_vstSyncData->m_sampleRate;
+		return;
+	}
+#else
+	key_t key;
+	int m_shmID;
+
+	if( ( key = ftok( VST_SNC_SHM_KEY_FILE, 'R' ) ) == -1 )
+	{
+		perror( "RemotePluginClient::ftok" );
+	}
+	else
+	{	// connect to shared memory segment
+		if( ( m_shmID = shmget( key, 0, 0 ) ) == -1 )
+		{
+			perror( "RemotePluginClient::shmget" );
+		}
+		else
+		{	// attach segment
+			m_vstSyncData = (VstSyncData *)shmat(m_shmID, 0, 0);
+			if( m_vstSyncData == (VstSyncData *)( -1 ) )
+			{
+				perror( "RemotePluginClient::shmat" );
+			}
+			else
+			{
+				m_bufferSize = m_vstSyncData->m_bufferSize;
+				m_sampleRate = m_vstSyncData->m_sampleRate;
+
+				// detach segment
+				if( shmdt(m_vstSyncData) == -1 )
+				{
+					perror("RemotePluginClient::shmdt");
+				}
+				return;
+			}
+		}
+	}
+#endif
+	// if attaching shared memory fails
+	sendMessage( IdSampleRateInformation );
+	sendMessage( IdBufferSizeInformation );
+}
+
+
+
+
+RemotePluginClient::~RemotePluginClient()
+{
+#ifdef USE_QT_SHMEM
+	m_shmQtID.detach();
+#endif
+	sendMessage( IdQuit );
+
+#ifndef USE_QT_SHMEM
+	shmdt( m_shm );
+#endif
+}
+
+
+
+#ifdef USE_QT_SHMEM
+VstSyncData * RemotePluginClient::getQtVSTshm()
+{
+	return m_vstSyncData;
+}
+#endif
+
+
+
+bool RemotePluginClient::processMessage( const message & _m )
+{
+	message reply_message( _m.id );
+	bool reply = false;
+	switch( _m.id )
+	{
+		case IdUndefined:
+			return false;
+
+		case IdSampleRateInformation:
+			m_sampleRate = _m.getInt();
+			updateSampleRate();
+			break;
+
+		case IdBufferSizeInformation:
+			m_bufferSize = _m.getInt();
+			updateBufferSize();
+			break;
+
+		case IdQuit:
+			return false;
+
+		case IdMidiEvent:
+			processMidiEvent(
+				MidiEvent( static_cast<MidiEventTypes>(
+							_m.getInt( 0 ) ),
+						_m.getInt( 1 ),
+						_m.getInt( 2 ),
+						_m.getInt( 3 ) ),
+							_m.getInt( 4 ) );
+			break;
+
+		case IdStartProcessing:
+			doProcessing();
+			reply_message.id = IdProcessingDone;
+			reply = true;
+			break;
+
+		case IdChangeSharedMemoryKey:
+			setShmKey( _m.getInt( 0 ), _m.getInt( 1 ) );
+			break;
+
+		case IdInitDone:
+			break;
+
+		default:
+		{
+			char buf[64];
+			sprintf( buf, "undefined message: %d\n", (int) _m.id );
+			debugMessage( buf );
+			break;
+		}
+	}
+	if( reply )
+	{
+		sendMessage( reply_message );
+	}
+
+	return true;
+}
+
+
+
+
+void RemotePluginClient::setShmKey( key_t _key, int _size )
+{
+#ifdef USE_QT_SHMEM
+	m_shmObj.setKey( QString::number( _key ) );
+	if( m_shmObj.attach() || m_shmObj.error() == QSharedMemory::NoError )
+	{
+		m_shm = (float *) m_shmObj.data();
+	}
+	else
+	{
+		char buf[64];
+		sprintf( buf, "failed getting shared memory: %d\n", m_shmObj.error() );
+		debugMessage( buf );
+	}
+#else
+	if( m_shm != NULL )
+	{
+		shmdt( m_shm );
+		m_shm = NULL;
+	}
+
+	// only called for detaching SHM?
+	if( _key == 0 )
+	{
+		return;
+	}
+
+	int shm_id = shmget( _key, _size, 0 );
+	if( shm_id == -1 )
+	{
+		debugMessage( "failed getting shared memory\n" );
+	}
+	else
+	{
+		m_shm = (float *) shmat( shm_id, 0, 0 );
+	}
+#endif
+}
+
+
+
+
+void RemotePluginClient::doProcessing()
+{
+	if( m_shm != NULL )
+	{
+		process( (sampleFrame *)( m_inputCount > 0 ? m_shm : NULL ),
+				(sampleFrame *)( m_shm +
+					( m_inputCount*m_bufferSize ) ) );
+	}
+	else
+	{
+		debugMessage( "doProcessing(): have no shared memory!\n" );
+	}
+}
+
+
+
+#endif
+
+#define QSTR_TO_STDSTR(s)	std::string( s.toUtf8().constData() )
+
+#endif
diff --git a/lmms/include/SampleBuffer.h b/lmms/include/SampleBuffer.h
new file mode 100644
index 0000000..54c444f
--- /dev/null
+++ b/lmms/include/SampleBuffer.h
@@ -0,0 +1,277 @@
+/*
+ * SampleBuffer.h - container-class SampleBuffer
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _SAMPLE_BUFFER_H
+#define _SAMPLE_BUFFER_H
+
+#include <QtCore/QMutex>
+#include <QtCore/QObject>
+#include <QtCore/QRect>
+
+#include <samplerate.h>
+
+#include "export.h"
+#include "interpolation.h"
+#include "lmms_basics.h"
+#include "lmms_math.h"
+#include "shared_object.h"
+
+
+class QPainter;
+
+
+class EXPORT SampleBuffer : public QObject, public sharedObject
+{
+	Q_OBJECT
+public:
+	class EXPORT handleState
+	{
+	public:
+		handleState( bool _varying_pitch = false );
+		virtual ~handleState();
+
+		inline const f_cnt_t frameIndex() const
+		{
+			return m_frameIndex;
+		}
+
+		inline void setFrameIndex( f_cnt_t _index )
+		{
+			m_frameIndex = _index;
+		}
+
+
+
+	private:
+		f_cnt_t m_frameIndex;
+		const bool m_varyingPitch;
+		SRC_STATE * m_resamplingData;
+
+		friend class SampleBuffer;
+
+	} ;
+
+
+	// constructor which either loads sample _audio_file or decodes
+	// base64-data out of string
+	SampleBuffer( const QString & _audio_file = QString(),
+						bool _is_base64_data = false );
+	SampleBuffer( const sampleFrame * _data, const f_cnt_t _frames );
+	SampleBuffer( const f_cnt_t _frames );
+
+	virtual ~SampleBuffer();
+
+	bool play( sampleFrame * _ab, handleState * _state,
+				const fpp_t _frames,
+				const float _freq,
+				const bool _looped = false );
+
+	void visualize( QPainter & _p, const QRect & _dr, const QRect & _clip, f_cnt_t _from_frame = 0, f_cnt_t _to_frame = 0 );
+	inline void visualize( QPainter & _p, const QRect & _dr, f_cnt_t _from_frame = 0, f_cnt_t _to_frame = 0 )
+	{
+		visualize( _p, _dr, _dr, _from_frame, _to_frame );
+	}
+
+	inline const QString & audioFile() const
+	{
+		return m_audioFile;
+	}
+
+	inline f_cnt_t startFrame() const
+	{
+		return m_startFrame;
+	}
+
+	inline f_cnt_t endFrame() const
+	{
+		return m_endFrame;
+	}
+
+	void setLoopStartFrame( f_cnt_t _start )
+	{
+		m_varLock.lock();
+		m_loopStartFrame = _start;
+		m_varLock.unlock();
+	}
+
+	void setLoopEndFrame( f_cnt_t _end )
+	{
+		m_varLock.lock();
+		m_loopEndFrame = _end;
+		m_varLock.unlock();
+	}
+
+	inline f_cnt_t frames() const
+	{
+		return m_frames;
+	}
+
+	inline float amplification() const
+	{
+		return m_amplification;
+	}
+
+	inline bool reversed() const
+	{
+		return m_reversed;
+	}
+
+	inline float frequency() const
+	{
+		return m_frequency;
+	}
+
+	sample_rate_t sampleRate() const
+	{
+		return m_sampleRate;
+	}
+
+	int sampleLength() const
+	{
+		return double( m_endFrame - m_startFrame ) / m_sampleRate * 1000;
+	}
+
+	inline void setFrequency( float _freq )
+	{
+		m_varLock.lock();
+		m_frequency = _freq;
+		m_varLock.unlock();
+	}
+
+	inline void setSampleRate( sample_rate_t _rate )
+	{
+		m_varLock.lock();
+		m_sampleRate = _rate;
+		m_varLock.unlock();
+	}
+
+	inline const sampleFrame * data() const
+	{
+		return m_data;
+	}
+
+    QString openAudioFile() const;
+    QString openAndSetAudioFile();
+	QString openAndSetWaveformFile();
+	
+	QString & toBase64( QString & _dst ) const;
+
+
+	static SampleBuffer * resample( sampleFrame * _data,
+						const f_cnt_t _frames,
+						const sample_rate_t _src_sr,
+						const sample_rate_t _dst_sr );
+
+	static inline SampleBuffer * resample( SampleBuffer * _buf,
+						const sample_rate_t _src_sr,
+						const sample_rate_t _dst_sr )
+	{
+		return resample( _buf->m_data, _buf->m_frames, _src_sr,
+								_dst_sr );
+	}
+
+	void normalizeSampleRate( const sample_rate_t _src_sr,
+						bool _keep_settings = false );
+
+	inline sample_t userWaveSample( const float _sample ) const
+	{
+		// Precise implementation
+//		const float frame = fraction( _sample ) * m_frames;
+//		const f_cnt_t f1 = static_cast<f_cnt_t>( frame );
+//		const f_cnt_t f2 = ( f1 + 1 ) % m_frames;
+//		sample_t waveSample = linearInterpolate( m_data[f1][0],
+//						m_data[f2][0],
+//						fraction( frame ) );
+//		return waveSample;
+
+		// Fast implementation
+		const float frame = _sample * m_frames;
+		f_cnt_t f1 = static_cast<f_cnt_t>( frame ) % m_frames;
+		if( f1 < 0 )
+		{
+			f1 += m_frames;
+		}
+		return m_data[f1][0];
+	}
+
+	static QString tryToMakeRelative( const QString & _file );
+	static QString tryToMakeAbsolute( const QString & _file );
+
+
+public slots:
+	void setAudioFile( const QString & _audio_file );
+	void loadFromBase64( const QString & _data );
+	void setStartFrame( const f_cnt_t _s );
+	void setEndFrame( const f_cnt_t _e );
+	void setAmplification( float _a );
+	void setReversed( bool _on );
+
+
+private:
+	void update( bool _keep_settings = false );
+
+    void convertIntToFloat ( int_sample_t * & _ibuf, f_cnt_t _frames, int _channels);
+    void directFloatWrite ( sample_t * & _fbuf, f_cnt_t _frames, int _channels);
+
+	f_cnt_t decodeSampleSF( const char * _f, int_sample_t * & _buf,
+						ch_cnt_t & _channels,
+						sample_rate_t & _sample_rate );
+#ifdef LMMS_HAVE_OGGVORBIS
+	f_cnt_t decodeSampleOGGVorbis( const char * _f, int_sample_t * & _buf,
+						ch_cnt_t & _channels,
+						sample_rate_t & _sample_rate );
+#endif
+	f_cnt_t decodeSampleDS( const char * _f, int_sample_t * & _buf,
+						ch_cnt_t & _channels,
+						sample_rate_t & _sample_rate );
+
+	QString m_audioFile;
+	sampleFrame * m_origData;
+	f_cnt_t m_origFrames;
+	sampleFrame * m_data;
+	QMutex m_varLock;
+	f_cnt_t m_frames;
+	f_cnt_t m_startFrame;
+	f_cnt_t m_endFrame;
+	f_cnt_t m_loopStartFrame;
+	f_cnt_t m_loopEndFrame;
+	float m_amplification;
+	bool m_reversed;
+	float m_frequency;
+	sample_rate_t m_sampleRate;
+
+	sampleFrame * getSampleFragment( f_cnt_t _start, f_cnt_t _frames,
+						bool _looped,
+						sampleFrame * * _tmp ) const;
+	f_cnt_t getLoopedIndex( f_cnt_t _index ) const;
+
+
+signals:
+	void sampleUpdated();
+
+} ;
+
+
+#endif
diff --git a/lmms/include/SamplePlayHandle.h b/lmms/include/SamplePlayHandle.h
new file mode 100644
index 0000000..a2ceae7
--- /dev/null
+++ b/lmms/include/SamplePlayHandle.h
@@ -0,0 +1,97 @@
+/*
+ * SamplePlayHandle.h - play-handle for playing a sample
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _SAMPLE_PLAY_HANDLE_H
+#define _SAMPLE_PLAY_HANDLE_H
+
+#include "Mixer.h"
+#include "SampleBuffer.h"
+#include "AutomatableModel.h"
+
+class bbTrack;
+class SampleTCO;
+class track;
+class AudioPort;
+
+
+class SamplePlayHandle : public PlayHandle
+{
+public:
+	SamplePlayHandle( const QString& sampleFile );
+	SamplePlayHandle( SampleBuffer* sampleBuffer );
+	SamplePlayHandle( SampleTCO* tco );
+	virtual ~SamplePlayHandle();
+
+	virtual inline bool affinityMatters() const
+	{
+		return true;
+	}
+
+
+	virtual void play( sampleFrame * _working_buffer );
+	virtual bool isFinished() const;
+
+	virtual bool isFromTrack( const track * _track ) const;
+
+	f_cnt_t totalFrames() const;
+	inline f_cnt_t framesDone() const
+	{
+		return( m_frame );
+	}
+	void setDoneMayReturnTrue( bool _enable )
+	{
+		m_doneMayReturnTrue = _enable;
+	}
+
+	void setBBTrack( bbTrack * _bb_track )
+	{
+		m_bbTrack = _bb_track;
+	}
+
+	void setVolumeModel( FloatModel * _model )
+	{
+		m_volumeModel = _model;
+	}
+
+
+private:
+	SampleBuffer * m_sampleBuffer;
+	bool m_doneMayReturnTrue;
+
+	f_cnt_t m_frame;
+	SampleBuffer::handleState m_state;
+
+	AudioPort * m_audioPort;
+	const bool m_ownAudioPort;
+
+	FloatModel m_defaultVolumeModel;
+	FloatModel * m_volumeModel;
+	track * m_track;
+
+	bbTrack * m_bbTrack;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/SampleRecordHandle.h b/lmms/include/SampleRecordHandle.h
new file mode 100644
index 0000000..9e50699
--- /dev/null
+++ b/lmms/include/SampleRecordHandle.h
@@ -0,0 +1,72 @@
+/*
+ * SampleRecordHandle.h - play-handle for recording a sample
+ *
+ * Copyright (c) 2008 Csaba Hruska <csaba.hruska/at/gmail.com>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _SAMPLE_RECORD_HANDLE_H
+#define _SAMPLE_RECORD_HANDLE_H
+
+#include <QtCore/QList>
+#include <QtCore/QPair>
+
+#include "Mixer.h"
+#include "SampleBuffer.h"
+
+class bbTrack;
+class pattern;
+class SampleTCO;
+class track;
+
+
+class SampleRecordHandle : public PlayHandle
+{
+public:
+	SampleRecordHandle( SampleTCO* tco );
+	virtual ~SampleRecordHandle();
+
+	virtual void play( sampleFrame * _working_buffer );
+	virtual bool isFinished() const;
+
+	virtual bool isFromTrack( const track * _track ) const;
+
+	f_cnt_t framesRecorded() const;
+	void createSampleBuffer( SampleBuffer * * _sample_buf );
+
+
+private:
+	virtual void writeBuffer( const sampleFrame * _ab,
+						const f_cnt_t _frames );
+
+	typedef QList<QPair<sampleFrame *, f_cnt_t> > bufferList;
+	bufferList m_buffers;
+	f_cnt_t m_framesRecorded;
+	MidiTime m_minLength;
+
+	track * m_track;
+	bbTrack * m_bbTrack;
+	SampleTCO * m_tco;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/SampleTrack.h b/lmms/include/SampleTrack.h
new file mode 100644
index 0000000..2afd928
--- /dev/null
+++ b/lmms/include/SampleTrack.h
@@ -0,0 +1,184 @@
+/*
+ * SampleTrack.h - class SampleTrack, a track which provides arrangement of samples
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef SAMPLE_TRACK_H
+#define SAMPLE_TRACK_H
+
+#include <QtGui/QDialog>
+
+#include "AudioPort.h"
+#include "track.h"
+
+class EffectRackView;
+class knob;
+class SampleBuffer;
+
+
+class SampleTCO : public trackContentObject
+{
+	Q_OBJECT
+	mapPropertyFromModel(bool,isRecord,setRecord,m_recordModel);
+public:
+	SampleTCO( track * _track );
+	virtual ~SampleTCO();
+
+	virtual void changeLength( const MidiTime & _length );
+	const QString & sampleFile() const;
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+	inline virtual QString nodeName() const
+	{
+		return "sampletco";
+	}
+
+	SampleBuffer* sampleBuffer()
+	{
+		return m_sampleBuffer;
+	}
+
+	MidiTime sampleLength() const;
+
+	virtual trackContentObjectView * createView( trackView * _tv );
+
+
+public slots:
+	void setSampleBuffer( SampleBuffer* sb );
+	void setSampleFile( const QString & _sf );
+	void updateLength( bpm_t = 0 );
+	void toggleRecord();
+
+
+private:
+	SampleBuffer* m_sampleBuffer;
+	BoolModel m_recordModel;
+
+
+	friend class SampleTCOView;
+
+
+signals:
+	void sampleChanged();
+
+} ;
+
+
+
+class SampleTCOView : public trackContentObjectView
+{
+	Q_OBJECT
+public:
+	SampleTCOView( SampleTCO * _tco, trackView * _tv );
+	virtual ~SampleTCOView();
+
+
+public slots:
+	void updateSample();
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _cme );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+	virtual void mouseDoubleClickEvent( QMouseEvent * );
+	virtual void paintEvent( QPaintEvent * );
+
+
+private:
+	SampleTCO * m_tco;
+
+} ;
+
+
+
+
+class SampleTrack : public track
+{
+	Q_OBJECT
+public:
+	SampleTrack( TrackContainer* tc );
+	virtual ~SampleTrack();
+
+	virtual bool play( const MidiTime & _start, const fpp_t _frames,
+						const f_cnt_t _frame_base, int _tco_num = -1 );
+	virtual trackView * createView( TrackContainerView* tcv );
+	virtual trackContentObject * createTCO( const MidiTime & _pos );
+
+
+	virtual void saveTrackSpecificSettings( QDomDocument & _doc,
+							QDomElement & _parent );
+	virtual void loadTrackSpecificSettings( const QDomElement & _this );
+
+	inline AudioPort * audioPort()
+	{
+		return &m_audioPort;
+	}
+
+	virtual QString nodeName() const
+	{
+		return "sampletrack";
+	}
+
+
+private:
+	AudioPort m_audioPort;
+	FloatModel m_volumeModel;
+
+
+	friend class SampleTrackView;
+
+} ;
+
+
+
+class SampleTrackView : public trackView
+{
+	Q_OBJECT
+public:
+	SampleTrackView( SampleTrack* track, TrackContainerView* tcv );
+	virtual ~SampleTrackView();
+
+
+public slots:
+	void showEffects();
+
+
+protected:
+	void modelChanged();
+	virtual QString nodeName() const
+	{
+		return "SampleTrackView";
+	}
+
+
+private:
+	EffectRackView * m_effectRack;
+	QWidget * m_effWindow;
+	knob * m_volumeKnob;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/SerializingObject.h b/lmms/include/SerializingObject.h
new file mode 100644
index 0000000..28442e2
--- /dev/null
+++ b/lmms/include/SerializingObject.h
@@ -0,0 +1,100 @@
+/*
+ * SerializingObject.h - declaration of class SerializingObject
+ *
+ * Copyright (c) 2008-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _SERIALIZING_OBJECT_H
+#define _SERIALIZING_OBJECT_H
+
+#include <QtCore/QString>
+
+#include "export.h"
+
+
+class QDomDocument;
+class QDomElement;
+
+class SerializingObjectHook;
+
+
+class EXPORT SerializingObject
+{
+public:
+	SerializingObject();
+	virtual ~SerializingObject();
+
+	virtual QDomElement saveState( QDomDocument & _doc, QDomElement & _parent );
+
+	virtual void restoreState( const QDomElement & _this );
+
+
+	// to be implemented by actual object
+	virtual QString nodeName() const = 0;
+
+	void setHook( SerializingObjectHook * _hook );
+
+	SerializingObjectHook* hook()
+	{
+		return m_hook;
+	}
+
+
+protected:
+	// to be implemented by sub-objects
+	virtual void saveSettings( QDomDocument& doc, QDomElement& element ) = 0;
+	virtual void loadSettings( const QDomElement& element ) = 0;
+
+
+private:
+	SerializingObjectHook * m_hook;
+
+} ;
+
+
+class SerializingObjectHook
+{
+public:
+	SerializingObjectHook() :
+		m_hookedIn( NULL )
+	{
+	}
+	virtual ~SerializingObjectHook()
+	{
+		if( m_hookedIn != NULL )
+		{
+			m_hookedIn->setHook( NULL );
+		}
+	}
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _this ) = 0;
+	virtual void loadSettings( const QDomElement & _this ) = 0;
+
+private:
+	SerializingObject * m_hookedIn;
+
+	friend class SerializingObject;
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/SideBar.h b/lmms/include/SideBar.h
new file mode 100644
index 0000000..9a544b8
--- /dev/null
+++ b/lmms/include/SideBar.h
@@ -0,0 +1,57 @@
+/*
+ * SideBar.h - side-bar in LMMS' MainWindow
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _SIDE_BAR_H
+#define _SIDE_BAR_H
+
+#include <QtCore/QMap>
+#include <QtGui/QButtonGroup>
+#include <QtGui/QToolBar>
+
+class QToolButton;
+class SideBarWidget;
+
+
+class SideBar : public QToolBar
+{
+	Q_OBJECT
+public:
+	SideBar( Qt::Orientation _orientation, QWidget * _parent );
+	virtual ~SideBar();
+
+	void appendTab( SideBarWidget * _sbw );
+
+
+private slots:
+	void toggleButton( QAbstractButton * _btn );
+
+
+private:
+	QButtonGroup m_btnGroup;
+	typedef QMap<QToolButton *, QWidget *> ButtonMap;
+	ButtonMap m_widgets;
+
+} ;
+
+#endif
diff --git a/lmms/include/SideBarWidget.h b/lmms/include/SideBarWidget.h
new file mode 100644
index 0000000..ff38994
--- /dev/null
+++ b/lmms/include/SideBarWidget.h
@@ -0,0 +1,82 @@
+/*
+ * SideBarWidget.h - base-class for all side-bar-widgets
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _SIDE_BAR_WIDGET_H
+#define _SIDE_BAR_WIDGET_H
+
+#include <QtGui/QPixmap>
+#include <QtGui/QVBoxLayout>
+#include <QtGui/QWidget>
+
+
+class SideBarWidget : public QWidget
+{
+	Q_OBJECT
+public:
+	SideBarWidget( const QString & _title, const QPixmap & _icon,
+							QWidget * _parent );
+	virtual ~SideBarWidget();
+
+	inline const QPixmap & icon() const
+	{
+		return m_icon;
+	}
+	inline const QString & title() const
+	{
+		return m_title;
+	}
+
+
+protected:
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void resizeEvent( QResizeEvent * _re );
+	virtual void contextMenuEvent( QContextMenuEvent * )
+	{
+	}
+
+	QWidget * contentParent()
+	{
+		return m_contents;
+	}
+
+	void addContentWidget( QWidget * _w )
+	{
+		m_layout->addWidget( _w );
+	}
+
+	void addContentLayout( QLayout * _l )
+	{
+		m_layout->addLayout( _l );
+	}
+
+
+private:
+	QWidget * m_contents;
+	QVBoxLayout * m_layout;
+	QString m_title;
+	QPixmap m_icon;
+
+} ;
+
+#endif
diff --git a/lmms/include/SongEditor.h b/lmms/include/SongEditor.h
new file mode 100644
index 0000000..3c26e76
--- /dev/null
+++ b/lmms/include/SongEditor.h
@@ -0,0 +1,140 @@
+/*
+ * SongEditor.h - declaration of class SongEditor, a window where you can
+ *                 setup your songs
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _SONG_EDITOR_H
+#define _SONG_EDITOR_H
+
+#include "TrackContainerView.h"
+
+class QLabel;
+class QScrollBar;
+
+class automatableSlider;
+class comboBox;
+class LcdSpinBox;
+class MeterDialog;
+class song;
+class textFloat;
+class timeLine;
+class toolButton;
+
+class positionLine : public QWidget
+{
+public:
+	positionLine( QWidget * _parent );
+
+private:
+	virtual void paintEvent( QPaintEvent * _pe );
+
+} ;
+
+
+class SongEditor : public TrackContainerView
+{
+	Q_OBJECT
+public:
+	SongEditor( song * _song );
+	virtual ~SongEditor();
+
+	void setPauseIcon( bool pause );
+
+
+public slots:
+	void scrolled( int _new_pos );
+
+
+private slots:
+	void setHighQuality( bool );
+
+	void play();
+	void record();
+	void recordAccompany();
+	void stop();
+
+	void masterVolumeChanged( int _new_val );
+	void masterVolumePressed();
+	void masterVolumeMoved( int _new_val );
+	void masterVolumeReleased();
+	void masterPitchChanged( int _new_val );
+	void masterPitchPressed();
+	void masterPitchMoved( int _new_val );
+	void masterPitchReleased();
+
+	void updateScrollBar( int );
+	void updatePosition( const MidiTime & _t );
+
+	void zoomingChanged();
+
+	void adjustUiAfterProjectLoad();
+
+
+private:
+	virtual void keyPressEvent( QKeyEvent * _ke );
+	virtual void wheelEvent( QWheelEvent * _we );
+
+	virtual bool allowRubberband() const;
+
+
+	song * m_s;
+
+	QScrollBar * m_leftRightScroll;
+
+	QWidget * m_toolBar;
+
+	toolButton * m_playButton;
+	toolButton * m_recordButton;
+	toolButton * m_recordAccompanyButton;
+	toolButton * m_stopButton;
+	LcdSpinBox * m_tempoSpinBox;
+
+	timeLine * m_timeLine;
+
+	MeterDialog * m_timeSigDisplay;
+	automatableSlider * m_masterVolumeSlider;
+	automatableSlider * m_masterPitchSlider;
+
+	textFloat * m_mvsStatus;
+	textFloat * m_mpsStatus;
+
+	toolButton * m_addBBTrackButton;
+	toolButton * m_addSampleTrackButton;
+	toolButton * m_addAutomationTrackButton;
+
+	toolButton * m_drawModeButton;
+	toolButton * m_editModeButton;
+
+	comboBox * m_zoomingComboBox;
+
+	positionLine * m_positionLine;
+
+	bool m_scrollBack;
+	bool m_smoothScroll;
+
+} ;
+
+
+
+#endif
diff --git a/lmms/include/SweepOscillator.h b/lmms/include/SweepOscillator.h
new file mode 100644
index 0000000..aa2729e
--- /dev/null
+++ b/lmms/include/SweepOscillator.h
@@ -0,0 +1,70 @@
+/*
+ * SweepOscillator.h - sweeping oscillator
+ *
+ * Copyright (c) 2006-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _SWEEP_OSCILLATOR_H
+#define _SWEEP_OSCILLATOR_H
+
+#include "Oscillator.h"
+#include "DspEffectLibrary.h"
+
+
+template<class FX = DspEffectLibrary::StereoBypass>
+class SweepOscillator
+{
+public:
+	SweepOscillator( const FX & _fx = FX() ) :
+		m_phase( 0.0f ),
+		m_FX( _fx )
+	{
+	}
+
+	virtual ~SweepOscillator()
+	{
+	}
+
+	void update( sampleFrame* buf, const fpp_t frames, const float freq1, const float freq2, const float sampleRate )
+	{
+		const float df = freq2 - freq1;
+		for( fpp_t frame = 0; frame < frames; ++frame )
+		{
+			const sample_t s = Oscillator::sinSample( m_phase );
+			buf[frame][0] = s;
+			buf[frame][1] = s;
+			m_FX.nextSample( buf[frame][0], buf[frame][1] );
+			m_phase += ( freq1 + ( frame * df / frames ) ) / sampleRate;
+		}
+	}
+
+
+private:
+	float m_phase;
+	FX m_FX;
+
+//	inline sample_t getSample( const float _sample );
+//	inline void recalcPhase();
+
+} ;
+
+
+#endif
diff --git a/lmms/include/TempoSyncKnob.h b/lmms/include/TempoSyncKnob.h
new file mode 100644
index 0000000..964d77c
--- /dev/null
+++ b/lmms/include/TempoSyncKnob.h
@@ -0,0 +1,82 @@
+/*
+ * TempoSyncKnob.h - adds bpm to ms conversion for knob class
+ *
+ * Copyright (c) 2005-2008 Danny McRae <khjklujn/at/yahoo.com>
+ * Copyright (c) 2009-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _TEMPO_SYNC_KNOB_H
+#define _TEMPO_SYNC_KNOB_H
+
+#include <QtGui/QPixmap>
+#include <QtCore/QPointer>
+
+#include "knob.h"
+#include "TempoSyncKnobModel.h"
+
+class MeterDialog;
+
+class EXPORT TempoSyncKnob : public knob
+{
+	Q_OBJECT
+public:
+	TempoSyncKnob( int knobNum, QWidget* parent = NULL, const QString& name = QString() );
+	virtual ~TempoSyncKnob();
+
+	const QString & syncDescription();
+	void setSyncDescription( const QString & _new_description );
+
+	const QPixmap & syncIcon();
+	void setSyncIcon( const QPixmap & _new_pix );
+
+	TempoSyncKnobModel * model()
+	{
+		return castModel<TempoSyncKnobModel>();
+	}
+
+	virtual void modelChanged();
+
+
+signals:
+	void syncDescriptionChanged( const QString & _new_description );
+	void syncIconChanged();
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+
+
+protected slots:
+	void updateDescAndIcon();
+	void showCustom();
+
+
+private:
+	QPixmap m_tempoSyncIcon;
+	QString m_tempoSyncDescription;
+
+	QPointer<MeterDialog> m_custom;
+
+} ;
+
+
+
+#endif
diff --git a/lmms/include/TempoSyncKnobModel.h b/lmms/include/TempoSyncKnobModel.h
new file mode 100644
index 0000000..4c0461e
--- /dev/null
+++ b/lmms/include/TempoSyncKnobModel.h
@@ -0,0 +1,104 @@
+/*
+ * TempoSyncKnobModel.h - adds bpm to ms conversion for knob class
+ *
+ * Copyright (c) 2005-2008 Danny McRae <khjklujn/at/yahoo.com>
+ * Copyright (c) 2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _TEMPO_SYNC_KNOB_MODEL_H
+#define _TEMPO_SYNC_KNOB_MODEL_H
+
+#include "MeterModel.h"
+
+class QAction;
+
+class EXPORT TempoSyncKnobModel : public FloatModel
+{
+	Q_OBJECT
+public:
+	enum TempoSyncMode
+	{
+		SyncNone,
+		SyncDoubleWholeNote,
+		SyncWholeNote,
+		SyncHalfNote,
+		SyncQuarterNote,
+		SyncEighthNote,
+		SyncSixteenthNote,
+		SyncThirtysecondNote,
+		SyncCustom
+	} ;
+
+	TempoSyncKnobModel( const float _val, const float _min,
+				const float _max, const float _step,
+				const float _scale, Model * _parent,
+				const QString & _display_name = QString() );
+	virtual ~TempoSyncKnobModel();
+
+	void saveSettings( QDomDocument & _doc, QDomElement & _this, const QString& name );
+	void loadSettings( const QDomElement & _this, const QString& name );
+
+	TempoSyncMode syncMode() const
+	{
+		return m_tempoSyncMode;
+	}
+
+	void setSyncMode( TempoSyncMode _new_mode );
+
+	float scale() const
+	{
+		return m_scale;
+	}
+
+	void setScale( float _new_scale );
+
+signals:
+	void syncModeChanged( TempoSyncMode _new_mode );
+	void scaleChanged( float _new_scale );
+
+
+public slots:
+	inline void disableSync()
+	{
+		setTempoSync( SyncNone );
+	}
+	void setTempoSync( int _note_type );
+	void setTempoSync( QAction * _item );
+
+
+protected slots:
+	void calculateTempoSyncTime( bpm_t _bpm );
+	void updateCustom();
+
+
+private:
+	TempoSyncMode m_tempoSyncMode;
+	TempoSyncMode m_tempoLastSyncMode;
+	float m_scale;
+
+	MeterModel m_custom;
+
+
+	friend class TempoSyncKnob;
+
+} ;
+
+#endif
diff --git a/lmms/include/TimeDisplayWidget.h b/lmms/include/TimeDisplayWidget.h
new file mode 100644
index 0000000..cde431d
--- /dev/null
+++ b/lmms/include/TimeDisplayWidget.h
@@ -0,0 +1,70 @@
+/*
+ * TimeDisplayWidget.h - widget for displaying current playback time
+ *
+ * Copyright (c) 2014 Ruben Ibarra
+ * Copyright (c) 2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _TIME_DISPLAY_WIDGET
+#define _TIME_DISPLAY_WIDGET
+
+#include <QtGui/QWidget>
+#include <QtGui/QHBoxLayout>
+
+#include "LcdWidget.h"
+
+
+class TimeDisplayWidget : public QWidget
+{
+	Q_OBJECT
+public:
+	TimeDisplayWidget();
+	virtual ~TimeDisplayWidget();
+
+
+protected:
+	virtual void mousePressEvent( QMouseEvent* mouseEvent );
+
+
+private slots:
+	void updateTime();
+
+
+private:
+	enum DisplayModes
+	{
+		MinutesSeconds,
+		BarsTicks,
+		DisplayModeCount
+	};
+	typedef DisplayModes DisplayMode;
+
+	void setDisplayMode( DisplayMode displayMode );
+
+	DisplayMode m_displayMode;
+	QHBoxLayout m_spinBoxesLayout;
+	LcdWidget m_majorLCD;
+	LcdWidget m_minorLCD;
+	LcdWidget m_milliSecondsLCD;
+
+} ;
+
+#endif
diff --git a/lmms/include/ToolPlugin.h b/lmms/include/ToolPlugin.h
new file mode 100644
index 0000000..e680a9e
--- /dev/null
+++ b/lmms/include/ToolPlugin.h
@@ -0,0 +1,45 @@
+/*
+ * ToolPlugin.h - declaration of class ToolPlugin, a standard interface for all
+ *                tool plugins
+ *
+ * Copyright (c) 2006-2007 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * Copyright (c) 2008-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _TOOL_PLUGIN_H
+#define _TOOL_PLUGIN_H
+
+#include "Plugin.h"
+
+class EXPORT ToolPlugin : public Plugin
+{
+public:
+	ToolPlugin( const Descriptor * _descriptor, Model * _parent );
+	virtual ~ToolPlugin();
+
+	// instantiate tool-plugin with given name or return NULL
+	// on failure
+	static ToolPlugin * instantiate( const QString & _plugin_name,
+										Model * _parent );
+
+} ;
+
+#endif
diff --git a/lmms/include/ToolPluginView.h b/lmms/include/ToolPluginView.h
new file mode 100644
index 0000000..9b81070
--- /dev/null
+++ b/lmms/include/ToolPluginView.h
@@ -0,0 +1,41 @@
+/*
+ * ToolPluginView.h - declaration of class ToolPluginView
+ *
+ * Copyright (c) 2006-2007 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * Copyright (c) 2008-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _TOOL_PLUGIN_VIEW_H
+#define _TOOL_PLUGIN_VIEW_H
+
+#include "PluginView.h"
+
+class ToolPlugin;
+
+class EXPORT ToolPluginView : public PluginView
+{
+public:
+	ToolPluginView( ToolPlugin * _toolPlugin );
+
+} ;
+
+
+#endif
diff --git a/lmms/include/TrackContainer.h b/lmms/include/TrackContainer.h
new file mode 100644
index 0000000..5918c59
--- /dev/null
+++ b/lmms/include/TrackContainer.h
@@ -0,0 +1,124 @@
+/*
+ * TrackContainer.h - base-class for all track-containers like Song-Editor,
+ *                    BB-Editor...
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _TRACK_CONTAINER_H
+#define _TRACK_CONTAINER_H
+
+#include <QtCore/QReadWriteLock>
+
+#include "track.h"
+#include "JournallingObject.h"
+
+
+class AutomationPattern;
+class InstrumentTrack;
+class TrackContainerView;
+
+
+class EXPORT TrackContainer : public Model, public JournallingObject
+{
+	Q_OBJECT
+public:
+	typedef QVector<track *> TrackList;
+
+	TrackContainer();
+	virtual ~TrackContainer();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+
+	virtual void loadSettings( const QDomElement & _this );
+
+
+	virtual AutomationPattern * tempoAutomationPattern()
+	{
+		return NULL;
+	}
+
+	int countTracks( track::TrackTypes _tt = track::NumTrackTypes ) const;
+
+
+	void addTrack( track * _track );
+	void removeTrack( track * _track );
+
+	virtual void updateAfterTrackAdd();
+
+	void clearAllTracks();
+
+	const TrackList & tracks() const
+	{
+		return m_tracks;
+	}
+
+	bool isEmpty() const;
+
+	static const QString classNodeName()
+	{
+		return "trackcontainer";
+	}
+
+
+signals:
+	void trackAdded( track * _track );
+
+protected:
+	mutable QReadWriteLock m_tracksMutex;
+
+private:
+	TrackList m_tracks;
+
+
+	friend class TrackContainerView;
+	friend class track;
+
+} ;
+
+
+class DummyTrackContainer : public TrackContainer
+{
+public:
+	DummyTrackContainer();
+
+	virtual ~DummyTrackContainer()
+	{
+	}
+
+	virtual QString nodeName() const
+	{
+		return "DummyTrackContainer";
+	}
+
+	InstrumentTrack * dummyInstrumentTrack()
+	{
+		return m_dummyInstrumentTrack;
+	}
+
+
+private:
+	InstrumentTrack * m_dummyInstrumentTrack;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/TrackContainerView.h b/lmms/include/TrackContainerView.h
new file mode 100644
index 0000000..48d8c49
--- /dev/null
+++ b/lmms/include/TrackContainerView.h
@@ -0,0 +1,190 @@
+/*
+ * TrackContainerView.h - view-component for TrackContainer
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef TRACK_CONTAINER_VIEW_H
+#define TRACK_CONTAINER_VIEW_H
+
+#include <QtCore/QVector>
+#include <QtGui/QScrollArea>
+#include <QtGui/QWidget>
+
+
+#include "track.h"
+#include "JournallingObject.h"
+
+
+class QVBoxLayout;
+class TrackContainer;
+
+
+class TrackContainerView : public QWidget, public ModelView,
+						public JournallingObject,
+						public SerializingObjectHook
+{
+	Q_OBJECT
+public:
+	TrackContainerView( TrackContainer* tc );
+	virtual ~TrackContainerView();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _this );
+	virtual void loadSettings( const QDomElement & _this );
+
+	QWidget * contentWidget()
+	{
+		return( m_scrollArea );
+	}
+
+	inline const MidiTime & currentPosition() const
+	{
+		return( m_currentPosition );
+	}
+
+	virtual bool fixedTCOs() const
+	{
+		return( false );
+	}
+
+	inline float pixelsPerTact() const
+	{
+		return( m_ppt );
+	}
+
+	void setPixelsPerTact( int _ppt );
+
+	const trackView * trackViewAt( const int _y ) const;
+
+	virtual bool allowRubberband() const;
+
+	inline bool rubberBandActive() const
+	{
+		return( m_rubberBand->isVisible() );
+	}
+
+	inline QVector<selectableObject *> selectedObjects()
+	{
+		if( allowRubberband() == true )
+		{
+			return( m_rubberBand->selectedObjects() );
+		}
+		return( QVector<selectableObject *>() );
+	}
+
+
+	TrackContainer* model()
+	{
+		return m_tc;
+	}
+
+	const TrackContainer* model() const
+	{
+		return m_tc;
+	}
+
+	void moveTrackViewUp( trackView * _tv );
+	void moveTrackViewDown( trackView * _tv );
+
+	// -- for usage by trackView only ---------------
+	trackView * addTrackView( trackView * _tv );
+	void removeTrackView( trackView * _tv );
+	// -------------------------------------------------------
+
+	void clearAllTracks();
+
+	virtual QString nodeName() const
+	{
+		return( "trackcontainerview" );
+	}
+
+
+public slots:
+	void realignTracks();
+	void createTrackView( track * _t );
+	void deleteTrackView( trackView * _tv );
+
+
+protected:
+	static const int DEFAULT_PIXELS_PER_TACT = 16;
+
+	const QList<trackView *> & trackViews() const
+	{
+		return( m_trackViews );
+	}
+
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseMoveEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+	virtual void resizeEvent( QResizeEvent * );
+
+	virtual void undoStep( JournalEntry & _je );
+	virtual void redoStep( JournalEntry & _je );
+
+	MidiTime m_currentPosition;
+
+
+private:
+	enum Actions
+	{
+		AddTrack,
+		RemoveTrack
+	} ;
+
+	class scrollArea : public QScrollArea
+	{
+	public:
+		scrollArea( TrackContainerView* parent );
+		virtual ~scrollArea();
+
+	protected:
+		virtual void wheelEvent( QWheelEvent * _we );
+
+	private:
+		TrackContainerView* m_trackContainerView;
+
+	} ;
+
+	TrackContainer* m_tc;
+	typedef QList<trackView *> trackViewList;
+	trackViewList m_trackViews;
+
+	scrollArea * m_scrollArea;
+	QVBoxLayout * m_scrollLayout;
+
+	float m_ppt;
+
+	rubberBand * m_rubberBand;
+	QPoint m_origin;
+
+
+signals:
+	void positionChanged( const MidiTime & _pos );
+
+
+} ;
+
+
+
+#endif
diff --git a/lmms/include/VersionedSaveDialog.h b/lmms/include/VersionedSaveDialog.h
new file mode 100644
index 0000000..8041f00
--- /dev/null
+++ b/lmms/include/VersionedSaveDialog.h
@@ -0,0 +1,53 @@
+/*
+ * VersionedSaveDialog.h - declaration of class VersionedSaveDialog, a file save
+ * dialog that provides buttons to increment or decrement a version which is
+ * appended to the file name. (e.g. "MyProject-01.mmpz")
+ *
+ * Copyright (c) 2014 Lukas W <lukaswhl/at/gmail.com>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef VERSIONEDSAVEDIALOG_H
+#define VERSIONEDSAVEDIALOG_H
+
+#include "FileDialog.h"
+
+class QLineEdit;
+
+
+class VersionedSaveDialog : public FileDialog
+{
+	Q_OBJECT
+public:
+	explicit VersionedSaveDialog( QWidget *parent = 0,
+								  const QString &caption = QString(),
+								  const QString &directory = QString(),
+								  const QString &filter = QString() );
+
+	// Returns true if file name was changed, returns false if it wasn't
+	static bool changeFileNameVersion( QString &fileName, bool increment );
+
+public slots:
+	void incrementVersion();
+	void decrementVersion();
+};
+
+#endif // VERSIONEDSAVEDIALOG_H
diff --git a/lmms/include/VstSyncController.h b/lmms/include/VstSyncController.h
new file mode 100644
index 0000000..91c39ea
--- /dev/null
+++ b/lmms/include/VstSyncController.h
@@ -0,0 +1,99 @@
+/*
+ * VstSyncController.h - type declarations needed for VST to lmms host sync
+ *
+ * Copyright (c) 2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * Copyright (c) 2013 Mike Choi <rdavidian71/at/gmail/dot/com>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef VST_SYNC_CONTROLLER_H
+#define VST_SYNC_CONTROLLER_H
+
+#include <QtCore/QObject>
+#include <QtCore/QSharedMemory>
+
+#include "VstSyncData.h"
+
+
+class VstSyncController : public QObject
+{
+	Q_OBJECT
+public:
+	VstSyncController();
+	~VstSyncController();
+
+	void setAbsolutePosition( int ticks );
+
+	void setPlaybackState( bool enabled )
+	{
+		m_syncData->isPlaying = enabled;
+	}
+
+	void setTempo( int newTempo );
+
+	void setTimeSignature( int num, int denom )
+	{
+		m_syncData->timeSigNumer = num;
+		m_syncData->timeSigDenom = denom;
+	}
+
+	void startCycle( int startTick, int endTick );
+
+	void stopCycle()
+	{
+		m_syncData->isCycle = false;
+	}
+
+	void update();
+
+
+private slots:
+	void updateSampleRate();
+
+
+private:
+	struct VstSyncData
+	{
+		bool isPlaying;
+		float ppqPos;
+		int timeSigNumer;
+		int timeSigDenom;
+		bool isCycle;
+		bool hasSHM;
+		float cycleStart;
+		float cycleEnd;
+		int m_bufferSize;
+		int m_sampleRate;
+		int m_bpm;
+
+#ifdef VST_SNC_LATENCY
+		float m_latency;
+#endif
+	} ;
+
+	VstSyncData* m_syncData;
+
+	int m_shmID;
+
+	QSharedMemory m_shm;
+
+};
+
+#endif
diff --git a/lmms/include/VstSyncData.h b/lmms/include/VstSyncData.h
new file mode 100644
index 0000000..9daa338
--- /dev/null
+++ b/lmms/include/VstSyncData.h
@@ -0,0 +1,61 @@
+/*
+ * VstSyncData.h - type declarations needed for VST to lmms host sync
+ *
+ * Copyright (c) 2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * Copyright (c) 2013 Mike Choi <rdavidian71/at/gmail/dot/com>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef VST_SYNC_DATA_H
+#define VST_SYNC_DATA_H
+
+// VST sync frequency (in ms), how often will be VST plugin synced
+// keep it power of two if possible (not used by now)
+//#define VST_SNC_TIMER 1
+
+// When defined, latency should be subtracted from song PPQ position
+//#define VST_SNC_LATENCY
+
+// define file for ftok as shared memory shmget key
+#define VST_SNC_SHM_KEY_FILE "/dev/null"
+//#define VST_SNC_SHM_RND_KEY 3561653564469
+
+
+
+struct VstSyncData
+{
+	bool isPlaying;
+	float ppqPos;
+	int timeSigNumer;
+	int timeSigDenom;
+	bool isCycle;
+	bool hasSHM;
+	float cycleStart;
+	float cycleEnd;
+	int m_bufferSize;
+	int m_sampleRate;
+	int m_bpm;
+
+#ifdef VST_SNC_LATENCY
+	float m_latency;
+#endif
+} ;
+
+#endif
diff --git a/lmms/include/about_dialog.h b/lmms/include/about_dialog.h
new file mode 100644
index 0000000..b2621ba
--- /dev/null
+++ b/lmms/include/about_dialog.h
@@ -0,0 +1,43 @@
+/*
+ * about_dialog.h - declaration of class aboutDialog
+ *
+ * Copyright (c) 2004-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _ABOUT_DIALOG_H
+#define _ABOUT_DIALOG_H
+
+#include <QtGui/QDialog>
+
+#include "ui_about_dialog.h"
+
+
+class aboutDialog : public QDialog, public Ui::AboutDialog
+{
+public:
+	aboutDialog( void );
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/aeffectx.h b/lmms/include/aeffectx.h
new file mode 100644
index 0000000..4188bf4
--- /dev/null
+++ b/lmms/include/aeffectx.h
@@ -0,0 +1,304 @@
+/*
+ * aeffectx.h - simple header to allow VeSTige compilation and eventually work
+ *
+ * Copyright (c) 2006 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _AEFFECTX_H
+#define _AEFFECTX_H
+
+#define CCONST(a, b, c, d)( ( ( (int) a ) << 24 ) |		\
+				( ( (int) b ) << 16 ) |		\
+				( ( (int) c ) << 8 ) |		\
+				( ( (int) d ) << 0 ) )
+
+const int audioMasterAutomate = 0;
+const int audioMasterVersion = 1;
+const int audioMasterCurrentId = 2;
+const int audioMasterIdle = 3;
+const int audioMasterPinConnected = 4;
+// unsupported? 5
+const int audioMasterWantMidi = 6;
+const int audioMasterGetTime = 7;
+const int audioMasterProcessEvents = 8;
+const int audioMasterSetTime = 9;
+const int audioMasterTempoAt = 10;
+const int audioMasterGetNumAutomatableParameters = 11;
+const int audioMasterGetParameterQuantization = 12;
+const int audioMasterIOChanged = 13;
+const int audioMasterNeedIdle = 14;
+const int audioMasterSizeWindow = 15;
+const int audioMasterGetSampleRate = 16;
+const int audioMasterGetBlockSize = 17;
+const int audioMasterGetInputLatency = 18;
+const int audioMasterGetOutputLatency = 19;
+const int audioMasterGetPreviousPlug = 20;
+const int audioMasterGetNextPlug = 21;
+const int audioMasterWillReplaceOrAccumulate = 22;
+const int audioMasterGetCurrentProcessLevel = 23;
+const int audioMasterGetAutomationState = 24;
+const int audioMasterOfflineStart = 25;
+const int audioMasterOfflineRead = 26;
+const int audioMasterOfflineWrite = 27;
+const int audioMasterOfflineGetCurrentPass = 28;
+const int audioMasterOfflineGetCurrentMetaPass = 29;
+const int audioMasterSetOutputSampleRate = 30;
+// unsupported? 31
+const int audioMasterGetSpeakerArrangement = 31; // deprecated in 2.4?
+const int audioMasterGetVendorString = 32;
+const int audioMasterGetProductString = 33;
+const int audioMasterGetVendorVersion = 34;
+const int audioMasterVendorSpecific = 35;
+const int audioMasterSetIcon = 36;
+const int audioMasterCanDo = 37;
+const int audioMasterGetLanguage = 38;
+const int audioMasterOpenWindow = 39;
+const int audioMasterCloseWindow = 40;
+const int audioMasterGetDirectory = 41;
+const int audioMasterUpdateDisplay = 42;
+const int audioMasterBeginEdit = 43;
+const int audioMasterEndEdit = 44;
+const int audioMasterOpenFileSelector = 45;
+const int audioMasterCloseFileSelector = 46; // currently unused
+const int audioMasterEditFile = 47; // currently unused
+const int audioMasterGetChunkFile = 48; // currently unused
+const int audioMasterGetInputSpeakerArrangement = 49; // currently unused
+
+const int effFlagsHasEditor = 1;
+const int effFlagsCanReplacing = 1 << 4; // very likely
+const int effFlagsIsSynth = 1 << 8; // currently unused
+
+const int effOpen = 0;
+const int effClose = 1; // currently unused
+const int effSetProgram = 2; // currently unused
+const int effGetProgram = 3; // currently unused
+const int effGetProgramName = 5; // currently unused
+const int effGetParamName = 8; // currently unused
+const int effSetSampleRate = 10;
+const int effSetBlockSize = 11;
+const int effMainsChanged = 12;
+const int effEditGetRect = 13;
+const int effEditOpen = 14;
+const int effEditClose = 15;
+const int effEditIdle = 19;
+const int effEditTop = 20;
+const int effProcessEvents = 25;
+const int effGetEffectName = 45;
+const int effGetParameterProperties = 47; // missing
+const int effGetVendorString = 47;
+const int effGetProductString = 48;
+const int effGetVendorVersion = 49;
+const int effCanDo = 51; // currently unused
+const int effGetVstVersion = 58; // currently unused
+
+const int kEffectMagic = CCONST( 'V', 's', 't', 'P' );
+const int kVstLangEnglish = 1;
+const int kVstMidiType = 1;
+const int kVstParameterUsesFloatStep = 1 << 2;
+const int kVstPpqPosValid = 1 << 9;
+const int kVstTempoValid = 1 << 10;
+const int kVstBarsValid = 1 << 11;
+const int kVstCyclePosValid = 1 << 12;
+const int kVstTimeSigValid = 1 << 13;
+const int kVstTransportPlaying = 1 << 1;
+const int kVstTransportCycleActive = 1 << 2;
+const int kVstTransportChanged = 1;
+
+
+class RemoteVstPlugin;
+
+
+class VstMidiEvent
+{
+public:
+	// 00
+	int type;
+	// 04
+	int byteSize;
+	// 08
+	int deltaFrames;
+	// 0c?
+	int flags;
+	// 10?
+	int noteLength;
+	// 14?
+	int noteOffset;
+	// 18
+	char midiData[4];
+	// 1c?
+	char detune;
+	// 1d?
+	char noteOffVelocity;
+	// 1e?
+	char reserved1;
+	// 1f?
+	char reserved2;
+
+} ;
+
+
+
+
+class VstEvent
+{
+	char dump[sizeof( VstMidiEvent )];
+
+} ;
+
+
+
+
+class VstEvents
+{
+public:
+	// 00
+	int numEvents;
+	// 04
+	void *reserved;
+	// 08
+	VstEvent* events[1];
+
+} ;
+
+
+
+
+// Not finished, neither really used
+class VstParameterProperties
+{
+public:
+/*	float stepFloat;
+	char label[64];
+	int flags;
+	int minInteger;
+	int maxInteger;
+	int stepInteger;
+	char shortLabel[8];
+	int category;
+	char categoryLabel[24];
+	char empty[128];*/
+
+	float stepFloat;
+	float smallStepFloat;
+	float largeStepFloat;
+	char label[64];
+	unsigned int flags;
+	unsigned int minInteger;
+	unsigned int maxInteger;
+	unsigned int stepInteger;
+	unsigned int largeStepInteger;
+	char shortLabel[8];
+	unsigned short displayIndex;
+  	unsigned short category;
+  	unsigned short numParametersInCategory;
+	unsigned short reserved;
+	char categoryLabel[24];
+	char future[16];
+
+} ;
+
+
+
+
+class AEffect
+{
+public:
+	// Never use virtual functions!!!
+	// 00-03
+	int magic;
+	// dispatcher 04-07
+	intptr_t (* dispatcher)( AEffect * , int , int , intptr_t, void * , float );
+	// process, quite sure 08-0b
+	void (* process)( AEffect * , float * * , float * * , int );
+	// setParameter 0c-0f
+	void (* setParameter)( AEffect * , int , float );
+	// getParameter 10-13
+	float (* getParameter)( AEffect * , int );
+	// programs 14-17
+	int numPrograms;
+	// Params 18-1b
+	int numParams;
+	// Input 1c-1f
+	int numInputs;
+	// Output 20-23
+	int numOutputs;
+	// flags 24-27
+	int flags;
+	// Fill somewhere 28-2b
+	void *ptr1;
+	void *ptr2;
+	// Zeroes 2c-2f 30-33 34-37 38-3b
+	char empty3[4 + 4 + 4];
+	// 1.0f 3c-3f
+	float unkown_float;
+	// An object? pointer 40-43
+	void *ptr3;
+	// Zeroes 44-47
+	void *user;
+	// Id 48-4b
+	int32_t uniqueID;
+	// Don't know 4c-4f
+	char unknown1[4];
+	// processReplacing 50-53
+	void (* processReplacing)( AEffect * , float * * , float * * , int );
+
+} ;
+
+
+
+
+class VstTimeInfo
+{
+public:
+	// 00
+	double samplePos;
+	// 08
+	double sampleRate;
+	// unconfirmed 10
+	char empty1[8];
+	// 18
+	double ppqPos;
+	// 20?
+	double tempo;
+	// 28
+	double barStartPos;
+	// 30?
+	double cycleStartPos;
+	// 38?
+	double cycleEndPos;
+	// 40?
+	int timeSigNumerator;
+	// 44?
+	int timeSigDenominator;
+	// unconfirmed 48 4c 50
+	char empty3[4 + 4 + 4];
+	// 54
+	int flags;
+
+} ;
+
+
+
+typedef intptr_t (* audioMasterCallback)( AEffect * , int32_t, int32_t, intptr_t, void * , float );
+
+
+#endif
diff --git a/lmms/include/atomic_int.h b/lmms/include/atomic_int.h
new file mode 100644
index 0000000..dd8bf78
--- /dev/null
+++ b/lmms/include/atomic_int.h
@@ -0,0 +1,103 @@
+/*
+ * atomic_int.h - fallback AtomicInt class when Qt is too old
+ *
+ * Copyright (c) 2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _ATOMIC_INT_H
+#define _ATOMIC_INT_H
+
+#include <QtCore/QMutex>
+
+#if QT_VERSION >= 0x040400
+
+typedef QAtomicInt AtomicInt;
+
+#else
+// implement our own (slow) QAtomicInt class when on old Qt
+class AtomicInt
+{
+public:
+	inline AtomicInt( int _value = 0 ) :
+		m_value( _value ),
+		m_lock()
+	{
+	}
+
+	inline AtomicInt( const AtomicInt & _copy ) :
+		m_value( _copy.m_value ),
+		m_lock()
+	{
+	}
+
+	inline int fetchAndStoreOrdered( int _newVal )
+	{
+		m_lock.lock();
+		const int oldVal = m_value;
+		m_value = _newVal;
+		m_lock.unlock();
+
+		return oldVal;
+	}
+
+	inline int fetchAndAddOrdered( int _add )
+	{
+		m_lock.lock();
+		const int oldVal = m_value;
+		m_value += _add;
+		m_lock.unlock();
+
+		return oldVal;
+	}
+
+	inline AtomicInt & operator=( const AtomicInt & _copy )
+	{
+		m_lock.lock();
+		m_value = _copy.m_value;
+		m_lock.unlock();
+
+		return *this;
+	}
+
+
+	inline AtomicInt & operator=( int _value )
+	{
+		m_lock.lock();
+		m_value = _value;
+		m_lock.unlock();
+
+		return *this;
+	}
+
+	inline operator int() const
+	{
+		return m_value;
+	}
+
+private:
+	volatile int m_value;
+	QMutex m_lock;
+} ;
+
+#endif
+
+#endif
+
diff --git a/lmms/include/automatable_button.h b/lmms/include/automatable_button.h
new file mode 100644
index 0000000..53084cf
--- /dev/null
+++ b/lmms/include/automatable_button.h
@@ -0,0 +1,109 @@
+/*
+ * automatable_button.h - class automatableButton, the base for all buttons
+ *
+ * Copyright (c) 2006-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _AUTOMATABLE_BUTTON_H
+#define _AUTOMATABLE_BUTTON_H
+
+#include <QtGui/QPushButton>
+
+#include "AutomatableModelView.h"
+
+
+class automatableButtonGroup;
+
+
+class EXPORT automatableButton : public QPushButton, public BoolModelView
+{
+	Q_OBJECT
+public:
+	automatableButton( QWidget * _parent, const QString & _name 
+			= QString::null );
+	virtual ~automatableButton();
+
+	inline void setCheckable( bool _on )
+	{
+		QPushButton::setCheckable( _on );
+		model()->setJournalling( _on );
+	}
+
+	virtual void modelChanged();
+
+
+public slots:
+	virtual void update();
+	virtual void toggle();
+	virtual void setChecked( bool _on )
+	{
+		// QPushButton::setChecked is called in update-slot
+		model()->setValue( _on );
+	}
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+
+
+private:
+	automatableButtonGroup * m_group;
+
+
+	friend class automatableButtonGroup;
+
+	using QPushButton::setChecked;
+	using QPushButton::isChecked;
+} ;
+
+
+
+class EXPORT automatableButtonGroup : public QWidget, public IntModelView
+{
+	Q_OBJECT
+public:
+	automatableButtonGroup( QWidget * _parent, const QString & _name
+			= QString::null );
+	virtual ~automatableButtonGroup();
+
+	void addButton( automatableButton * _btn );
+	void removeButton( automatableButton * _btn );
+
+	void activateButton( automatableButton * _btn );
+
+	virtual void modelChanged();
+
+
+private slots:
+	void updateButtons();
+
+
+private:
+	QList<automatableButton *> m_buttons;
+
+} ;
+
+
+
+#endif
diff --git a/lmms/include/automatable_slider.h b/lmms/include/automatable_slider.h
new file mode 100644
index 0000000..3a41a77
--- /dev/null
+++ b/lmms/include/automatable_slider.h
@@ -0,0 +1,77 @@
+/*
+ * automatable_slider.h - class automatableSlider, a QSlider with automation
+ *
+ * Copyright (c) 2006-2008 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _AUTOMATABLE_SLIDER_H
+#define _AUTOMATABLE_SLIDER_H
+
+#include <QtGui/QSlider>
+
+#include "AutomatableModelView.h"
+
+
+
+class automatableSlider : public QSlider, public IntModelView
+{
+	Q_OBJECT
+public:
+	automatableSlider( QWidget * _parent, const QString & _name = QString::null );
+	virtual ~automatableSlider();
+
+	bool showStatus()
+	{
+		return( m_showStatus );
+	}
+
+
+signals:
+	void logicValueChanged( int _value );
+	void logicSliderMoved( int _value );
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+	virtual void wheelEvent( QWheelEvent * _me );
+
+	virtual void modelChanged();
+
+
+private:
+	bool m_showStatus;
+
+
+private slots:
+	void changeValue( int _value );
+	void moveSlider( int _value );
+	void updateSlider();
+
+} ;
+
+
+typedef IntModel sliderModel;
+
+
+#endif
diff --git a/lmms/include/base64.h b/lmms/include/base64.h
new file mode 100644
index 0000000..ebdfe47
--- /dev/null
+++ b/lmms/include/base64.h
@@ -0,0 +1,58 @@
+/*
+ * base64.h - namespace base64 with methods for encoding/decoding binary data
+ *            to/from base64
+ *
+ * Copyright (c) 2006-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _BASE64_H
+#define _BASE64_H
+
+#include <QtCore/QByteArray>
+#include <QtCore/QString>
+#include <QtCore/QVariant>
+
+
+namespace base64
+{
+	inline void encode( const char * _data, const int _size,
+								QString & _dst )
+	{
+		_dst = QByteArray( _data, _size ).toBase64();
+	}
+
+	template<class T>
+	inline void decode( const QString & _b64, T * * _data, int * _size )
+	{
+		QByteArray data = QByteArray::fromBase64( _b64.toUtf8() );
+		*_size = data.size();
+		*_data = new T[*_size / sizeof(T)];
+		memcpy( *_data, data.constData(), *_size );
+	}
+	// deprecated!!
+	QString encode( const QVariant & _data );
+	// for compatibility-code only
+	QVariant decode( const QString & _b64,
+			QVariant::Type _force_type = QVariant::Invalid );
+
+}
+
+#endif
diff --git a/lmms/include/basic_filters.h b/lmms/include/basic_filters.h
new file mode 100644
index 0000000..e41046e
--- /dev/null
+++ b/lmms/include/basic_filters.h
@@ -0,0 +1,675 @@
+/*
+ * basic_filters.h - simple but powerful filter-class with most used filters
+ *
+ * original file by ??? 
+ * modified and enhanced by Tobias Doerffel
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _BASIC_FILTERS_H
+#define _BASIC_FILTERS_H
+
+#ifndef __USE_XOPEN
+#define __USE_XOPEN
+#endif
+
+#include <math.h>
+
+#include "lmms_basics.h"
+#include "Mixer.h"
+#include "templates.h"
+#include "lmms_constants.h"
+
+//#include <iostream>
+//#include <cstdlib>
+
+template<ch_cnt_t CHANNELS/* = DEFAULT_CHANNELS*/>
+class basicFilters
+{
+public:
+	enum FilterTypes
+	{
+		LowPass,
+		HiPass,
+		BandPass_CSG,
+		BandPass_CZPG,
+		Notch,
+		AllPass,
+		Moog,
+		DoubleLowPass,
+		Lowpass_RC12,
+		Bandpass_RC12,
+		Highpass_RC12,
+		Lowpass_RC24,
+		Bandpass_RC24,
+		Highpass_RC24,
+		Formantfilter,
+		NumFilters
+	} ;
+
+	static inline float minFreq()
+	{
+		return( 3.0f );
+	}
+
+	static inline float minQ()
+	{
+		return( 0.01f );
+	}
+
+	inline void setFilterType( const int _idx )
+	{
+		m_doubleFilter = _idx == DoubleLowPass;
+		if( !m_doubleFilter )
+		{
+			m_type = static_cast<FilterTypes>( _idx );
+			return;
+		}
+
+		// Double lowpass mode, backwards-compat for the goofy
+		// Add-NumFilters to signify doubleFilter stuff
+		m_type = static_cast<FilterTypes>( LowPass );
+		if( m_subFilter == NULL )
+		{
+			m_subFilter = new basicFilters<CHANNELS>(
+						static_cast<sample_rate_t>(
+							m_sampleRate ) );
+		}
+		m_subFilter->m_type = m_type;
+	}
+
+	inline basicFilters( const sample_rate_t _sample_rate ) :
+		m_b0a0( 0.0f ),
+		m_b1a0( 0.0f ),
+		m_b2a0( 0.0f ),
+		m_a1a0( 0.0f ),
+		m_a2a0( 0.0f ),
+		m_rca( 0.0f ),
+		m_rcb( 1.0f ),
+		m_rcc( 0.0f ),
+		m_doubleFilter( false ),
+		m_sampleRate( (float) _sample_rate ),
+		m_subFilter( NULL )
+	{
+		clearHistory();
+	}
+
+	inline ~basicFilters()
+	{
+		delete m_subFilter;
+	}
+
+	inline void clearHistory()
+	{
+		// reset in/out history
+		for( ch_cnt_t _chnl = 0; _chnl < CHANNELS; ++_chnl )
+		{
+			// reset in/out history for simple filters
+			m_ou1[_chnl] = m_ou2[_chnl] = m_in1[_chnl] =
+					m_in2[_chnl] = 0.0f;
+					
+			// reset in/out history for moog-filter
+			m_y1[_chnl] = m_y2[_chnl] = m_y3[_chnl] = m_y4[_chnl] =
+					m_oldx[_chnl] = m_oldy1[_chnl] =
+					m_oldy2[_chnl] = m_oldy3[_chnl] = 0.0f;
+					
+			// reset in/out history for RC-filters
+			m_rclp0[_chnl] = m_rcbp0[_chnl] = m_rchp0[_chnl] = m_rclast0[_chnl] = 0.0f;
+			m_rclp1[_chnl] = m_rcbp1[_chnl] = m_rchp1[_chnl] = m_rclast1[_chnl] = 0.0f;
+			
+			for(int i=0; i<6; i++)
+			   m_vflp[i][_chnl] = m_vfbp[i][_chnl] = m_vfhp[i][_chnl] = m_vflast[i][_chnl] = 0.0f;
+		}
+	}
+
+	inline sample_t update( sample_t _in0, ch_cnt_t _chnl )
+	{
+		sample_t out;
+		switch( m_type )
+		{
+			case Moog:
+			{
+				sample_t x = _in0 - m_r*m_y4[_chnl];
+
+				// four cascaded onepole filters
+				// (bilinear transform)
+				m_y1[_chnl] = tLimit(
+						( x + m_oldx[_chnl] ) * m_p
+							- m_k * m_y1[_chnl],
+								-10.0f, 10.0f );
+				m_y2[_chnl] = tLimit(
+					( m_y1[_chnl] + m_oldy1[_chnl] ) * m_p
+							- m_k * m_y2[_chnl],
+								-10.0f, 10.0f );
+				m_y3[_chnl] = tLimit(
+					( m_y2[_chnl] + m_oldy2[_chnl] ) * m_p
+							- m_k * m_y3[_chnl],
+								-10.0f, 10.0f );
+				m_y4[_chnl] = tLimit(
+					( m_y3[_chnl] + m_oldy3[_chnl] ) * m_p
+							- m_k * m_y4[_chnl],
+								-10.0f, 10.0f );
+
+				m_oldx[_chnl] = x;
+				m_oldy1[_chnl] = m_y1[_chnl];
+				m_oldy2[_chnl] = m_y2[_chnl];
+				m_oldy3[_chnl] = m_y3[_chnl];
+				out = m_y4[_chnl] - m_y4[_chnl] * m_y4[_chnl] *
+						m_y4[_chnl] * ( 1.0f / 6.0f );
+				break;
+			}
+
+
+			// 4-times oversampled simulation of an active RC-Bandpass,-Lowpass,-Highpass-
+			// Filter-Network as it was used in nearly all modern analog synthesizers. This
+			// can be driven up to self-oscillation (BTW: do not remove the limits!!!).
+			// (C) 1998 ... 2009 S.Fendt. Released under the GPL v2.0  or any later version.
+
+			case Lowpass_RC12:
+			case Bandpass_RC12:
+			case Highpass_RC12:
+			{
+				sample_t lp, hp, bp;
+
+				sample_t in;
+
+				// 4-times oversampled... (even the moog-filter would benefit from this)
+				for( int n = 4; n != 0; --n )
+				{
+					in = _in0 + m_rcbp0[_chnl] * m_rcq;
+					in = (in > +1.f) ? +1.f : in;
+					in = (in < -1.f) ? -1.f : in;
+
+					lp = in * m_rcb + m_rclp0[_chnl] * m_rca;
+					lp = (lp > +1.f) ? +1.f : lp;
+					lp = (lp < -1.f) ? -1.f : lp;
+
+					hp = m_rcc * ( m_rchp0[_chnl] + in - m_rclast0[_chnl] );
+					hp = (hp > +1.f) ? +1.f : hp;
+					hp = (hp < -1.f) ? -1.f : hp;
+
+					bp = hp * m_rcb + m_rcbp0[_chnl] * m_rca;
+					bp = (bp > +1.f) ? +1.f : bp;
+					bp = (bp < -1.f) ? -1.f : bp;
+
+					m_rclast0[_chnl] = in;
+					m_rclp0[_chnl] = lp;
+					m_rchp0[_chnl] = hp;
+					m_rcbp0[_chnl] = bp;
+				}
+
+				if( m_type == Lowpass_RC12 )
+					out = lp;
+				else if( m_type == Bandpass_RC12 )
+					out = bp;
+				else
+					out = hp;
+				
+				return( out );
+				break;
+			}
+
+			case Lowpass_RC24:
+			case Bandpass_RC24:
+			case Highpass_RC24:
+			{
+				sample_t lp, hp, bp;
+
+				sample_t in;
+
+				for( int n = 4; n != 0; --n )
+				{
+					// first stage is as for the 12dB case...
+					in = _in0 + m_rcbp0[_chnl] * m_rcq;
+					in = (in > +1.f) ? +1.f : in;
+					in = (in < -1.f) ? -1.f : in;
+
+					lp = in * m_rcb + m_rclp0[_chnl] * m_rca;
+					lp = (lp > +1.f) ? +1.f : lp;
+					lp = (lp < -1.f) ? -1.f : lp;
+
+					hp = m_rcc * ( m_rchp0[_chnl] + in - m_rclast0[_chnl] );
+					hp = (hp > +1.f) ? +1.f : hp;
+					hp = (hp < -1.f) ? -1.f : hp;
+
+					bp = hp * m_rcb + m_rcbp0[_chnl] * m_rca;
+					bp = (bp > +1.f) ? +1.f : bp;
+					bp = (bp < -1.f) ? -1.f : bp;
+
+					m_rclast0[_chnl] = in;
+					m_rclp0[_chnl] = lp;
+					m_rchp0[_chnl] = hp;
+					m_rcbp0[_chnl] = bp;
+
+					// second stage gets the output of the first stage as input...
+					if( m_type == Lowpass_RC24 )
+					{
+						in = lp + m_rcbp1[_chnl] * m_rcq;
+					}
+					else if( m_type == Bandpass_RC24 )
+					{
+						in = bp + m_rcbp1[_chnl] * m_rcq;
+					}
+					else
+					{
+   						in = hp + m_rcbp1[_chnl] * m_rcq;
+					}
+					in = (in > +1.f) ? +1.f : in;
+					in = (in < -1.f) ? -1.f : in;
+
+					lp = in * m_rcb + m_rclp1[_chnl] * m_rca;
+					lp = (lp > +1.f) ? +1.f : lp;
+					lp = (lp < -1.f) ? -1.f : lp;
+
+					hp = m_rcc * ( m_rchp1[_chnl] + in - m_rclast1[_chnl] );
+					hp = (hp > +1.f) ? +1.f : hp;
+					hp = (hp < -1.f) ? -1.f : hp;
+
+					bp = hp * m_rcb + m_rcbp1[_chnl] * m_rca;
+					bp = (bp > +1.f) ? +1.f : bp;
+					bp = (bp < -1.f) ? -1.f : bp;
+
+					m_rclast1[_chnl] = in;
+					m_rclp1[_chnl] = lp;
+					m_rchp1[_chnl] = hp;
+					m_rcbp1[_chnl] = bp;
+				}
+
+				// output is second stage-lowpass...
+				if( m_type == Lowpass_RC24 )
+				{
+					out = lp;
+				}
+				else if( m_type == Bandpass_RC24 )
+				{
+					out = bp;
+				}
+				else
+				{
+					out = hp;
+				}
+			
+				return out;
+				break;
+			}
+
+			case Formantfilter:
+			{
+				sample_t lp, hp, bp, in;
+
+		out = 0;
+		for(int o=0; o<4; o++)
+		{
+			// first formant
+			in = _in0 + m_vfbp[0][_chnl] * m_vfq;
+			in = (in > +1.f) ? +1.f : in;
+			in = (in < -1.f) ? -1.f : in;
+
+			lp = in * m_vfb[0] + m_vflp[0][_chnl] * m_vfa[0];
+			lp = (lp > +1.f) ? +1.f : lp;
+			lp = (lp < -1.f) ? -1.f : lp;
+
+			hp = m_vfc[0] * ( m_vfhp[0][_chnl] + in - m_vflast[0][_chnl] );
+			hp = (hp > +1.f) ? +1.f : hp;
+			hp = (hp < -1.f) ? -1.f : hp;
+
+			bp = hp * m_vfb[0] + m_vfbp[0][_chnl] * m_vfa[0];
+			bp = (bp > +1.f) ? +1.f : bp;
+			bp = (bp < -1.f) ? -1.f : bp;
+
+			m_vflast[0][_chnl] = in;
+			m_vflp[0][_chnl] = lp;
+			m_vfhp[0][_chnl] = hp;
+			m_vfbp[0][_chnl] = bp;
+
+			in = bp + m_vfbp[2][_chnl] * m_vfq;
+			in = (in > +1.f) ? +1.f : in;
+			in = (in < -1.f) ? -1.f : in;
+
+			lp = in * m_vfb[0] + m_vflp[2][_chnl] * m_vfa[0];
+			lp = (lp > +1.f) ? +1.f : lp;
+			lp = (lp < -1.f) ? -1.f : lp;
+
+			hp = m_vfc[0] * ( m_vfhp[2][_chnl] + in - m_vflast[2][_chnl] );
+			hp = (hp > +1.f) ? +1.f : hp;
+			hp = (hp < -1.f) ? -1.f : hp;
+
+			bp = hp * m_vfb[0] + m_vfbp[2][_chnl] * m_vfa[0];
+			bp = (bp > +1.f) ? +1.f : bp;
+			bp = (bp < -1.f) ? -1.f : bp;
+
+			m_vflast[2][_chnl] = in;
+			m_vflp[2][_chnl] = lp;
+			m_vfhp[2][_chnl] = hp;
+			m_vfbp[2][_chnl] = bp;  
+			      
+			in = bp + m_vfbp[4][_chnl] * m_vfq;
+			in = (in > +1.f) ? +1.f : in;
+			in = (in < -1.f) ? -1.f : in;
+
+			lp = in * m_vfb[0] + m_vflp[4][_chnl] * m_vfa[0];
+			lp = (lp > +1.f) ? +1.f : lp;
+			lp = (lp < -1.f) ? -1.f : lp;
+
+			hp = m_vfc[0] * ( m_vfhp[4][_chnl] + in - m_vflast[4][_chnl] );
+			hp = (hp > +1.f) ? +1.f : hp;
+			hp = (hp < -1.f) ? -1.f : hp;
+
+			bp = hp * m_vfb[0] + m_vfbp[4][_chnl] * m_vfa[0];
+			bp = (bp > +1.f) ? +1.f : bp;
+			bp = (bp < -1.f) ? -1.f : bp;
+
+			m_vflast[4][_chnl] = in;
+			m_vflp[4][_chnl] = lp;
+			m_vfhp[4][_chnl] = hp;
+			m_vfbp[4][_chnl] = bp;  
+
+			out += bp;
+
+			// second formant
+			in = _in0 + m_vfbp[0][_chnl] * m_vfq;
+			in = (in > +1.f) ? +1.f : in;
+			in = (in < -1.f) ? -1.f : in;
+
+			lp = in * m_vfb[1] + m_vflp[1][_chnl] * m_vfa[1];
+			lp = (lp > +1.f) ? +1.f : lp;
+			lp = (lp < -1.f) ? -1.f : lp;
+
+			hp = m_vfc[1] * ( m_vfhp[1][_chnl] + in - m_vflast[1][_chnl] );
+			hp = (hp > +1.f) ? +1.f : hp;
+			hp = (hp < -1.f) ? -1.f : hp;
+
+			bp = hp * m_vfb[1] + m_vfbp[1][_chnl] * m_vfa[1];
+			bp = (bp > +1.f) ? +1.f : bp;
+			bp = (bp < -1.f) ? -1.f : bp;
+
+			m_vflast[1][_chnl] = in;
+			m_vflp[1][_chnl] = lp;
+			m_vfhp[1][_chnl] = hp;
+			m_vfbp[1][_chnl] = bp;
+
+			in = bp + m_vfbp[3][_chnl] * m_vfq;
+			in = (in > +1.f) ? +1.f : in;
+			in = (in < -1.f) ? -1.f : in;
+
+			lp = in * m_vfb[1] + m_vflp[3][_chnl] * m_vfa[1];
+			lp = (lp > +1.f) ? +1.f : lp;
+			lp = (lp < -1.f) ? -1.f : lp;
+
+			hp = m_vfc[1] * ( m_vfhp[3][_chnl] + in - m_vflast[3][_chnl] );
+			hp = (hp > +1.f) ? +1.f : hp;
+			hp = (hp < -1.f) ? -1.f : hp;
+
+			bp = hp * m_vfb[1] + m_vfbp[3][_chnl] * m_vfa[1];
+			bp = (bp > +1.f) ? +1.f : bp;
+			bp = (bp < -1.f) ? -1.f : bp;
+
+			m_vflast[3][_chnl] = in;
+			m_vflp[3][_chnl] = lp;
+			m_vfhp[3][_chnl] = hp;
+			m_vfbp[3][_chnl] = bp;  
+
+			in = bp + m_vfbp[5][_chnl] * m_vfq;
+			in = (in > +1.f) ? +1.f : in;
+			in = (in < -1.f) ? -1.f : in;
+
+			lp = in * m_vfb[1] + m_vflp[5][_chnl] * m_vfa[1];
+			lp = (lp > +1.f) ? +1.f : lp;
+			lp = (lp < -1.f) ? -1.f : lp;
+
+			hp = m_vfc[1] * ( m_vfhp[5][_chnl] + in - m_vflast[5][_chnl] );
+			hp = (hp > +1.f) ? +1.f : hp;
+			hp = (hp < -1.f) ? -1.f : hp;
+
+			bp = hp * m_vfb[1] + m_vfbp[5][_chnl] * m_vfa[1];
+			bp = (bp > +1.f) ? +1.f : bp;
+			bp = (bp < -1.f) ? -1.f : bp;
+
+			m_vflast[5][_chnl] = in;
+			m_vflp[5][_chnl] = lp;
+			m_vfhp[5][_chnl] = hp;
+			m_vfbp[5][_chnl] = bp;  
+
+			out += bp;
+            }
+            
+				return( out/2.0f );
+				break;
+			}
+			
+			default:
+				// filter
+				out = m_b0a0*_in0 +
+						m_b1a0*m_in1[_chnl] +
+						m_b2a0*m_in2[_chnl] -
+						m_a1a0*m_ou1[_chnl] -
+						m_a2a0*m_ou2[_chnl];
+
+				// push in/out buffers
+				m_in2[_chnl] = m_in1[_chnl];
+				m_in1[_chnl] = _in0;
+				m_ou2[_chnl] = m_ou1[_chnl];
+
+				m_ou1[_chnl] = out;
+				break;
+		}
+
+		if( m_doubleFilter )
+		{
+			return m_subFilter->update( out, _chnl );
+		}
+
+		// Clipper band limited sigmoid
+		return out;
+	}
+
+
+	inline void calcFilterCoeffs( float _freq, float _q
+				/*, const bool _q_is_bandwidth = false*/ )
+	{
+		// temp coef vars
+		_freq = qBound(minFreq(), _freq, 20000.0f); // limit freq and q for not getting
+                                                            // bad noise out of the filter...
+
+		_q = qMax( _q, minQ() );
+
+		if( m_type == Lowpass_RC12  ||
+			m_type == Bandpass_RC12 ||
+			m_type == Highpass_RC12 ||
+			m_type == Lowpass_RC24 ||
+			m_type == Bandpass_RC24 ||
+			m_type == Highpass_RC24 )
+		{
+			if( _freq < 50.f )
+			{
+				_freq = 50.f;
+			}
+		
+			m_rca = 1.0f - (1.0f/(m_sampleRate*4)) / ( (1.0f/(_freq*2.0f*M_PI)) + (1.0f/(m_sampleRate*4)) );
+			m_rcb = 1.0f - m_rca;
+			m_rcc = (1.0f/(_freq*2.0f*M_PI)) / ( (1.0f/(_freq*2.0f*M_PI)) + (1.0f/(m_sampleRate*4)) );
+			
+			// Stretch Q/resonance, as self-oscillation reliably starts at a q of ~2.5 - ~2.6
+			m_rcq = _q/4.f;
+		}
+
+		if( m_type == Formantfilter )
+		{
+			// formats for a, e, i, o, u, a
+			const float _f[5][2] = { { 1000, 1400 }, { 500, 2300 },
+							{ 320, 3200 },
+							{ 500, 1000 },
+							{ 320, 800 } };
+
+			// Stretch Q/resonance
+			m_vfq = _q/4.f;
+
+			// frequency in lmms ranges from 1Hz to 14000Hz
+			const int vowel = (int)( floor( _freq/14000.f * 4.f ) );
+			const float fract = ( _freq/14000.f * 4.f ) -
+								(float)vowel;
+
+			// interpolate between formant frequencies         
+			const float f0 = _f[vowel+0][0] * ( 1.0f - fract ) + 
+						_f[vowel+1][0] * ( fract );
+
+			const float f1 = _f[vowel+0][1] * ( 1.0f - fract ) + 
+						_f[vowel+1][1] * ( fract );
+
+			m_vfa[0] = 1.0f - (1.0f/(m_sampleRate*4)) /
+						( (1.0f/(f0*2.0f*M_PI)) +
+						(1.0f/(m_sampleRate*4)) );
+			m_vfb[0] = 1.0f - m_vfa[0];
+			m_vfc[0] = (1.0f/(f0*2.0f*M_PI)) /
+						( (1.0f/(f0*2.0f*M_PI)) +
+						(1.0f/(m_sampleRate*4)) );
+
+			m_vfa[1] = 1.0f - (1.0f/(m_sampleRate*4)) /
+						( (1.0f/(f1*2.0f*M_PI)) +
+						(1.0f/(m_sampleRate*4)) );
+			m_vfb[1] = 1.0f - m_vfa[1];
+			m_vfc[1] = (1.0f/(f1*2.0f*M_PI)) /
+					( (1.0f/(f1*2.0f*M_PI)) +
+						(1.0f/(m_sampleRate*4)) );
+		}
+		
+		if( m_type == Moog )
+		{
+			// [ 0 - 0.5 ]
+			const float f = _freq / m_sampleRate;
+			// (Empirical tunning)
+			m_p = ( 3.6f - 3.2f * f ) * f;
+			m_k = 2.0f * m_p - 1;
+			m_r = _q * powf( M_E, ( 1 - m_p ) * 1.386249f );
+
+			if( m_doubleFilter )
+			{
+				m_subFilter->m_r = m_r;
+				m_subFilter->m_p = m_p;
+				m_subFilter->m_k = m_k;
+			}
+			return;
+		}
+
+		// other filters
+		const float omega = F_2PI * _freq / m_sampleRate;
+		const float tsin = sinf( omega );
+		const float tcos = cosf( omega );
+		//float alpha;
+
+		//if (q_is_bandwidth)
+		//alpha = tsin*sinhf(logf(2.0f)/2.0f*q*omega/
+		//					tsin);
+		//else
+		const float alpha = 0.5f * tsin / _q;
+
+		const float a0 = 1.0f / ( 1.0f + alpha );
+
+		m_a1a0 = -2.0f * tcos * a0;
+		m_a2a0 = ( 1.0f - alpha ) * a0;
+
+		switch( m_type )
+		{
+			case LowPass:
+				m_b1a0 = ( 1.0f - tcos ) * a0;
+				m_b0a0 = m_b1a0 * 0.5f;
+				m_b2a0 = m_b0a0;//((1.0f-tcos)/2.0f)*a0;
+				break;
+			case HiPass:
+				m_b1a0 = ( -1.0f - tcos ) * a0;
+				m_b0a0 = m_b1a0 * -0.5f;
+				m_b2a0 = m_b0a0;//((1.0f+tcos)/2.0f)*a0;
+				break;
+			case BandPass_CSG:
+				m_b1a0 = 0.0f;
+				m_b0a0 = tsin * 0.5f * a0;
+				m_b2a0 = -m_b0a0;
+				break;
+			case BandPass_CZPG:
+				m_b1a0 = 0.0f;
+				m_b0a0 = alpha * a0;
+				m_b2a0 = -m_b0a0;
+				break;
+			case Notch:
+				m_b1a0 = m_a1a0;
+				m_b0a0 = a0;
+				m_b2a0 = a0;
+				break;
+			case AllPass:
+				m_b1a0 = m_a1a0;
+				m_b0a0 = m_a2a0;
+				m_b2a0 = 1.0f;//(1.0f+alpha)*a0;
+				break;
+			default:
+				break;
+		}
+
+		if( m_doubleFilter )
+		{
+			m_subFilter->m_b0a0 = m_b0a0;
+			m_subFilter->m_b1a0 = m_b1a0;
+			m_subFilter->m_b2a0 = m_b2a0;
+			m_subFilter->m_a1a0 = m_a1a0;
+			m_subFilter->m_a2a0 = m_a2a0;
+		}
+	}
+
+
+private:
+	// filter coeffs
+	float m_b0a0, m_b1a0, m_b2a0, m_a1a0, m_a2a0;
+
+	// coeffs for moog-filter
+	float m_r, m_p, m_k;
+
+	// coeffs for RC-type-filters
+	float m_rca, m_rcb, m_rcc, m_rcq;
+
+	// coeffs for formant-filters
+	float m_vfa[4], m_vfb[4], m_vfc[4], m_vfq;
+	
+	typedef sample_t frame[CHANNELS];
+
+	// in/out history
+	frame m_ou1, m_ou2, m_in1, m_in2;
+
+	// in/out history for moog-filter
+	frame m_y1, m_y2, m_y3, m_y4, m_oldx, m_oldy1, m_oldy2, m_oldy3;
+	
+	// in/out history for RC-type-filters
+	frame m_rcbp0, m_rclp0, m_rchp0, m_rclast0;
+	frame m_rcbp1, m_rclp1, m_rchp1, m_rclast1;
+
+	// in/out history for Formant-filters
+	frame m_vfbp[6], m_vflp[6], m_vfhp[6], m_vflast[6];
+	
+	FilterTypes m_type;
+	bool m_doubleFilter;
+
+	float m_sampleRate;
+	basicFilters<CHANNELS> * m_subFilter;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/bb_editor.h b/lmms/include/bb_editor.h
new file mode 100644
index 0000000..c1ebd96
--- /dev/null
+++ b/lmms/include/bb_editor.h
@@ -0,0 +1,76 @@
+/*
+ * bb_editor.h - view-component of BB-Editor
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _BB_EDITOR_H
+#define _BB_EDITOR_H
+
+#include "TrackContainerView.h"
+
+
+class bbTrackContainer;
+class comboBox;
+class toolButton;
+
+
+class bbEditor : public TrackContainerView
+{
+	Q_OBJECT
+public:
+	bbEditor( bbTrackContainer * _tc );
+	virtual ~bbEditor();
+
+	virtual inline bool fixedTCOs() const
+	{
+		return( true );
+	}
+
+	void removeBBView( int _bb );
+
+	void setPauseIcon( bool pause );
+
+
+public slots:
+	void play();
+	void stop();
+	void updatePosition();
+	void addAutomationTrack();
+	void addSteps();
+	void removeSteps();
+
+private:
+	virtual void keyPressEvent( QKeyEvent * _ke );
+
+	bbTrackContainer * m_bbtc;
+	QWidget * m_toolBar;
+
+	toolButton * m_playButton;
+	toolButton * m_stopButton;
+
+	comboBox * m_bbComboBox;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/bb_track.h b/lmms/include/bb_track.h
new file mode 100644
index 0000000..d951ea9
--- /dev/null
+++ b/lmms/include/bb_track.h
@@ -0,0 +1,189 @@
+/*
+ * bb_track.h - class bbTrack, a wrapper for using bbEditor
+ *              (which is a singleton-class) as track
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef BB_TRACK_H
+#define BB_TRACK_H
+
+#include <QtCore/QObject>
+#include <QtCore/QMap>
+
+#include "track.h"
+
+class trackLabelButton;
+class TrackContainer;
+
+
+class bbTCO : public trackContentObject
+{
+public:
+	bbTCO( track * _track, unsigned int _color = 0 );
+	virtual ~bbTCO();
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+	inline virtual QString nodeName() const
+	{
+		return( "bbtco" );
+	}
+
+	inline unsigned int color() const
+	{
+		return( m_color );
+	}
+	inline static unsigned int defaultColor()
+	{
+		return qRgb( 128, 182, 175 );
+	}
+
+	virtual trackContentObjectView * createView( trackView * _tv );
+
+private:
+	unsigned int m_color;
+
+
+	friend class bbTCOView;
+
+} ;
+
+
+
+class bbTCOView : public trackContentObjectView
+{
+	Q_OBJECT
+public:
+	bbTCOView( trackContentObject * _tco, trackView * _tv );
+	virtual ~bbTCOView();
+
+	QColor color() const
+	{
+		return( m_bbTCO->m_color );
+	}
+	void setColor( QColor _new_color );
+
+
+protected slots:
+	void openInBBEditor();
+	void resetName();
+	void changeName();
+	void changeColor();
+
+
+protected:
+	void paintEvent( QPaintEvent * );
+	void mouseDoubleClickEvent( QMouseEvent * _me );
+	virtual void constructContextMenu( QMenu * );
+
+
+private:
+	bbTCO * m_bbTCO;
+
+} ;
+
+
+
+
+class EXPORT bbTrack : public track
+{
+	Q_OBJECT
+public:
+	bbTrack( TrackContainer* tc );
+	virtual ~bbTrack();
+
+	virtual bool play( const MidiTime & _start, const fpp_t _frames,
+						const f_cnt_t _frame_base, int _tco_num = -1 );
+	virtual trackView * createView( TrackContainerView* tcv );
+	virtual trackContentObject * createTCO( const MidiTime & _pos );
+
+	virtual void saveTrackSpecificSettings( QDomDocument & _doc,
+							QDomElement & _parent );
+	virtual void loadTrackSpecificSettings( const QDomElement & _this );
+
+	static bbTrack * findBBTrack( int _bb_num );
+	static int numOfBBTrack( track * _track );
+	static void swapBBTracks( track * _track1, track * _track2 );
+
+	bool automationDisabled( track * _track )
+	{
+		return( m_disabledTracks.contains( _track ) );
+	}
+	void disableAutomation( track * _track )
+	{
+		m_disabledTracks.append( _track );
+	}
+	void enableAutomation( track * _track )
+	{
+		m_disabledTracks.removeAll( _track );
+	}
+
+
+protected:
+	inline virtual QString nodeName() const
+	{
+		return( "bbtrack" );
+	}
+
+
+private:
+	QList<track *> m_disabledTracks;
+
+	typedef QMap<bbTrack *, int> infoMap;
+	static infoMap s_infoMap;
+
+
+	friend class bbTrackView;
+
+} ;
+
+
+
+class bbTrackView : public trackView
+{
+	Q_OBJECT
+public:
+	bbTrackView( bbTrack* bbt, TrackContainerView* tcv );
+	virtual ~bbTrackView();
+
+	virtual bool close();
+
+	const bbTrack * getBBTrack() const
+	{
+		return( m_bbTrack );
+	}
+
+
+public slots:
+	void clickedTrackLabel();
+
+
+private:
+	bbTrack * m_bbTrack;
+	trackLabelButton * m_trackLabel;
+
+} ;
+
+
+
+#endif
diff --git a/lmms/include/bb_track_container.h b/lmms/include/bb_track_container.h
new file mode 100644
index 0000000..3ad0b91
--- /dev/null
+++ b/lmms/include/bb_track_container.h
@@ -0,0 +1,82 @@
+/*
+ * bb_track_container.h - model-component of BB-Editor
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _BB_TRACK_CONTAINER_H
+#define _BB_TRACK_CONTAINER_H
+
+#include "TrackContainer.h"
+#include "combobox.h"
+
+
+class EXPORT bbTrackContainer : public TrackContainer
+{
+	Q_OBJECT
+	mapPropertyFromModel(int,currentBB,setCurrentBB,m_bbComboBoxModel);
+public:
+	bbTrackContainer();
+	virtual ~bbTrackContainer();
+
+	virtual bool play( MidiTime _start, const fpp_t _frames,
+						const f_cnt_t _frame_base, int _tco_num = -1 );
+
+	virtual void updateAfterTrackAdd();
+
+	inline virtual QString nodeName() const
+	{
+		return "bbtrackcontainer";
+	}
+
+	tact_t lengthOfBB( int _bb );
+	inline tact_t lengthOfCurrentBB()
+	{
+		return lengthOfBB( currentBB() );
+	}
+	int numOfBBs() const;
+	void removeBB( int _bb );
+
+	void swapBB( int _bb1, int _bb2 );
+
+	void updateBBTrack( trackContentObject * _tco );
+	void fixIncorrectPositions();
+	void createTCOsForBB( int _bb );
+
+
+public slots:
+	void play();
+	void stop();
+	void updateComboBox();
+	void currentBBChanged();
+
+
+private:
+	ComboBoxModel m_bbComboBoxModel;
+
+
+	friend class bbEditor;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/caption_menu.h b/lmms/include/caption_menu.h
new file mode 100644
index 0000000..e6bce5f
--- /dev/null
+++ b/lmms/include/caption_menu.h
@@ -0,0 +1,46 @@
+/*
+ * caption_menu.h - context menu with a caption
+ *
+ * Copyright (c) 2007-2008 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _CAPTION_MENU_H
+#define _CAPTION_MENU_H
+
+#include <QtGui/QMenu>
+
+#include "export.h"
+
+
+class EXPORT captionMenu : public QMenu
+{
+	Q_OBJECT
+public:
+	captionMenu( const QString & _title, QWidget * _parent = 0 );
+	virtual ~captionMenu();
+
+} ;
+
+
+
+
+#endif
diff --git a/lmms/include/combobox.h b/lmms/include/combobox.h
new file mode 100644
index 0000000..76bb361
--- /dev/null
+++ b/lmms/include/combobox.h
@@ -0,0 +1,79 @@
+/*
+ * combobox.h - class ComboBox, a combo box view for models
+ *
+ * Copyright (c) 2006-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _COMBOBOX_H
+#define _COMBOBOX_H
+
+#include <QtGui/QMenu>
+#include <QtGui/QWidget>
+
+#include "ComboBoxModel.h"
+#include "AutomatableModelView.h"
+
+
+
+class EXPORT comboBox : public QWidget, public IntModelView
+{
+	Q_OBJECT
+public:
+	comboBox( QWidget* parent = NULL, const QString& name = QString() );
+	virtual ~comboBox();
+
+	ComboBoxModel* model()
+	{
+		return castModel<ComboBoxModel>();
+	}
+
+	const ComboBoxModel* model() const
+	{
+		return castModel<ComboBoxModel>();
+	}
+
+	virtual QSize sizeHint() const;
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent* event );
+	virtual void mousePressEvent( QMouseEvent* event );
+	virtual void paintEvent( QPaintEvent* event );
+	virtual void wheelEvent( QWheelEvent* event );
+
+
+private:
+	static QPixmap* s_background;
+	static QPixmap* s_arrow;
+	static QPixmap* s_arrowSelected;
+
+	QMenu m_menu;
+
+	bool m_pressed;
+
+
+private slots:
+	void setItem( QAction* item );
+
+} ;
+
+#endif
diff --git a/lmms/include/config_mgr.h b/lmms/include/config_mgr.h
new file mode 100644
index 0000000..ec3babf
--- /dev/null
+++ b/lmms/include/config_mgr.h
@@ -0,0 +1,222 @@
+/*
+ * config_mgr.h - class configManager, a class for managing LMMS-configuration
+ *
+ * Copyright (c) 2005-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _CONFIG_MGR_H
+#define _CONFIG_MGR_H
+
+#include "lmmsconfig.h"
+
+#include <QtCore/QMap>
+#include <QtCore/QPair>
+#include <QtCore/QStringList>
+#include <QtCore/QVector>
+
+#include "export.h"
+
+
+class engine;
+
+
+const QString PROJECTS_PATH = "projects/";
+const QString PRESETS_PATH = "presets/";
+const QString SAMPLES_PATH = "samples/";
+const QString DEFAULT_THEME_PATH = "themes/default/";
+const QString TRACK_ICON_PATH = "track_icons/";
+const QString LOCALE_PATH = "locale/";
+
+
+class EXPORT configManager
+{
+public:
+	static inline configManager * inst()
+	{
+		if( s_instanceOfMe == NULL )
+		{
+			s_instanceOfMe = new configManager();
+		}
+		return( s_instanceOfMe );
+	}
+
+	const QString & dataDir() const
+	{
+		return( m_dataDir );
+	}
+
+	const QString & workingDir() const
+	{
+		return( m_workingDir );
+	}
+
+	QString userProjectsDir() const
+	{
+		return( workingDir() + PROJECTS_PATH );
+	}
+
+	QString userPresetsDir() const
+	{
+		return( workingDir() + PRESETS_PATH );
+	}
+
+	QString userSamplesDir() const
+	{
+		return( workingDir() + SAMPLES_PATH );
+	}
+
+	QString factoryProjectsDir() const
+	{
+		return( dataDir() + PROJECTS_PATH );
+	}
+
+	QString factoryPresetsDir() const
+	{
+		return( dataDir() + PRESETS_PATH );
+	}
+
+	QString factorySamplesDir() const
+	{
+		return( dataDir() + SAMPLES_PATH );
+	}
+
+	QString defaultArtworkDir() const
+	{
+		return( m_dataDir + DEFAULT_THEME_PATH );
+	}
+
+	QString artworkDir() const
+	{
+		return( m_artworkDir );
+	}
+
+	QString trackIconsDir() const
+	{
+		return( m_dataDir + TRACK_ICON_PATH );
+	}
+
+	QString localeDir() const
+	{
+		return( m_dataDir + LOCALE_PATH );
+	}
+
+	const QString & pluginDir() const
+	{
+		return( m_pluginDir );
+	}
+
+	const QString & vstDir() const
+	{
+		return( m_vstDir );
+	}
+
+	const QString & flDir() const
+	{
+		return( m_flDir );
+	}
+
+	const QString & ladspaDir() const
+	{
+		return( m_ladDir );
+	}
+
+#ifdef LMMS_HAVE_STK
+	const QString & stkDir() const
+	{
+		return( m_stkDir );
+	}
+#endif
+
+#ifdef LMMS_HAVE_FLUIDSYNTH
+	const QString & defaultSoundfont() const
+	{
+		return( m_defaultSoundfont );
+	}
+#endif
+
+	const QString & backgroundArtwork() const
+	{
+		return( m_backgroundArtwork );
+	}
+
+	inline const QStringList & recentlyOpenedProjects() const
+	{
+		return( m_recentlyOpenedProjects );
+	}
+
+	void addRecentlyOpenedProject( const QString & _file );
+
+	const QString & value( const QString & _class,
+					const QString & _attribute ) const;
+	void setValue( const QString & _class, const QString & _attribute,
+						const QString & _value );
+
+	void loadConfigFile();
+	void saveConfigFile();
+
+
+	void setWorkingDir( const QString & _wd );
+	void setVSTDir( const QString & _vd );
+	void setArtworkDir( const QString & _ad );
+	void setFLDir( const QString & _fd );
+	void setLADSPADir( const QString & _fd );
+	void setSTKDir( const QString & _fd );
+	void setDefaultSoundfont( const QString & _sf );
+	void setBackgroundArtwork( const QString & _ba );
+
+
+private:
+	static configManager * s_instanceOfMe;
+
+	configManager();
+	configManager( const configManager & _c );
+	~configManager();
+
+
+	const QString m_lmmsRcFile;
+	QString m_workingDir;
+	QString m_dataDir;
+	QString m_artworkDir;
+	QString m_pluginDir;
+	QString m_vstDir;
+	QString m_flDir;
+	QString m_ladDir;
+#ifdef LMMS_HAVE_STK
+	QString m_stkDir;
+#endif
+#ifdef LMMS_HAVE_FLUIDSYNTH
+	QString m_defaultSoundfont;
+#endif
+	QString m_backgroundArtwork;
+	QStringList m_recentlyOpenedProjects;
+
+
+	typedef QVector<QPair<QString, QString> > stringPairVector;
+	typedef QMap<QString, stringPairVector> settingsMap;
+	settingsMap m_settings;
+
+
+	friend class engine;
+
+} ;
+
+#endif
diff --git a/lmms/include/cpuload_widget.h b/lmms/include/cpuload_widget.h
new file mode 100644
index 0000000..096307c
--- /dev/null
+++ b/lmms/include/cpuload_widget.h
@@ -0,0 +1,67 @@
+/*
+ * cpuload_widget.h - widget for displaying CPU-load (partly based on
+ *                    Hydrogen's CPU-load-widget)
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _CPULOAD_WIDGET_H
+#define _CPULOAD_WIDGET_H
+
+#include <QtCore/QTimer>
+#include <QtGui/QPixmap>
+#include <QtGui/QWidget>
+
+#include "lmms_basics.h"
+
+
+class cpuloadWidget : public QWidget
+{
+	Q_OBJECT
+public:
+	cpuloadWidget( QWidget * _parent );
+	virtual ~cpuloadWidget();
+
+
+protected:
+	virtual void paintEvent( QPaintEvent * _ev );
+
+
+protected slots:
+	void updateCpuLoad();
+
+
+private:
+	int m_currentLoad;
+
+	QPixmap m_temp;
+	QPixmap m_background;
+	QPixmap m_leds;
+
+	bool m_changed;
+
+	QTimer m_updateTimer;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/custom_events.h b/lmms/include/custom_events.h
new file mode 100644
index 0000000..0050a79
--- /dev/null
+++ b/lmms/include/custom_events.h
@@ -0,0 +1,46 @@
+/*
+ * custom_events.h - custom event types list
+ *
+ * Copyright (c) 2007 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _CUSTOM_EVENTS_H
+#define _CUSTOM_EVENTS_H
+
+
+#include <QtCore/QEvent>
+
+
+namespace customEvents
+{
+
+	enum Type
+	{
+		GUI_UPDATE = QEvent::User
+	} ;
+
+}
+
+
+
+
+#endif
diff --git a/lmms/include/debug.h b/lmms/include/debug.h
new file mode 100644
index 0000000..64b1a88
--- /dev/null
+++ b/lmms/include/debug.h
@@ -0,0 +1,42 @@
+/*
+ * debug.h - header file to be included for debugging purposes
+ *
+ * Copyright (c) 2004-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _DEBUG_H
+#define _DEBUG_H
+
+#include "lmmsconfig.h"
+
+// set whether debug-stuff (like messages on the console, asserts and other
+// additional range-checkings) should be compiled
+
+#ifdef LMMS_DEBUG
+	#include <assert.h>
+#else
+	#define assert(x) ((void)(x))
+#endif
+#include <cstdio>
+
+
+#endif
diff --git a/lmms/include/drumsynth.h b/lmms/include/drumsynth.h
new file mode 100644
index 0000000..ebbc26a
--- /dev/null
+++ b/lmms/include/drumsynth.h
@@ -0,0 +1,52 @@
+/*
+ * drumsynth.h - DrumSynth DS file renderer
+ *
+ * Copyright (c) 1998-2000 Paul Kellett (mda-vst.com)
+ * Copyright (c) 2007 Paul Giblock <drfaygo/at/gmail.com>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _DRUMSYNTH_H__
+#define _DRUMSYNTH_H__
+
+#include <stdint.h>
+#include "lmms_basics.h"
+
+class DrumSynth {
+    public:
+        DrumSynth() {};
+        int GetDSFileSamples(const char *dsfile, int16_t *&wave, int channels, sample_rate_t Fs);
+
+    private:
+        float LoudestEnv(void);
+        int   LongestEnv(void);
+        void  UpdateEnv(int e, long t);
+        void  GetEnv(int env, const char *sec, const char *key, const char *ini);
+
+        float waveform(float ph, int form);
+        
+        int GetPrivateProfileString(const char *sec, const char *key, const char *def, char *buffer, int size, const char *file);
+        int GetPrivateProfileInt(const char *sec, const char *key, int def, const char *file);
+        float GetPrivateProfileFloat(const char *sec, const char *key, float def, const char *file);
+
+};
+
+#endif 
diff --git a/lmms/include/embed.h b/lmms/include/embed.h
new file mode 100644
index 0000000..3aa9c8a
--- /dev/null
+++ b/lmms/include/embed.h
@@ -0,0 +1,130 @@
+/*
+ * embed.h - misc. stuff for using embedded data (resources linked into binary)
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _EMBED_H
+#define _EMBED_H
+
+#include <QtGui/QPixmap>
+#include <QtCore/QString>
+
+#include "export.h"
+#include "lmms_basics.h"
+
+
+namespace embed
+{
+
+struct descriptor
+{
+	int size;
+	const unsigned char * data;
+	const char * name;
+} ;
+
+
+QPixmap EXPORT getIconPixmap( const char *  _name, int _w = -1, int _h = -1 );
+QString EXPORT getText( const char * _name );
+
+}
+
+
+#ifdef PLUGIN_NAME
+namespace PLUGIN_NAME
+{
+
+QPixmap getIconPixmap( const char *  _name, int _w = -1, int _h = -1 );
+//QString getText( const char * _name );
+
+}
+#endif
+
+
+
+class PixmapLoader
+{
+public:
+	PixmapLoader( const PixmapLoader * _ref ) :
+		m_name( _ref != NULL ? _ref->m_name : QString::null )
+	{
+	}
+
+	PixmapLoader( const QString & _name = QString::null ) :
+		m_name( _name )
+	{
+	}
+
+	virtual QPixmap pixmap() const
+	{
+		if( !m_name.isEmpty() )
+		{
+			return( embed::getIconPixmap(
+					m_name.toAscii().constData() ) );
+		}
+		return( QPixmap() );
+	}
+
+	virtual ~PixmapLoader()
+	{
+	}
+
+	virtual QString pixmapName() const
+	{
+		return m_name;
+	}
+
+protected:
+	QString m_name;
+} ;
+
+
+#ifdef PLUGIN_NAME
+class PluginPixmapLoader : public PixmapLoader
+{
+public:
+	PluginPixmapLoader( const QString & _name = QString::null ) :
+		PixmapLoader( _name )
+	{
+	}
+
+	virtual QPixmap pixmap() const
+	{
+		if( !m_name.isEmpty() )
+		{
+			return( PLUGIN_NAME::getIconPixmap(
+					m_name.toAscii().constData() ) );
+		}
+		return( QPixmap() );
+	}
+
+	virtual QString pixmapName() const
+	{
+		return QString( STRINGIFY(PLUGIN_NAME) ) + "::" + m_name;
+	}
+
+} ;
+#endif
+
+
+
+#endif
diff --git a/lmms/include/endian_handling.h b/lmms/include/endian_handling.h
new file mode 100644
index 0000000..0181426
--- /dev/null
+++ b/lmms/include/endian_handling.h
@@ -0,0 +1,53 @@
+/*
+ * endian_handling.h - handle endianess
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _ENDIAN_HANDLING_H
+#define _ENDIAN_HANDLING_H
+
+#include <QtCore/QSysInfo>
+
+#include "lmms_basics.h"
+
+
+inline bool isLittleEndian()
+{
+	return( QSysInfo::ByteOrder == QSysInfo::LittleEndian );
+}
+
+
+inline int16_t swap16IfBE( int16_t i )
+{
+	return( isLittleEndian() ? i : ( ( i & 0xFF ) << 8) | ( ( i >> 8 ) & 0xFF ) );
+}
+
+
+inline int32_t swap32IfBE( int32_t i )
+{
+	return( isLittleEndian() ? i : ( ( i & 0xff000000 ) >> 24 ) |
+					( ( i & 0x00ff0000 ) >> 8 )  |
+					( ( i & 0x0000ff00 ) << 8 )  |
+					( ( i & 0x000000ff ) << 24 ) );
+}
+
+#endif
diff --git a/lmms/include/engine.h b/lmms/include/engine.h
new file mode 100644
index 0000000..a4fc34c
--- /dev/null
+++ b/lmms/include/engine.h
@@ -0,0 +1,205 @@
+/*
+ * engine.h - engine-system of LMMS
+ *
+ * Copyright (c) 2006-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _ENGINE_H
+#define _ENGINE_H
+
+#include "lmmsconfig.h"
+
+#include <QtCore/QMap>
+
+#include "export.h"
+
+class AutomationEditor;
+class bbEditor;
+class bbTrackContainer;
+class DummyTrackContainer;
+class FxMixer;
+class FxMixerView;
+class ProjectJournal;
+class MainWindow;
+class Mixer;
+class PianoRoll;
+class projectNotes;
+class song;
+class SongEditor;
+class ladspa2LMMS;
+class ControllerRackView;
+
+
+class EXPORT engine
+{
+public:
+	static void init( const bool _has_gui = true );
+	static void destroy();
+
+	static bool hasGUI()
+	{
+		return s_hasGUI;
+	}
+
+	static void setSuppressMessages( bool _on )
+	{
+		s_suppressMessages = _on;
+	}
+
+	static bool suppressMessages()
+	{
+		return !s_hasGUI || s_suppressMessages;
+	}
+
+	// core
+	static Mixer *mixer()
+	{
+		return s_mixer;
+	}
+
+	static FxMixer * fxMixer()
+	{
+		return s_fxMixer;
+	}
+
+	static song * getSong()
+	{
+		return s_song;
+	}
+
+	static bbTrackContainer * getBBTrackContainer()
+	{
+		return s_bbTrackContainer;
+	}
+
+	static ProjectJournal * projectJournal()
+	{
+		return s_projectJournal;
+	}
+
+	// GUI
+	static MainWindow * mainWindow()
+	{
+		return s_mainWindow;
+	}
+
+	static FxMixerView * fxMixerView()
+	{
+		return s_fxMixerView;
+	}
+
+	static SongEditor* songEditor()
+	{
+		return s_songEditor;
+	}
+
+	static bbEditor * getBBEditor()
+	{
+		return s_bbEditor;
+	}
+
+	static PianoRoll* pianoRoll()
+	{
+		return s_pianoRoll;
+	}
+
+	static projectNotes * getProjectNotes()
+	{
+		return s_projectNotes;
+	}
+
+	static AutomationEditor * automationEditor()
+	{
+		return s_automationEditor;
+	}
+
+	static ladspa2LMMS * getLADSPAManager()
+	{
+		return s_ladspaManager;
+	}
+
+	static DummyTrackContainer * dummyTrackContainer()
+	{
+		return s_dummyTC;
+	}
+
+	static ControllerRackView * getControllerRackView()
+	{
+		return s_controllerRackView;
+	}
+
+	static float framesPerTick()
+	{
+		return s_framesPerTick;
+	}
+	static void updateFramesPerTick();
+
+	static const QMap<QString, QString> & pluginFileHandling()
+	{
+		return s_pluginFileHandling;
+	}
+
+
+private:
+	// small helper function which sets the pointer to NULL before actually deleting
+	// the object it refers to
+	template<class T>
+	static inline void deleteHelper( T * * ptr )
+	{
+		T * tmp = *ptr;
+		*ptr = NULL;
+		delete tmp;
+	}
+
+	static bool s_hasGUI;
+	static bool s_suppressMessages;
+	static float s_framesPerTick;
+
+	// core
+	static Mixer *s_mixer;
+	static FxMixer * s_fxMixer;
+	static song * s_song;
+	static bbTrackContainer * s_bbTrackContainer;
+	static ProjectJournal * s_projectJournal;
+	static DummyTrackContainer * s_dummyTC;
+	static ControllerRackView * s_controllerRackView;
+
+	// GUI
+	static MainWindow * s_mainWindow;
+	static FxMixerView * s_fxMixerView;
+	static SongEditor* s_songEditor;
+	static AutomationEditor * s_automationEditor;
+	static bbEditor * s_bbEditor;
+	static PianoRoll* s_pianoRoll;
+	static projectNotes * s_projectNotes;
+	static ladspa2LMMS * s_ladspaManager;
+
+	static QMap<QString, QString> s_pluginFileHandling;
+
+	static void initPluginFileHandling();
+
+} ;
+
+
+
+
+#endif
diff --git a/lmms/include/export.h b/lmms/include/export.h
new file mode 100644
index 0000000..4249754
--- /dev/null
+++ b/lmms/include/export.h
@@ -0,0 +1,47 @@
+/*
+ * export.h - macros for export-declarations
+ *
+ * Copyright (c) 2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _EXPORT_H
+#define _EXPORT_H
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_BUILD_WIN32
+
+#ifdef PLUGIN_NAME
+#define EXPORT __declspec(dllimport)
+#define PLUGIN_EXPORT __declspec(dllexport)
+#else
+#define EXPORT __declspec(dllexport)
+#endif
+
+#else
+
+#define EXPORT
+#define PLUGIN_EXPORT
+
+#endif
+
+#endif
diff --git a/lmms/include/export_project_dialog.h b/lmms/include/export_project_dialog.h
new file mode 100644
index 0000000..5b906e0
--- /dev/null
+++ b/lmms/include/export_project_dialog.h
@@ -0,0 +1,75 @@
+/*
+ * export_project_dialog.h - declaration of class exportProjectDialog which is
+ *                           responsible for exporting project
+ *
+ * Copyright (c) 2004-2012 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _EXPORT_PROJECT_DIALOG_H
+#define _EXPORT_PROJECT_DIALOG_H
+
+#include <QtGui/QDialog>
+#include <vector>
+#include "ui_export_project.h"
+
+#include "ProjectRenderer.h"
+
+
+class exportProjectDialog : public QDialog, public Ui::ExportProjectDialog
+{
+	Q_OBJECT
+public:
+	exportProjectDialog( const QString & _file_name, QWidget * _parent, bool multi_export );
+	virtual ~exportProjectDialog();
+
+
+protected:
+	virtual void reject( void );
+	virtual void closeEvent( QCloseEvent * _ce );
+
+
+private slots:
+	void startBtnClicked( void );
+	void updateTitleBar( int );
+	void render(ProjectRenderer* renderer);
+	void multiRender();
+	ProjectRenderer* prepRender();
+	void popRender();
+	void accept();
+
+private:
+	QString m_fileName;
+	QString m_dirName;
+	QString m_fileExtension;
+	typedef QVector<ProjectRenderer*> RenderVector;
+	RenderVector m_renderers;
+	bool m_multiExport;
+
+	typedef QVector<track*> TrackVector;
+	TrackVector m_unmuted;
+	TrackVector m_unmutedBB;
+	ProjectRenderer::ExportFileFormats m_ft;
+	TrackVector m_tracksToRender;
+	ProjectRenderer* m_activeRenderer;
+} ;
+
+#endif
diff --git a/lmms/include/fade_button.h b/lmms/include/fade_button.h
new file mode 100644
index 0000000..861595e
--- /dev/null
+++ b/lmms/include/fade_button.h
@@ -0,0 +1,64 @@
+/*
+ * fade_button.h - declaration of class fadeButton 
+ *
+ * Copyright (c) 2005-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _FADE_BUTTON_H
+#define _FADE_BUTTON_H 
+
+#include <QtCore/QTime>
+#include <QtGui/QAbstractButton>
+#include <QtGui/QColor>
+
+
+class fadeButton : public QAbstractButton
+{
+	Q_OBJECT
+public:
+	fadeButton( const QColor & _normal_color, const QColor &
+					_activated_color, QWidget * _parent );
+
+	virtual ~fadeButton();
+
+
+public slots:
+	void activate();
+
+
+protected:
+	virtual void customEvent( QEvent * );
+	virtual void paintEvent( QPaintEvent * _pe );
+
+
+private:
+	QTime m_stateTimer;
+	QColor m_normalColor;
+	QColor m_activatedColor;
+
+	void signalUpdate();
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/fader.h b/lmms/include/fader.h
new file mode 100644
index 0000000..02bc475
--- /dev/null
+++ b/lmms/include/fader.h
@@ -0,0 +1,119 @@
+/*
+ * fader.h - fader-widget used in FX-mixer - partly taken from Hydrogen
+ *
+ * Copyright (c) 2008-2012 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+/*
+ * Hydrogen
+ * Copyright(c) 2002-2008 by Alex >Comix< Cominu [comix@users.sourceforge.net]
+ *
+ * http://www.hydrogen-music.org
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY, without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#ifndef _FADER_H
+#define _FADER_H
+
+#include <QtCore/QTime>
+#include <QtGui/QWidget>
+#include <QtGui/QPixmap>
+
+#include "AutomatableModelView.h"
+
+class textFloat;
+
+
+class fader : public QWidget, public FloatModelView
+{
+	Q_OBJECT
+public:
+	fader( FloatModel * _model, const QString & _name, QWidget * _parent );
+	virtual ~fader();
+
+	void setPeak_L( float fPeak );
+	float getPeak_L() {	return m_fPeakValue_L;	}
+
+	void setPeak_R( float fPeak );
+	float getPeak_R() {	return m_fPeakValue_R;	}
+
+
+private:
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+	virtual void mousePressEvent( QMouseEvent *ev );
+	virtual void mouseDoubleClickEvent( QMouseEvent* mouseEvent );
+	virtual void mouseMoveEvent( QMouseEvent *ev );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+	virtual void wheelEvent( QWheelEvent *ev );
+	virtual void paintEvent( QPaintEvent *ev );
+
+	int knobPosY() const
+	{
+		float fRange = m_model->maxValue() - m_model->minValue();
+		float realVal = m_model->value() - m_model->minValue();
+
+		return height() - ( ( height() - m_knob.height() ) * ( realVal / fRange ) );
+	}
+
+	FloatModel * m_model;
+
+	void setPeak( float fPeak, float &targetPeak, float &persistentPeak, QTime &lastPeakTime );
+	int calculateDisplayPeak( float fPeak );
+
+	float m_fPeakValue_L;
+	float m_fPeakValue_R;
+	float m_persistentPeak_L;
+	float m_persistentPeak_R;
+	const float m_fMinPeak;
+	const float m_fMaxPeak;
+
+	QTime m_lastPeakTime_L;
+	QTime m_lastPeakTime_R;
+
+	QPixmap m_back;
+	QPixmap m_leds;
+	QPixmap m_knob;
+
+	int m_moveStartPoint;
+	float m_startValue;
+
+	static textFloat * s_textFloat;
+	void updateTextFloat();
+
+} ;
+
+
+#endif
diff --git a/lmms/include/fft_helpers.h b/lmms/include/fft_helpers.h
new file mode 100644
index 0000000..44fe7b7
--- /dev/null
+++ b/lmms/include/fft_helpers.h
@@ -0,0 +1,85 @@
+/*
+ * fft_helpers.h - some functions around FFT analysis
+ *
+ * Copyright (c) 2008-2012 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _FFT_HELPERS_H
+#define _FFT_HELPERS_H
+
+#include "lmmsconfig.h"
+#include "export.h"
+
+#include <fftw3.h>
+
+const int FFT_BUFFER_SIZE = 2048;
+
+enum WINDOWS
+{
+        KAISER=1,
+        RECTANGLE,
+        HANNING,
+        HAMMING
+};
+
+/* returns biggest value from abs_spectrum[spec_size] array
+ *
+ *    returns -1 on error
+ */
+float EXPORT maximum( float * _abs_spectrum, unsigned int _spec_size );
+
+/* apply hanning or hamming window to channel
+ *
+ *    returns -1 on error
+ */
+int EXPORT hanming( float * _timebuffer, int _length, WINDOWS _type );
+
+/* compute absolute values of complex_buffer, save to absspec_buffer
+ * take care that - compl_len is not bigger than complex_buffer!
+ *                - absspec buffer is big enough!
+ *
+ *    returns 0 on success, else -1
+ */
+int EXPORT absspec( fftwf_complex * _complex_buffer, float * _absspec_buffer,
+							int _compl_length );
+
+/* build fewer subbands from many absolute spectrum values
+ * take care that - compressedbands[] array num_new elements long
+ *                - num_old > num_new
+ *                       
+ *    returns 0 on success, else -1
+ */
+int EXPORT compressbands( float * _absspec_buffer, float * _compressedband,
+			int _num_old, int _num_new, int _bottom, int _top );
+
+
+int EXPORT calc13octaveband31( float * _absspec_buffer, float * _subbands,
+				int _num_spec, float _max_frequency );
+
+/* compute power of finite time sequence
+ * take care num_values is length of timesignal[]
+ *
+ *    returns power on success, else -1
+ */
+float EXPORT signalpower(float *timesignal, int num_values);
+
+#endif
diff --git a/lmms/include/fifo_buffer.h b/lmms/include/fifo_buffer.h
new file mode 100644
index 0000000..3942d34
--- /dev/null
+++ b/lmms/include/fifo_buffer.h
@@ -0,0 +1,88 @@
+/*
+ * fifo_buffer.h - FIFO fixed-size buffer
+ *
+ * Copyright (c) 2007 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _FIFO_BUFFER_H
+#define _FIFO_BUFFER_H
+
+#include <QtCore/QSemaphore>
+
+
+template<typename T>
+class fifoBuffer
+{
+public:
+	fifoBuffer( int _size ) :
+		m_reader_sem( _size ),
+		m_writer_sem( _size ),
+		m_reader_index( 0 ),
+		m_writer_index( 0 ),
+		m_size( _size )
+	{
+		m_buffer = new T[_size];
+		m_reader_sem.acquire( _size );
+	}
+
+	~fifoBuffer()
+	{
+		delete[] m_buffer;
+		m_reader_sem.release( m_size );
+	}
+
+	void write( T _element )
+	{
+		m_writer_sem.acquire();
+		m_buffer[m_writer_index++] = _element;
+		m_writer_index %= m_size;
+		m_reader_sem.release();
+	}
+
+	T read()
+	{
+		m_reader_sem.acquire();
+		T element = m_buffer[m_reader_index++];
+		m_reader_index %= m_size;
+		m_writer_sem.release();
+		return( element );
+	}
+
+	bool available()
+	{
+		return( m_reader_sem.available() );
+	}
+
+
+private:
+	QSemaphore m_reader_sem;
+	QSemaphore m_writer_sem;
+	int m_reader_index;
+	int m_writer_index;
+	int m_size;
+	T * m_buffer;
+
+} ;
+
+
+
+
+#endif
diff --git a/lmms/include/file_browser.h b/lmms/include/file_browser.h
new file mode 100644
index 0000000..d3aa501
--- /dev/null
+++ b/lmms/include/file_browser.h
@@ -0,0 +1,238 @@
+/*
+ * file_browser.h - include file for fileBrowser
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _FILE_BROWSER_H
+#define _FILE_BROWSER_H
+
+#include <QtCore/QDir>
+#include <QtCore/QMutex>
+#include <QtGui/QTreeWidget>
+
+
+#include "SideBarWidget.h"
+
+
+class QLineEdit;
+
+class fileItem;
+class InstrumentTrack;
+class fileBrowserTreeWidget;
+class PlayHandle;
+class TrackContainer;
+
+
+
+class fileBrowser : public SideBarWidget
+{
+	Q_OBJECT
+public:
+	fileBrowser( const QString & _directories, const QString & _filter,
+			const QString & _title, const QPixmap & _pm,
+			QWidget * _parent, bool _dirs_as_items = false );
+	virtual ~fileBrowser();
+
+
+public slots:
+	void filterItems( const QString & _filter );
+	void reloadTree( void );
+
+
+private:
+	bool filterItems( QTreeWidgetItem * _item, const QString & _filter );
+	virtual void keyPressEvent( QKeyEvent * _ke );
+
+	void addItems( const QString & _path );
+
+	fileBrowserTreeWidget * m_l;
+
+	QLineEdit * m_filterEdit;
+
+	QString m_directories;
+	QString m_filter;
+
+	bool m_dirsAsItems;
+
+} ;
+
+
+
+
+class fileBrowserTreeWidget : public QTreeWidget
+{
+	Q_OBJECT
+public:
+	fileBrowserTreeWidget( QWidget * _parent );
+	virtual ~fileBrowserTreeWidget();
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _e );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseMoveEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+
+
+private:
+	void handleFile( fileItem * _fi, InstrumentTrack * _it );
+	void openInNewInstrumentTrack( TrackContainer* tc );
+
+
+	bool m_mousePressed;
+	QPoint m_pressPos;
+
+	PlayHandle* m_previewPlayHandle;
+	QMutex m_pphMutex;
+
+	fileItem * m_contextMenuItem;
+
+
+private slots:
+	void activateListItem( QTreeWidgetItem * _item, int _column );
+	void openInNewInstrumentTrackBBE( void );
+	void openInNewInstrumentTrackSE( void );
+	void sendToActiveInstrumentTrack( void );
+	void updateDirectory( QTreeWidgetItem * _item );
+
+} ;
+
+
+
+
+class directory : public QTreeWidgetItem
+{
+public:
+	directory( const QString & _filename, const QString & _path,
+						const QString & _filter );
+
+	void update( void );
+
+	inline QString fullName( QString _path = QString::null )
+	{
+		if( _path == QString::null )
+		{
+			_path = m_directories[0];
+		}
+		if( _path != QString::null )
+		{
+			_path += QDir::separator();
+		}
+		return( QDir::cleanPath( _path + text( 0 ) ) +
+							QDir::separator() );
+	}
+
+	inline void addDirectory( const QString & _dir )
+	{
+		m_directories.push_back( _dir );
+	}
+
+
+private:
+	void initPixmaps( void );
+
+	bool addItems( const QString & _path );
+
+
+	static QPixmap * s_folderPixmap;
+	static QPixmap * s_folderOpenedPixmap;
+	static QPixmap * s_folderLockedPixmap;
+
+	QStringList m_directories;
+	QString m_filter;
+
+} ;
+
+
+
+
+class fileItem : public QTreeWidgetItem
+{
+public:
+	enum FileTypes
+	{
+		ProjectFile,
+		PresetFile,
+		SampleFile,
+		SoundFontFile,
+		PatchFile,
+		MidiFile,
+		FlpFile,
+		VstPluginFile,
+		UnknownFile,
+		NumFileTypes
+	} ;
+
+	enum FileHandling
+	{
+		NotSupported,
+		LoadAsProject,
+		LoadAsPreset,
+		LoadByPlugin,
+		ImportAsProject
+	} ;
+
+
+	fileItem( QTreeWidget * _parent, const QString & _name,
+							const QString & _path );
+	fileItem( const QString & _name, const QString & _path );
+
+	inline QString fullName( void ) const
+	{
+		return( QDir::cleanPath( m_path ) + QDir::separator() +
+								text( 0 ) );
+	}
+
+	inline FileTypes type( void ) const
+	{
+		return( m_type );
+	}
+
+	inline FileHandling handling( void ) const
+	{
+		return( m_handling );
+	}
+
+	QString extension( void );
+	static QString extension( const QString & _file );
+
+
+private:
+	void initPixmaps( void );
+	void determineFileType( void );
+
+	static QPixmap * s_projectFilePixmap;
+	static QPixmap * s_presetFilePixmap;
+	static QPixmap * s_sampleFilePixmap;
+	static QPixmap * s_midiFilePixmap;
+	static QPixmap * s_flpFilePixmap;
+	static QPixmap * s_unknownFilePixmap;
+
+	QString m_path;
+	FileTypes m_type;
+	FileHandling m_handling;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/graph.h b/lmms/include/graph.h
new file mode 100644
index 0000000..b2041c6
--- /dev/null
+++ b/lmms/include/graph.h
@@ -0,0 +1,185 @@
+/*
+ * graph.h - a QT widget for displaying and manipulating waveforms
+ *
+ * Copyright (c) 2006-2007 Andreas Brandmaier <andy/at/brandmaier/dot/de>
+ *               2008 Paul Giblock <drfaygo/at/gmail/dot/com>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef GRAPH_H
+#define GRAPH_H
+
+#include <QtGui/QWidget>
+#include <QtGui/QPixmap>
+#include <QtGui/QCursor>
+
+#include "Model.h"
+#include "ModelView.h"
+#include "lmms_basics.h"
+
+class graphModel;
+
+
+class EXPORT graph : public QWidget, public ModelView
+{
+	Q_OBJECT
+public:
+	enum graphStyle
+	{
+		NearestStyle,
+		LinearStyle,
+		LinearNonCyclicStyle,
+		BarStyle,
+		NumGraphStyles
+	};
+
+	graph( QWidget * _parent, graphStyle _style = graph::LinearStyle,
+		int _width = 132,
+		int _height = 104
+	);
+	virtual ~graph();
+
+	void setForeground( const QPixmap & _pixmap );
+
+
+	void setGraphColor( const QColor );
+
+	inline graphModel * model()
+	{
+		return castModel<graphModel>();
+	}
+
+	inline graphStyle getGraphStyle()
+	{
+		return m_graphStyle;
+	}
+
+
+	inline void setGraphStyle( graphStyle _s )
+	{
+		m_graphStyle = _s;
+		update();
+	}
+
+
+protected:
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void dropEvent( QDropEvent * _de );
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseMoveEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+
+protected slots:
+	void updateGraph( int _startPos, int _endPos );
+	void updateGraph();
+
+private:
+	virtual void modelChanged();
+
+	void changeSampleAt( int _x, int _y );
+	void drawLineAt( int _x, int _y, int _lastx );
+
+
+	QPixmap m_foreground;
+	QColor m_graphColor;
+
+	graphStyle m_graphStyle;
+
+	bool m_mouseDown;
+	int m_lastCursorX;
+
+} ;
+
+
+class EXPORT graphModel : public Model
+{
+	Q_OBJECT
+public:
+	graphModel( float _min,
+			float _max,
+			int _size,
+			:: Model * _parent,
+			bool _default_constructed = false,
+			float _step = 0.0 );
+
+	virtual ~graphModel();
+
+	// TODO: saveSettings, loadSettings?
+
+	inline float minValue() const
+	{
+		return( m_minValue );
+	}
+
+	inline float maxValue() const
+	{
+		return( m_maxValue );
+	}
+
+	inline int length() const
+	{
+		return( m_samples.count() );
+	}
+
+	inline const float * samples() const
+	{
+		return( m_samples.data() );
+	}
+
+public slots:
+	void setRange( float _min, float _max );
+
+	void setLength( int _size );
+
+	void setSampleAt( int _samplePos, float _value );
+	void setSamples( const float * _value );
+
+	void setWaveToSine();
+	void setWaveToTriangle();
+	void setWaveToSaw();
+	void setWaveToSquare();
+	void setWaveToNoise();
+	QString setWaveToUser( );
+
+	void smooth();
+	void smoothNonCyclic();
+	void normalize();
+	void invert();
+	void shiftPhase( int _deg );
+
+signals:
+	void lengthChanged();
+	void samplesChanged( int startPos, int endPos );
+	void rangeChanged();
+
+private:
+
+	QVector<float> m_samples;
+	float m_minValue;
+	float m_maxValue;
+	float m_step;
+
+	friend class graph;
+
+};
+
+#endif
diff --git a/lmms/include/group_box.h b/lmms/include/group_box.h
new file mode 100644
index 0000000..ef08b56
--- /dev/null
+++ b/lmms/include/group_box.h
@@ -0,0 +1,76 @@
+/*
+ * group_box.h - LMMS-groupbox
+ *
+ * Copyright (c) 2005-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _GROUP_BOX_H
+#define _GROUP_BOX_H
+
+#include <QtGui/QWidget>
+
+#include "AutomatableModelView.h"
+#include "pixmap_button.h"
+
+
+class QPixmap;
+
+
+class groupBox : public QWidget, public BoolModelView
+{
+	Q_OBJECT
+public:
+	groupBox( const QString & _caption, QWidget * _parent = NULL );
+	virtual ~groupBox();
+
+	virtual void modelChanged();
+
+	pixmapButton * ledButton()
+	{
+		return m_led;
+	}
+
+	int titleBarHeight() const
+	{
+		return m_titleBarHeight;
+	}
+
+
+protected:
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void resizeEvent( QResizeEvent * _re );
+
+
+private:
+	void updatePixmap();
+
+	pixmapButton * m_led;
+	QString m_caption;
+	const int m_titleBarHeight;
+
+} ;
+
+
+typedef BoolModel groupBoxModel;
+
+
+#endif
diff --git a/lmms/include/gui_templates.h b/lmms/include/gui_templates.h
new file mode 100644
index 0000000..8045e26
--- /dev/null
+++ b/lmms/include/gui_templates.h
@@ -0,0 +1,68 @@
+/*
+ * gui_templates.h - GUI-specific templates
+ *
+ * Copyright (c) 2005-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _GUI_TEMPLATES_H
+#define _GUI_TEMPLATES_H
+
+#include "lmmsconfig.h"
+
+#include <QtGui/QApplication>
+#include <QtGui/QFont>
+#include <QtGui/QDesktopWidget>
+
+
+
+// return DPI-independent font-size - font with returned font-size has always
+// the same size in pixels
+template<int SIZE>
+inline QFont pointSize( QFont _f )
+{
+	static const float DPI = 96;
+#ifdef LMMS_BUILD_WIN32
+	_f.setPointSizeF( ((float) SIZE+0.5f) * DPI /
+			QApplication::desktop()->logicalDpiY() );
+#else
+	_f.setPointSizeF( (float) SIZE * DPI /
+			QApplication::desktop()->logicalDpiY() );
+#endif
+	return( _f );
+}
+
+
+inline QFont pointSizeF( QFont _f, float SIZE )
+{
+	static const float DPI = 96;
+#ifdef LMMS_BUILD_WIN32
+	_f.setPointSizeF( (SIZE+0.5f) * DPI /
+			QApplication::desktop()->logicalDpiY() );
+#else
+	_f.setPointSizeF( SIZE * DPI /
+			QApplication::desktop()->logicalDpiY() );
+#endif
+	return( _f );
+}
+
+
+#endif
diff --git a/lmms/include/interpolation.h b/lmms/include/interpolation.h
new file mode 100644
index 0000000..4ff5827
--- /dev/null
+++ b/lmms/include/interpolation.h
@@ -0,0 +1,94 @@
+/*
+ * interpolation.h - fast implementations of several interpolation-algorithms
+ *
+ * Copyright (c) 2004-2005 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _INTERPOLATION_H
+#define _INTERPOLATION_H
+
+#ifndef __USE_XOPEN
+#define __USE_XOPEN
+#endif
+
+#include <math.h>
+#include "lmms_constants.h"
+
+inline float hermiteInterpolate( float x0, float x1, float x2, float x3,
+								float frac_pos )
+{
+	const float frsq = frac_pos*frac_pos;
+	const float frsq2 = 2*frsq;
+	return( ( (x2-x0) *0.5f ) * ( frac_pos * (frsq+1) -frsq2 ) +
+				( frsq2*frac_pos - 3*frsq ) * ( x1-x2 ) +
+			frsq2 * (frac_pos-1) * ( ( x3-x1 ) * 0.25f ) + x1 );
+
+/*
+   const float frsq	= frac_pos*frac_pos;
+   //const float frsq2	= 2*frsq;
+   frac_pos *= 0.5;
+   const float frcu	= frsq*frac_pos;
+   return (
+   
+   (frcu - frsq + frac_pos) * ((x2 - x0)) +
+   
+   (4*frcu - 3*frsq) * (x1 - x2)
+   //frsq*(2*frac_pos-3) * (x1 - x2)
+   
+   + (frcu - 0.5*frsq)*((x3 - x1))  
+    
+   + x1
+   
+   );
+*/
+}
+
+
+
+inline float cubicInterpolate( float v0, float v1, float v2, float v3, float x )
+{
+	float frsq = x*x;
+	float frcu = frsq*v0;
+	float t1 = v3 + 3*v1;
+
+	return( v1 + 0.5f * frcu + x * ( v2 - frcu * ( 1.0f/6.0f ) -
+		t1 * ( 1.0f/6.0f ) - v0 / 3.0f ) + frsq * x * ( t1 *
+		( 1.0f/6.0f ) - 0.5f * v2 ) + frsq * ( 0.5f * v2 - v1 ) );
+}
+
+
+
+inline float cosinusInterpolate( float v0, float v1, float x )
+{
+	float f = cosf( x * ( F_PI_2 ) );
+	return( v0*f + v1*( 1.0f-f ) );
+}
+
+
+
+inline float linearInterpolate( float v0, float v1, float x )
+{
+	return( v0*( 1.0f-x ) + v1*x );
+}
+
+
+#endif
diff --git a/lmms/include/knob.h b/lmms/include/knob.h
new file mode 100644
index 0000000..8114122
--- /dev/null
+++ b/lmms/include/knob.h
@@ -0,0 +1,174 @@
+/*
+ * knob.h - powerful knob-widget
+ *
+ * Copyright (c) 2004-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef KNOB_H
+#define KNOB_H
+
+#include <QtGui/QWidget>
+#include <QtCore/QPoint>
+
+#include "AutomatableModelView.h"
+#include "templates.h"
+
+
+class QPixmap;
+class textFloat;
+
+enum knobTypes
+{
+	knobDark_28, knobBright_26, knobSmall_17, knobGreen_17, knobVintage_32, knobStyled
+} ;
+
+
+
+class EXPORT knob : public QWidget, public FloatModelView
+{
+	Q_OBJECT
+	Q_PROPERTY(float innerRadius READ innerRadius WRITE setInnerRadius)
+	Q_PROPERTY(float outerRadius READ outerRadius WRITE setOuterRadius)
+
+	Q_PROPERTY(float centerPointX READ centerPointX WRITE setCenterPointX)
+	Q_PROPERTY(float centerPointY READ centerPointY WRITE setCenterPointY)
+
+	Q_PROPERTY(float lineWidth READ lineWidth WRITE setLineWidth)
+
+	// Unfortunately, the gradient syntax doesn't create our gradient
+	// correctly so we need to do this:
+	Q_PROPERTY(QColor outerColor READ outerColor WRITE setOuterColor)
+	mapPropertyFromModel(bool,isVolumeKnob,setVolumeKnob,m_volumeKnob);
+	mapPropertyFromModel(float,volumeRatio,setVolumeRatio,m_volumeRatio);
+
+public:
+	knob( int _knob_num, QWidget * _parent = NULL, const QString & _name = QString() );
+	virtual ~knob();
+
+	// TODO: remove
+	inline void setHintText( const QString & _txt_before,
+						const QString & _txt_after )
+	{
+		setDescription( _txt_before );
+		setUnit( _txt_after );
+	}
+	void setLabel( const QString & _txt );
+
+	void setTotalAngle( float _angle );
+
+	// Begin styled knob accessors
+	float innerRadius() const;
+	void setInnerRadius( float _r );
+
+	float outerRadius() const;
+	void setOuterRadius( float _r );
+
+	QPointF centerPoint() const;
+	float centerPointX() const;
+	void setCenterPointX( float _c );
+	float centerPointY() const;
+	void setCenterPointY( float _c );
+
+	float lineWidth() const;
+	void setLineWidth( float _w );
+
+	QColor outerColor() const;
+	void setOuterColor( const QColor & _c );
+
+
+signals:
+	void sliderPressed();
+	void sliderReleased();
+	void sliderMoved( float value );
+
+
+protected:
+	virtual void contextMenuEvent( QContextMenuEvent * _me );
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+	virtual void focusOutEvent( QFocusEvent * _fe );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+	virtual void mouseMoveEvent( QMouseEvent * _me );
+	virtual void mouseDoubleClickEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _me );
+	virtual void wheelEvent( QWheelEvent * _me );
+
+	virtual float getValue( const QPoint & _p );
+
+private slots:
+	virtual void enterValue();
+	void displayHelp();
+	void friendlyUpdate();
+
+
+private:
+	QString displayValue() const;
+
+	virtual void doConnections();
+
+	QLineF calculateLine( const QPointF & _mid, float _radius,
+						float _innerRadius = 1) const;
+
+	void drawKnob( QPainter * _p );
+	void setPosition( const QPoint & _p );
+	bool updateAngle();
+
+	int angleFromValue( float value, float minValue, float maxValue, float totalAngle ) const
+	{
+		return static_cast<int>( ( value - 0.5 * ( minValue + maxValue ) ) / ( maxValue - minValue ) * m_totalAngle ) % 360;
+	}
+
+	inline float pageSize() const
+	{
+		return ( model()->maxValue() - model()->minValue() ) / 100.0f;
+	}
+
+
+	static textFloat * s_textFloat;
+
+	int m_knobNum;
+	QString m_label;
+
+	QPixmap * m_knobPixmap;
+	BoolModel m_volumeKnob;
+	FloatModel m_volumeRatio;
+
+	QPoint m_mouseOffset;
+	QPoint m_origMousePos;
+	float m_leftOver;
+	bool m_buttonPressed;
+
+	float m_totalAngle;
+	int m_angle;
+	QImage m_cache;
+
+	// Styled knob stuff, could break out
+	QPointF m_centerPoint;
+	float m_innerRadius;
+	float m_outerRadius;
+	float m_lineWidth;
+	QColor * m_outerColor;
+
+} ;
+
+#endif
diff --git a/lmms/include/ladspa.h b/lmms/include/ladspa.h
new file mode 100644
index 0000000..5c30a8a
--- /dev/null
+++ b/lmms/include/ladspa.h
@@ -0,0 +1,603 @@
+/* ladspa.h
+
+   Linux Audio Developer's Simple Plugin API Version 1.1[LGPL].
+   Copyright (C) 2000-2002 Richard W.E. Furse, Paul Barton-Davis,
+   Stefan Westerfeld.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+   Lesser General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+   USA. */
+
+#ifndef LADSPA_INCLUDED
+#define LADSPA_INCLUDED
+
+#define LADSPA_VERSION "1.1"
+#define LADSPA_VERSION_MAJOR 1
+#define LADSPA_VERSION_MINOR 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*****************************************************************************/
+
+/* Overview: 
+
+   There is a large number of synthesis packages in use or development
+   on the Linux platform at this time. This API (`The Linux Audio
+   Developer's Simple Plugin API') attempts to give programmers the
+   ability to write simple `plugin' audio processors in C/C++ and link
+   them dynamically (`plug') into a range of these packages (`hosts').
+   It should be possible for any host and any plugin to communicate
+   completely through this interface.
+
+   This API is deliberately short and simple. To achieve compatibility
+   with a range of promising Linux sound synthesis packages it
+   attempts to find the `greatest common divisor' in their logical
+   behaviour. Having said this, certain limiting decisions are
+   implicit, notably the use of a fixed type (LADSPA_Data) for all
+   data transfer and absence of a parameterised `initialisation'
+   phase. See below for the LADSPA_Data typedef.
+
+   Plugins are expected to distinguish between control and audio
+   data. Plugins have `ports' that are inputs or outputs for audio or
+   control data and each plugin is `run' for a `block' corresponding
+   to a short time interval measured in samples. Audio data is
+   communicated using arrays of LADSPA_Data, allowing a block of audio
+   to be processed by the plugin in a single pass. Control data is
+   communicated using single LADSPA_Data values. Control data has a
+   single value at the start of a call to the `run()' or `run_adding()'
+   function, and may be considered to remain this value for its
+   duration. The plugin may assume that all its input and output ports
+   have been connected to the relevant data location (see the
+   `connect_port()' function below) before it is asked to run.
+
+   Plugins will reside in shared object files suitable for dynamic
+   linking by dlopen() and family. The file will provide a number of
+   `plugin types' that can be used to instantiate actual plugins
+   (sometimes known as `plugin instances') that can be connected
+   together to perform tasks.
+
+   This API contains very limited error-handling. */
+
+/*****************************************************************************/
+
+/* Fundamental data type passed in and out of plugin. This data type
+   is used to communicate audio samples and control values. It is
+   assumed that the plugin will work sensibly given any numeric input
+   value although it may have a preferred range (see hints below). 
+
+   For audio it is generally assumed that 1.0f is the `0dB' reference
+   amplitude and is a `normal' signal level. */
+
+typedef float LADSPA_Data;
+
+/*****************************************************************************/
+
+/* Special Plugin Properties: 
+ 
+   Optional features of the plugin type are encapsulated in the
+   LADSPA_Properties type. This is assembled by ORing individual
+   properties together. */
+
+typedef int LADSPA_Properties;
+
+/* Property LADSPA_PROPERTY_REALTIME indicates that the plugin has a
+   real-time dependency (e.g. listens to a MIDI device) and so its
+   output must not be cached or subject to significant latency. */
+#define LADSPA_PROPERTY_REALTIME        0x1
+
+/* Property LADSPA_PROPERTY_INPLACE_BROKEN indicates that the plugin
+   may cease to work correctly if the host elects to use the same data
+   location for both input and output (see connect_port()). This
+   should be avoided as enabling this flag makes it impossible for
+   hosts to use the plugin to process audio `in-place.' */
+#define LADSPA_PROPERTY_INPLACE_BROKEN  0x2
+
+/* Property LADSPA_PROPERTY_HARD_RT_CAPABLE indicates that the plugin
+   is capable of running not only in a conventional host but also in a
+   `hard real-time' environment. To qualify for this the plugin must
+   satisfy all of the following:
+
+   (1) The plugin must not use malloc(), free() or other heap memory
+   management within its run() or run_adding() functions. All new
+   memory used in run() must be managed via the stack. These
+   restrictions only apply to the run() function.
+
+   (2) The plugin will not attempt to make use of any library
+   functions with the exceptions of functions in the ANSI standard C
+   and C maths libraries, which the host is expected to provide.
+
+   (3) The plugin will not access files, devices, pipes, sockets, IPC
+   or any other mechanism that might result in process or thread
+   blocking.
+      
+   (4) The plugin will take an amount of time to execute a run() or
+   run_adding() call approximately of form (A+B*SampleCount) where A
+   and B depend on the machine and host in use. This amount of time
+   may not depend on input signals or plugin state. The host is left
+   the responsibility to perform timings to estimate upper bounds for
+   A and B. */
+#define LADSPA_PROPERTY_HARD_RT_CAPABLE 0x4
+
+#define LADSPA_IS_REALTIME(x)        ((x) & LADSPA_PROPERTY_REALTIME)
+#define LADSPA_IS_INPLACE_BROKEN(x)  ((x) & LADSPA_PROPERTY_INPLACE_BROKEN)
+#define LADSPA_IS_HARD_RT_CAPABLE(x) ((x) & LADSPA_PROPERTY_HARD_RT_CAPABLE)
+
+/*****************************************************************************/
+
+/* Plugin Ports: 
+
+   Plugins have `ports' that are inputs or outputs for audio or
+   data. Ports can communicate arrays of LADSPA_Data (for audio
+   inputs/outputs) or single LADSPA_Data values (for control
+   input/outputs). This information is encapsulated in the
+   LADSPA_PortDescriptor type which is assembled by ORing individual
+   properties together.
+
+   Note that a port must be an input or an output port but not both
+   and that a port must be a control or audio port but not both. */
+
+typedef int LADSPA_PortDescriptor;
+
+/* Property LADSPA_PORT_INPUT indicates that the port is an input. */
+#define LADSPA_PORT_INPUT   0x1
+
+/* Property LADSPA_PORT_OUTPUT indicates that the port is an output. */
+#define LADSPA_PORT_OUTPUT  0x2
+
+/* Property LADSPA_PORT_CONTROL indicates that the port is a control
+   port. */
+#define LADSPA_PORT_CONTROL 0x4
+
+/* Property LADSPA_PORT_AUDIO indicates that the port is a audio
+   port. */
+#define LADSPA_PORT_AUDIO   0x8
+
+#define LADSPA_IS_PORT_INPUT(x)   ((x) & LADSPA_PORT_INPUT)
+#define LADSPA_IS_PORT_OUTPUT(x)  ((x) & LADSPA_PORT_OUTPUT)
+#define LADSPA_IS_PORT_CONTROL(x) ((x) & LADSPA_PORT_CONTROL)
+#define LADSPA_IS_PORT_AUDIO(x)   ((x) & LADSPA_PORT_AUDIO)
+
+/*****************************************************************************/
+
+/* Plugin Port Range Hints: 
+
+   The host may wish to provide a representation of data entering or
+   leaving a plugin (e.g. to generate a GUI automatically). To make
+   this more meaningful, the plugin should provide `hints' to the host
+   describing the usual values taken by the data.
+   
+   Note that these are only hints. The host may ignore them and the
+   plugin must not assume that data supplied to it is meaningful. If
+   the plugin receives invalid input data it is expected to continue
+   to run without failure and, where possible, produce a sensible
+   output (e.g. a high-pass filter given a negative cutoff frequency
+   might switch to an all-pass mode).
+    
+   Hints are meaningful for all input and output ports but hints for
+   input control ports are expected to be particularly useful.
+   
+   More hint information is encapsulated in the
+   LADSPA_PortRangeHintDescriptor type which is assembled by ORing
+   individual hint types together. Hints may require further
+   LowerBound and UpperBound information.
+
+   All the hint information for a particular port is aggregated in the
+   LADSPA_PortRangeHint structure. */
+
+typedef int LADSPA_PortRangeHintDescriptor;
+
+/* Hint LADSPA_HINT_BOUNDED_BELOW indicates that the LowerBound field
+   of the LADSPA_PortRangeHint should be considered meaningful. The
+   value in this field should be considered the (inclusive) lower
+   bound of the valid range. If LADSPA_HINT_SAMPLE_RATE is also
+   specified then the value of LowerBound should be multiplied by the
+   sample rate. */
+#define LADSPA_HINT_BOUNDED_BELOW   0x1
+
+/* Hint LADSPA_HINT_BOUNDED_ABOVE indicates that the UpperBound field
+   of the LADSPA_PortRangeHint should be considered meaningful. The
+   value in this field should be considered the (inclusive) upper
+   bound of the valid range. If LADSPA_HINT_SAMPLE_RATE is also
+   specified then the value of UpperBound should be multiplied by the
+   sample rate. */
+#define LADSPA_HINT_BOUNDED_ABOVE   0x2
+
+/* Hint LADSPA_HINT_TOGGLED indicates that the data item should be
+   considered a Boolean toggle. Data less than or equal to zero should
+   be considered `off' or `false,' and data above zero should be
+   considered `on' or `true.' LADSPA_HINT_TOGGLED may not be used in
+   conjunction with any other hint except LADSPA_HINT_DEFAULT_0 or
+   LADSPA_HINT_DEFAULT_1. */
+#define LADSPA_HINT_TOGGLED         0x4
+
+/* Hint LADSPA_HINT_SAMPLE_RATE indicates that any bounds specified
+   should be interpreted as multiples of the sample rate. For
+   instance, a frequency range from 0Hz to the Nyquist frequency (half
+   the sample rate) could be requested by this hint in conjunction
+   with LowerBound = 0 and UpperBound = 0.5. Hosts that support bounds
+   at all must support this hint to retain meaning. */
+#define LADSPA_HINT_SAMPLE_RATE     0x8
+
+/* Hint LADSPA_HINT_LOGARITHMIC indicates that it is likely that the
+   user will find it more intuitive to view values using a logarithmic
+   scale. This is particularly useful for frequencies and gains. */
+#define LADSPA_HINT_LOGARITHMIC     0x10
+
+/* Hint LADSPA_HINT_INTEGER indicates that a user interface would
+   probably wish to provide a stepped control taking only integer
+   values. Any bounds set should be slightly wider than the actual
+   integer range required to avoid floating point rounding errors. For
+   instance, the integer set {0,1,2,3} might be described as [-0.1,
+   3.1]. */
+#define LADSPA_HINT_INTEGER         0x20
+
+/* The various LADSPA_HINT_HAS_DEFAULT_* hints indicate a `normal'
+   value for the port that is sensible as a default. For instance,
+   this value is suitable for use as an initial value in a user
+   interface or as a value the host might assign to a control port
+   when the user has not provided one. Defaults are encoded using a
+   mask so only one default may be specified for a port. Some of the
+   hints make use of lower and upper bounds, in which case the
+   relevant bound or bounds must be available and
+   LADSPA_HINT_SAMPLE_RATE must be applied as usual. The resulting
+   default must be rounded if LADSPA_HINT_INTEGER is present. Default
+   values were introduced in LADSPA v1.1. */
+#define LADSPA_HINT_DEFAULT_MASK    0x3C0
+
+/* This default values indicates that no default is provided. */
+#define LADSPA_HINT_DEFAULT_NONE    0x0
+
+/* This default hint indicates that the suggested lower bound for the
+   port should be used. */
+#define LADSPA_HINT_DEFAULT_MINIMUM 0x40
+
+/* This default hint indicates that a low value between the suggested
+   lower and upper bounds should be chosen. For ports with
+   LADSPA_HINT_LOGARITHMIC, this should be exp(log(lower) * 0.75 +
+   log(upper) * 0.25). Otherwise, this should be (lower * 0.75 + upper
+   * 0.25). */
+#define LADSPA_HINT_DEFAULT_LOW     0x80
+
+/* This default hint indicates that a middle value between the
+   suggested lower and upper bounds should be chosen. For ports with
+   LADSPA_HINT_LOGARITHMIC, this should be exp(log(lower) * 0.5 +
+   log(upper) * 0.5). Otherwise, this should be (lower * 0.5 + upper *
+   0.5). */
+#define LADSPA_HINT_DEFAULT_MIDDLE  0xC0
+
+/* This default hint indicates that a high value between the suggested
+   lower and upper bounds should be chosen. For ports with
+   LADSPA_HINT_LOGARITHMIC, this should be exp(log(lower) * 0.25 +
+   log(upper) * 0.75). Otherwise, this should be (lower * 0.25 + upper
+   * 0.75). */
+#define LADSPA_HINT_DEFAULT_HIGH    0x100
+
+/* This default hint indicates that the suggested upper bound for the
+   port should be used. */
+#define LADSPA_HINT_DEFAULT_MAXIMUM 0x140
+
+/* This default hint indicates that the number 0 should be used. Note
+   that this default may be used in conjunction with
+   LADSPA_HINT_TOGGLED. */
+#define LADSPA_HINT_DEFAULT_0       0x200
+
+/* This default hint indicates that the number 1 should be used. Note
+   that this default may be used in conjunction with
+   LADSPA_HINT_TOGGLED. */
+#define LADSPA_HINT_DEFAULT_1       0x240
+
+/* This default hint indicates that the number 100 should be used. */
+#define LADSPA_HINT_DEFAULT_100     0x280
+
+/* This default hint indicates that the Hz frequency of `concert A'
+   should be used. This will be 440 unless the host uses an unusual
+   tuning convention, in which case it may be within a few Hz. */
+#define LADSPA_HINT_DEFAULT_440     0x2C0
+
+#define LADSPA_IS_HINT_BOUNDED_BELOW(x)   ((x) & LADSPA_HINT_BOUNDED_BELOW)
+#define LADSPA_IS_HINT_BOUNDED_ABOVE(x)   ((x) & LADSPA_HINT_BOUNDED_ABOVE)
+#define LADSPA_IS_HINT_TOGGLED(x)         ((x) & LADSPA_HINT_TOGGLED)
+#define LADSPA_IS_HINT_SAMPLE_RATE(x)     ((x) & LADSPA_HINT_SAMPLE_RATE)
+#define LADSPA_IS_HINT_LOGARITHMIC(x)     ((x) & LADSPA_HINT_LOGARITHMIC)
+#define LADSPA_IS_HINT_INTEGER(x)         ((x) & LADSPA_HINT_INTEGER)
+
+#define LADSPA_IS_HINT_HAS_DEFAULT(x)     ((x) & LADSPA_HINT_DEFAULT_MASK)
+#define LADSPA_IS_HINT_DEFAULT_MINIMUM(x) (((x) & LADSPA_HINT_DEFAULT_MASK)   \
+                                           == LADSPA_HINT_DEFAULT_MINIMUM)
+#define LADSPA_IS_HINT_DEFAULT_LOW(x)     (((x) & LADSPA_HINT_DEFAULT_MASK)   \
+                                           == LADSPA_HINT_DEFAULT_LOW)
+#define LADSPA_IS_HINT_DEFAULT_MIDDLE(x)  (((x) & LADSPA_HINT_DEFAULT_MASK)   \
+                                           == LADSPA_HINT_DEFAULT_MIDDLE)
+#define LADSPA_IS_HINT_DEFAULT_HIGH(x)    (((x) & LADSPA_HINT_DEFAULT_MASK)   \
+                                           == LADSPA_HINT_DEFAULT_HIGH)
+#define LADSPA_IS_HINT_DEFAULT_MAXIMUM(x) (((x) & LADSPA_HINT_DEFAULT_MASK)   \
+                                           == LADSPA_HINT_DEFAULT_MAXIMUM)
+#define LADSPA_IS_HINT_DEFAULT_0(x)       (((x) & LADSPA_HINT_DEFAULT_MASK)   \
+                                           == LADSPA_HINT_DEFAULT_0)
+#define LADSPA_IS_HINT_DEFAULT_1(x)       (((x) & LADSPA_HINT_DEFAULT_MASK)   \
+                                           == LADSPA_HINT_DEFAULT_1)
+#define LADSPA_IS_HINT_DEFAULT_100(x)     (((x) & LADSPA_HINT_DEFAULT_MASK)   \
+                                           == LADSPA_HINT_DEFAULT_100)
+#define LADSPA_IS_HINT_DEFAULT_440(x)     (((x) & LADSPA_HINT_DEFAULT_MASK)   \
+                                            == LADSPA_HINT_DEFAULT_440)
+
+typedef struct _LADSPA_PortRangeHint {
+
+  /* Hints about the port. */
+  LADSPA_PortRangeHintDescriptor HintDescriptor;
+
+  /* Meaningful when hint LADSPA_HINT_BOUNDED_BELOW is active. When
+     LADSPA_HINT_SAMPLE_RATE is also active then this value should be
+     multiplied by the relevant sample rate. */
+  LADSPA_Data LowerBound;
+
+  /* Meaningful when hint LADSPA_HINT_BOUNDED_ABOVE is active. When
+     LADSPA_HINT_SAMPLE_RATE is also active then this value should be
+     multiplied by the relevant sample rate. */
+  LADSPA_Data UpperBound;
+
+} LADSPA_PortRangeHint;
+
+/*****************************************************************************/
+
+/* Plugin Handles: 
+
+   This plugin handle indicates a particular instance of the plugin
+   concerned. It is valid to compare this to NULL (0 for C++) but
+   otherwise the host should not attempt to interpret it. The plugin
+   may use it to reference internal instance data. */
+
+typedef void * LADSPA_Handle;
+
+/*****************************************************************************/
+
+/* Descriptor for a Type of Plugin: 
+
+   This structure is used to describe a plugin type. It provides a
+   number of functions to examine the type, instantiate it, link it to
+   buffers and workspaces and to run it. */
+
+typedef struct _LADSPA_Descriptor { 
+
+  /* This numeric identifier indicates the plugin type
+     uniquely. Plugin programmers may reserve ranges of IDs from a
+     central body to avoid clashes. Hosts may assume that IDs are
+     below 0x1000000. */
+  unsigned long UniqueID;
+
+  /* This identifier can be used as a unique, case-sensitive
+     identifier for the plugin type within the plugin file. Plugin
+     types should be identified by file and label rather than by index
+     or plugin name, which may be changed in new plugin
+     versions. Labels must not contain white-space characters. */
+  const char * Label;
+
+  /* This indicates a number of properties of the plugin. */
+  LADSPA_Properties Properties;
+
+  /* This member points to the null-terminated name of the plugin
+     (e.g. "Sine Oscillator"). */
+  const char * Name;
+
+  /* This member points to the null-terminated string indicating the
+     maker of the plugin. This can be an empty string but not NULL. */
+  const char * Maker;
+
+  /* This member points to the null-terminated string indicating any
+     copyright applying to the plugin. If no Copyright applies the
+     string "None" should be used. */
+  const char * Copyright;
+
+  /* This indicates the number of ports (input AND output) present on
+     the plugin. */
+  unsigned long PortCount;
+
+  /* This member indicates an array of port descriptors. Valid indices
+     vary from 0 to PortCount-1. */
+  const LADSPA_PortDescriptor * PortDescriptors;
+
+  /* This member indicates an array of null-terminated strings
+     describing ports (e.g. "Frequency (Hz)"). Valid indices vary from
+     0 to PortCount-1. */
+  const char * const * PortNames;
+
+  /* This member indicates an array of range hints for each port (see
+     above). Valid indices vary from 0 to PortCount-1. */
+  const LADSPA_PortRangeHint * PortRangeHints;
+
+  /* This may be used by the plugin developer to pass any custom
+     implementation data into an instantiate call. It must not be used
+     or interpreted by the host. It is expected that most plugin
+     writers will not use this facility as LADSPA_Handle should be
+     used to hold instance data. */
+  void * ImplementationData;
+
+  /* This member is a function pointer that instantiates a plugin. A
+     handle is returned indicating the new plugin instance. The
+     instantiation function accepts a sample rate as a parameter. The
+     plugin descriptor from which this instantiate function was found
+     must also be passed. This function must return NULL if
+     instantiation fails. 
+
+     Note that instance initialisation should generally occur in
+     activate() rather than here. */
+  LADSPA_Handle (*instantiate)(const struct _LADSPA_Descriptor * Descriptor,
+                               unsigned long                     SampleRate);
+
+  /* This member is a function pointer that connects a port on an
+     instantiated plugin to a memory location at which a block of data
+     for the port will be read/written. The data location is expected
+     to be an array of LADSPA_Data for audio ports or a single
+     LADSPA_Data value for control ports. Memory issues will be
+     managed by the host. The plugin must read/write the data at these
+     locations every time run() or run_adding() is called and the data
+     present at the time of this connection call should not be
+     considered meaningful.
+
+     connect_port() may be called more than once for a plugin instance
+     to allow the host to change the buffers that the plugin is
+     reading or writing. These calls may be made before or after
+     activate() or deactivate() calls.
+
+     connect_port() must be called at least once for each port before
+     run() or run_adding() is called. When working with blocks of
+     LADSPA_Data the plugin should pay careful attention to the block
+     size passed to the run function as the block allocated may only
+     just be large enough to contain the block of samples.
+
+     Plugin writers should be aware that the host may elect to use the
+     same buffer for more than one port and even use the same buffer
+     for both input and output (see LADSPA_PROPERTY_INPLACE_BROKEN).
+     However, overlapped buffers or use of a single buffer for both
+     audio and control data may result in unexpected behaviour. */
+   void (*connect_port)(LADSPA_Handle Instance,
+                        unsigned long Port,
+                        LADSPA_Data * DataLocation);
+
+  /* This member is a function pointer that initialises a plugin
+     instance and activates it for use. This is separated from
+     instantiate() to aid real-time support and so that hosts can
+     reinitialise a plugin instance by calling deactivate() and then
+     activate(). In this case the plugin instance must reset all state
+     information dependent on the history of the plugin instance
+     except for any data locations provided by connect_port() and any
+     gain set by set_run_adding_gain(). If there is nothing for
+     activate() to do then the plugin writer may provide a NULL rather
+     than an empty function.
+
+     When present, hosts must call this function once before run() (or
+     run_adding()) is called for the first time. This call should be
+     made as close to the run() call as possible and indicates to
+     real-time plugins that they are now live. Plugins should not rely
+     on a prompt call to run() after activate(). activate() may not be
+     called again unless deactivate() is called first. Note that
+     connect_port() may be called before or after a call to
+     activate(). */
+  void (*activate)(LADSPA_Handle Instance);
+
+  /* This method is a function pointer that runs an instance of a
+     plugin for a block. Two parameters are required: the first is a
+     handle to the particular instance to be run and the second
+     indicates the block size (in samples) for which the plugin
+     instance may run.
+
+     Note that if an activate() function exists then it must be called
+     before run() or run_adding(). If deactivate() is called for a
+     plugin instance then the plugin instance may not be reused until
+     activate() has been called again.
+
+     If the plugin has the property LADSPA_PROPERTY_HARD_RT_CAPABLE
+     then there are various things that the plugin should not do
+     within the run() or run_adding() functions (see above). */
+  void (*run)(LADSPA_Handle Instance,
+              unsigned long SampleCount);
+
+  /* This method is a function pointer that runs an instance of a
+     plugin for a block. This has identical behaviour to run() except
+     in the way data is output from the plugin. When run() is used,
+     values are written directly to the memory areas associated with
+     the output ports. However when run_adding() is called, values
+     must be added to the values already present in the memory
+     areas. Furthermore, output values written must be scaled by the
+     current gain set by set_run_adding_gain() (see below) before
+     addition.
+
+     run_adding() is optional. When it is not provided by a plugin,
+     this function pointer must be set to NULL. When it is provided,
+     the function set_run_adding_gain() must be provided also. */
+  void (*run_adding)(LADSPA_Handle Instance,
+                     unsigned long SampleCount);
+
+  /* This method is a function pointer that sets the output gain for
+     use when run_adding() is called (see above). If this function is
+     never called the gain is assumed to default to 1. Gain
+     information should be retained when activate() or deactivate()
+     are called.
+
+     This function should be provided by the plugin if and only if the
+     run_adding() function is provided. When it is absent this
+     function pointer must be set to NULL. */
+  void (*set_run_adding_gain)(LADSPA_Handle Instance,
+                              LADSPA_Data   Gain);
+
+  /* This is the counterpart to activate() (see above). If there is
+     nothing for deactivate() to do then the plugin writer may provide
+     a NULL rather than an empty function.
+
+     Hosts must deactivate all activated units after they have been
+     run() (or run_adding()) for the last time. This call should be
+     made as close to the last run() call as possible and indicates to
+     real-time plugins that they are no longer live. Plugins should
+     not rely on prompt deactivation. Note that connect_port() may be
+     called before or after a call to deactivate().
+
+     Deactivation is not similar to pausing as the plugin instance
+     will be reinitialised when activate() is called to reuse it. */
+  void (*deactivate)(LADSPA_Handle Instance);
+
+  /* Once an instance of a plugin has been finished with it can be
+     deleted using the following function. The instance handle passed
+     ceases to be valid after this call.
+  
+     If activate() was called for a plugin instance then a
+     corresponding call to deactivate() must be made before cleanup()
+     is called. */
+  void (*cleanup)(LADSPA_Handle Instance);
+
+} LADSPA_Descriptor;
+
+/**********************************************************************/
+
+/* Accessing a Plugin: */
+
+/* The exact mechanism by which plugins are loaded is host-dependent,
+   however all most hosts will need to know is the name of shared
+   object file containing the plugin types. To allow multiple hosts to
+   share plugin types, hosts may wish to check for environment
+   variable LADSPA_PATH. If present, this should contain a
+   colon-separated path indicating directories that should be searched
+   (in order) when loading plugin types.
+
+   A plugin programmer must include a function called
+   "ladspa_descriptor" with the following function prototype within
+   the shared object file. This function will have C-style linkage (if
+   you are using C++ this is taken care of by the `extern "C"' clause
+   at the top of the file).
+
+   A host will find the plugin shared object file by one means or
+   another, find the ladspa_descriptor() function, call it, and
+   proceed from there.
+
+   Plugin types are accessed by index (not ID) using values from 0
+   upwards. Out of range indexes must result in this function
+   returning NULL, so the plugin count can be determined by checking
+   for the least index that results in NULL being returned. */
+
+const LADSPA_Descriptor * ladspa_descriptor(unsigned long Index);
+
+/* Datatype corresponding to the ladspa_descriptor() function. */
+typedef const LADSPA_Descriptor * 
+(*LADSPA_Descriptor_Function)(unsigned long Index);
+
+/**********************************************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LADSPA_INCLUDED */
+
+/* EOF */
diff --git a/lmms/include/ladspa_2_lmms.h b/lmms/include/ladspa_2_lmms.h
new file mode 100644
index 0000000..b85fabe
--- /dev/null
+++ b/lmms/include/ladspa_2_lmms.h
@@ -0,0 +1,78 @@
+/*
+ * ladspa_2_lmms.h - class that identifies and instantiates LADSPA effects
+ *                   for use with LMMS
+ *
+ * Copyright (c) 2005-2008 Danny McRae <khjklujn@netscape.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _LADSPA_2_LMMS_H
+#define _LADSPA_2_LMMS_H
+
+
+#include "ladspa_manager.h"
+
+
+class EXPORT ladspa2LMMS : public ladspaManager
+{
+public:
+	
+	inline l_sortable_plugin_t getInstruments()
+	{
+		return( m_instruments );
+	}
+	
+	inline l_sortable_plugin_t getValidEffects()
+	{
+		return( m_validEffects );
+	}
+	
+	inline l_sortable_plugin_t getInvalidEffects()
+	{
+		return( m_invalidEffects );
+	}
+	
+	inline l_sortable_plugin_t getAnalysisTools()
+	{
+		return( m_analysisTools );
+	}
+	
+	inline l_sortable_plugin_t getOthers()
+	{
+		return( m_otherPlugins );
+	}
+	
+	QString getShortName( const ladspa_key_t & _key );
+
+private:
+	ladspa2LMMS();
+	virtual ~ladspa2LMMS();
+
+	l_sortable_plugin_t m_instruments;
+	l_sortable_plugin_t m_validEffects;
+	l_sortable_plugin_t m_invalidEffects;
+	l_sortable_plugin_t m_analysisTools;
+	l_sortable_plugin_t m_otherPlugins;
+	
+	friend class engine;
+
+} ;
+
+#endif
diff --git a/lmms/include/ladspa_manager.h b/lmms/include/ladspa_manager.h
new file mode 100644
index 0000000..b534a2d
--- /dev/null
+++ b/lmms/include/ladspa_manager.h
@@ -0,0 +1,338 @@
+/*
+ * ladspa_manager.h - declaration of class ladspaManager
+ *                    a class to manage loading and instantiation
+ *                    of ladspa plugins
+ *
+ * Copyright (c) 2005-2008 Danny McRae <khjklujn@netscape.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _LADSPA_MANAGER_H
+#define _LADSPA_MANAGER_H
+
+#include <ladspa.h>
+
+#include <QtCore/QMap>
+#include <QtCore/QPair>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+
+
+#include "export.h"
+#include "lmms_basics.h"
+
+
+const float NOHINT = -99342.2243f;
+
+typedef QPair<QString, QString> ladspa_key_t;
+typedef QPair<QString, ladspa_key_t> sortable_plugin_t;
+typedef QList<sortable_plugin_t> l_sortable_plugin_t;
+typedef QList<ladspa_key_t> l_ladspa_key_t;
+
+/* ladspaManager provides a database of LADSPA plug-ins.  Upon instantiation,
+it loads all of the plug-ins found in the LADSPA_PATH environmental variable
+and stores their access descriptors according in a dictionary keyed on
+the filename the plug-in was loaded from and the label of the plug-in.
+
+The can be retrieved by using ladspa_key_t.  For example, to get the 
+"Phase Modulated Voice" plug-in from the cmt library, you would perform the
+calls using:
+
+	ladspa_key_t key( "cmt.so", "phasemod" )
+	
+as the plug-in key. */
+
+enum ladspaPluginType
+{
+	SOURCE,
+	TRANSFER,
+	VALID,
+	INVALID,
+	SINK,
+	OTHER
+};
+
+typedef struct ladspaManagerStorage
+{
+	LADSPA_Descriptor_Function descriptorFunction;
+	uint32_t index;
+	ladspaPluginType type;
+	uint16_t inputChannels;
+	uint16_t outputChannels;
+} ladspaManagerDescription;
+
+
+class EXPORT ladspaManager
+{
+public:
+	
+	ladspaManager();
+	virtual ~ladspaManager();
+
+	l_sortable_plugin_t getSortedPlugins();
+	ladspaManagerDescription * getDescription( const ladspa_key_t & 
+								_plugin );
+	
+	/* This identifier can be used as a unique, case-sensitive
+	identifier for the plugin type within the plugin file. Plugin
+	types should be identified by file and label rather than by index
+	or plugin name, which may be changed in new plugin
+	versions. Labels must not contain white-space characters. */
+	QString  getLabel( const ladspa_key_t & _plugin );
+
+	/* Indicates that the plugin has a real-time dependency
+	(e.g. listens to a MIDI device) and so its output must not
+	be cached or subject to significant latency. */
+	bool  hasRealTimeDependency( const ladspa_key_t & _plugin );
+
+	/* Indicates that the plugin may cease to work correctly if the 
+	host elects to use the same data location for both input and output
+	(see connectPort). */
+	bool  isInplaceBroken( const ladspa_key_t & _plugin );
+
+	/* Indicates that the plugin is capable of running not only in a
+	conventional host but also in a 'hard real-time' environment. */
+	bool  isRealTimeCapable( const ladspa_key_t & _plugin );
+
+	/* Returns the name of the plug-in */
+	QString  getName( const ladspa_key_t & _plugin );
+
+	/* Returns the the plug-in's author */
+	QString  getMaker( const ladspa_key_t & _plugin );
+
+	/* Returns the copyright for the plug-in */
+	QString  getCopyright( const ladspa_key_t & _plugin );
+
+  	/* This indicates the number of ports (input AND output) present on
+	the plugin. */
+	uint32_t  getPortCount( const ladspa_key_t & _plugin );
+
+
+	/* Indicates that the port is an input. */
+	bool  isPortInput( const ladspa_key_t & _plugin, uint32_t _port );
+
+	/* Indicates that the port is an output. */
+	bool  isPortOutput( const ladspa_key_t & _plugin, uint32_t _port );
+
+	/* Indicates that the port is an audio. */
+	bool  isPortAudio( const ladspa_key_t & _plugin, uint32_t _port );
+
+	/* Indicates that the port is an control. */
+	bool  isPortControl( const ladspa_key_t & _plugin, uint32_t _port );
+
+	/* Indicates that any bounds specified should be interpreted as 
+	multiples of the sample rate. For instance, a frequency range from 
+	0Hz to the Nyquist frequency (half the sample rate) could be requested 
+	by this hint in conjunction with LowerBound = 0 and UpperBound = 0.5. 
+	Hosts that support bounds at all must support this hint to retain
+	meaning. */
+	bool  areHintsSampleRateDependent( const ladspa_key_t & _plugin, 
+								uint32_t _port );
+
+  	/* Returns the lower boundary value for the given port. If
+	no lower bound is provided by the plug-in, returns -999e-99. When
+	areHintsSampleRateDependent() is also true then this value should be
+	multiplied by the relevant sample rate. */
+	float  getLowerBound( const ladspa_key_t & _plugin, uint32_t _port );
+
+  	/* Returns the upper boundary value for the given port. If
+	no upper bound is provided by the plug-in, returns -999e-99. When
+	areHintsSampleRateDependent() is also true then this value should be
+	multiplied by the relevant sample rate. */
+	float  getUpperBound( const ladspa_key_t & _plugin, uint32_t _port );
+
+	/* Indicates whether the given port should be considered 0 or 1
+	boolean switch. */
+	bool  isPortToggled( const ladspa_key_t & _plugin, uint32_t _port );
+
+	/* Retrieves any default setting hints offered by the plug-in for
+	the given port. */
+	float  getDefaultSetting( const ladspa_key_t & _plugin, uint32_t _port );
+
+	/* Indicates that it is likely that the user will find it more
+	intuitive to view values using a logarithmic scale. This is
+	particularly useful for frequencies and gains. */
+	bool  isLogarithmic( const ladspa_key_t & _plugin, uint32_t _port );
+
+	/* Indicates that a user interface would probably wish to provide a 
+	stepped control taking only integer values. Any bounds set should be 
+	slightly wider than the actual integer range required to avoid floating
+	point rounding errors. For instance, the integer set {0,1,2,3} might 
+	be described as [-0.1, 3.1]. */
+	bool  isInteger( const ladspa_key_t & _plugin, uint32_t _port );
+	
+	/* Returns the name of the port. */
+	QString  getPortName( const ladspa_key_t & _plugin, uint32_t _port );
+	
+	
+	/* This may be used by the plugin developer to pass any custom
+	implementation data into an instantiate call. It must not be used
+	or interpreted by the host. It is expected that most plugin
+	writers will not use this facility as LADSPA_Handle should be
+	used to hold instance data. */
+	const void *  getImplementationData(
+						const ladspa_key_t & _plugin );
+	
+	
+	/* Returns a pointer to the plug-in's descriptor from which control
+	of the plug-in is accessible */
+	const LADSPA_Descriptor *  getDescriptor(
+						const ladspa_key_t & _plugin );
+	
+	
+	/* The following methods are convenience functions for use during
+	development.  A real instrument should use the getDescriptor()
+	method and implement the plug-in manipulations internally to avoid
+	the overhead associated with QMap lookups. */
+	
+	
+	/* Returns a handle to an instantiation of the given plug-in. */
+	LADSPA_Handle  instantiate( const ladspa_key_t & _plugin, 
+						uint32_t _sample_rate );
+	
+  	/* This method calls a function pointer that connects a port on an
+	instantiated plugin to a memory location at which a block of data
+	for the port will be read/written. The data location is expected
+	to be an array of LADSPA_Data for audio ports or a single
+	LADSPA_Data value for control ports. Memory issues will be
+	managed by the host. The plugin must read/write the data at these
+	locations every time run() or runAdding() is called and the data
+	present at the time of this connection call should not be
+	considered meaningful.
+
+	connectPort() may be called more than once for a plugin instance
+	to allow the host to change the buffers that the plugin is
+	reading or writing. These calls may be made before or after
+	activate() or deactivate() calls.
+
+	connectPort() must be called at least once for each port before
+	run() or runAdding() is called. */
+	bool  connectPort( const ladspa_key_t & _plugin, 
+					LADSPA_Handle _instance, 
+					uint32_t _port,
+					LADSPA_Data * _data_location );
+	
+  	/* This method calls a function pointer that initialises a plugin
+	instance and activates it for use. This is separated from
+	instantiate() to aid real-time support and so that hosts can
+	reinitialise a plugin instance by calling deactivate() and then
+	activate(). In this case the plugin instance must reset all state
+	information dependent on the history of the plugin instance
+	except for any data locations provided by connectPort() and any
+	gain set by setRunAddingGain(). If there is nothing for
+	activate() to do then the plugin writer may provide a NULL rather
+	than an empty function.
+
+	When present, hosts must call this function once before run() (or
+	runAdding()) is called for the first time. This call should be
+	made as close to the run() call as possible and indicates to
+	real-time plugins that they are now live. Plugins should not rely
+	on a prompt call to run() after activate(). activate() may not be
+	called again unless deactivate() is called first. Note that
+	connectPort() may be called before or after a call to
+	activate(). */
+	bool  activate( const ladspa_key_t & _plugin,
+						LADSPA_Handle _instance );
+
+	/* This method calls a function pointer that runs an instance of a
+	plugin for a block. Two parameters are required: the first is a
+	handle to the particular instance to be run and the second
+	indicates the block size (in samples) for which the plugin
+	instance may run.
+
+	Note that if an activate() function exists then it must be called
+	before run() or run_adding(). If deactivate() is called for a
+	plugin instance then the plugin instance may not be reused until
+	activate() has been called again. */
+	bool  run( const ladspa_key_t & _plugin, 
+					LADSPA_Handle _instance,
+					uint32_t _sample_count );
+
+	/* This method calls a function pointer that runs an instance of a
+	plugin for a block. This has identical behaviour to run() except
+	in the way data is output from the plugin. When run() is used,
+	values are written directly to the memory areas associated with
+	the output ports. However when runAdding() is called, values
+	must be added to the values already present in the memory
+	areas. Furthermore, output values written must be scaled by the
+	current gain set by setRunAddingGain() (see below) before
+	addition.
+
+	runAdding() is optional. When it is not provided by a plugin,
+	this function pointer must be set to NULL. When it is provided,
+	the function setRunAddingGain() must be provided also. */
+	bool  runAdding( const ladspa_key_t & _plugin,
+						LADSPA_Handle _instance,
+						uint32_t _sample_count );
+
+  	/* This method calls a function pointer that sets the output gain for
+	use when runAdding() is called (see above). If this function is
+	never called the gain is assumed to default to 1. Gain
+	information should be retained when activate() or deactivate()
+	are called.
+
+	This function should be provided by the plugin if and only if the
+	runAdding() function is provided. When it is absent this
+	function pointer must be set to NULL. */
+	bool  setRunAddingGain( const ladspa_key_t & _plugin,
+						LADSPA_Handle _instance,
+						LADSPA_Data _gain );
+
+	/* This is the counterpart to activate() (see above). If there is
+	nothing for deactivate() to do then the plugin writer may provide
+	a NULL rather than an empty function.
+
+	Hosts must deactivate all activated units after they have been
+	run() (or run_adding()) for the last time. This call should be
+	made as close to the last run() call as possible and indicates to
+	real-time plugins that they are no longer live. Plugins should
+	not rely on prompt deactivation. Note that connect_port() may be
+	called before or after a call to deactivate().
+
+	Deactivation is not similar to pausing as the plugin instance
+	will be reinitialised when activate() is called to reuse it. */
+	bool  deactivate( const ladspa_key_t & _plugin,
+						LADSPA_Handle _instance );
+
+	/* Once an instance of a plugin has been finished with it can be
+	deleted using the following function. The instance handle passed
+	ceases to be valid after this call.
+  
+	If activate() was called for a plugin instance then a
+	corresponding call to deactivate() must be made before cleanup()
+	is called. */
+	bool  cleanup( const ladspa_key_t & _plugin,
+						LADSPA_Handle _instance );
+
+private:
+	void  addPlugins( LADSPA_Descriptor_Function _descriptor_func,
+						const QString & _file );
+	uint16_t  getPluginInputs( const LADSPA_Descriptor * _descriptor );
+	uint16_t  getPluginOutputs( const LADSPA_Descriptor * _descriptor );
+	
+	typedef QMap<ladspa_key_t, ladspaManagerDescription *>
+						ladspaManagerMapType;
+	ladspaManagerMapType m_ladspaManagerMap;
+	l_sortable_plugin_t m_sortedPlugins;
+
+} ;
+
+#endif
diff --git a/lmms/include/led_checkbox.h b/lmms/include/led_checkbox.h
new file mode 100644
index 0000000..edb9e40
--- /dev/null
+++ b/lmms/include/led_checkbox.h
@@ -0,0 +1,71 @@
+/*
+ * led_checkbox.h - class ledCheckBox, an improved QCheckBox
+ *
+ * Copyright (c) 2005-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _LED_CHECKBOX_H
+#define _LED_CHECKBOX_H
+
+#include "automatable_button.h"
+
+
+class QPixmap;
+
+
+class EXPORT ledCheckBox : public automatableButton
+{
+	Q_OBJECT
+public:
+	enum LedColors
+	{
+		Yellow,
+		Green,
+		Red,
+		NumColors
+	} ;
+
+	ledCheckBox( const QString & _txt, QWidget * _parent,
+				const QString & _name = QString::null,
+						LedColors _color = Yellow );
+	virtual ~ledCheckBox();
+
+
+	inline const QString & text()
+	{
+		return( m_text );
+	}
+
+
+protected:
+	virtual void paintEvent( QPaintEvent * _pe );
+
+
+private:
+	QPixmap * m_ledOnPixmap;
+	QPixmap * m_ledOffPixmap;
+	
+	QString m_text;
+
+} ;
+
+#endif
diff --git a/lmms/include/lmms_basics.h b/lmms/include/lmms_basics.h
new file mode 100644
index 0000000..2805bb4
--- /dev/null
+++ b/lmms/include/lmms_basics.h
@@ -0,0 +1,142 @@
+/*
+ * types.h - typedefs for common types that are used in the whole app
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TYPES_H
+#define _TYPES_H
+
+#include <limits>
+
+#include "lmmsconfig.h"
+
+#ifdef LMMS_HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
+
+typedef int32_t tact_t;
+typedef int32_t tick_t;
+typedef uint8_t volume_t;
+typedef int8_t panning_t;
+
+
+typedef float sample_t;			// standard sample-type
+typedef int16_t int_sample_t;		// 16-bit-int-sample
+
+
+typedef uint32_t sample_rate_t;		// sample-rate
+typedef int16_t fpp_t;			// frames per period (0-16384)
+typedef int32_t f_cnt_t;			// standard frame-count
+typedef uint8_t ch_cnt_t;			// channel-count (0-SURROUND_CHANNELS)
+typedef uint16_t bpm_t;			// tempo (MIN_BPM to MAX_BPM)
+typedef uint16_t bitrate_t;		// bitrate in kbps
+typedef uint16_t fx_ch_t;			// FX-channel (0 to MAX_EFFECT_CHANNEL)
+
+typedef uint32_t jo_id_t;			// (unique) ID of a journalling object
+
+// use for improved branch prediction
+#define likely(x)	__builtin_expect((x),1)
+#define unlikely(x)	__builtin_expect((x),0)
+
+
+template<typename T>
+struct typeInfo
+{
+	static inline T min()
+	{
+		return std::numeric_limits<T>::min();
+	}
+
+	static inline T max()
+	{
+		return std::numeric_limits<T>::max();
+	}
+
+	static inline T minEps()
+	{
+		return 1;
+	}
+
+	static inline bool isEqual( T _x, T _y )
+	{
+		return _x == _y;
+	}
+
+	static inline T absVal( T t )
+	{
+		return t >= 0 ? t : -t;
+	}
+} ;
+
+
+template<>
+inline float typeInfo<float>::minEps()
+{
+	return 1.0e-10;
+}
+	
+template<>
+inline bool typeInfo<float>::isEqual( float _x, float _y )
+{
+	if( likely( _x == _y ) )
+	{
+		return true;
+	}
+	return absVal( _x - _y ) < minEps();
+}
+
+
+
+const ch_cnt_t DEFAULT_CHANNELS = 2;
+
+const ch_cnt_t SURROUND_CHANNELS =
+#define LMMS_DISABLE_SURROUND
+#ifndef LMMS_DISABLE_SURROUND
+				4;
+#else
+				2;
+#endif
+
+
+#ifdef LMMS_BUILD_WIN32
+#define LADSPA_PATH_SEPERATOR ';'
+#else
+#define LADSPA_PATH_SEPERATOR ':'
+#endif
+
+
+
+typedef sample_t sampleFrame[DEFAULT_CHANNELS];
+typedef sample_t surroundSampleFrame[SURROUND_CHANNELS];
+#define ALIGN_SIZE 16
+#if __GNUC__
+typedef sample_t sampleFrameA[DEFAULT_CHANNELS] __attribute__((__aligned__(ALIGN_SIZE)));
+#endif
+
+
+#define STRINGIFY(s) STR(s)
+#define STR(PN)	#PN
+
+
+#endif
diff --git a/lmms/include/lmms_constants.h b/lmms/include/lmms_constants.h
new file mode 100644
index 0000000..190d963
--- /dev/null
+++ b/lmms/include/lmms_constants.h
@@ -0,0 +1,33 @@
+/*
+ * lmms_constants.h - defines system constants
+ *
+ * Copyright (c) 2006 Danny McRae <khjklujn/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _LMMS_CONSTANTS_H
+#define _LMMS_CONSTANTS_H
+
+const float F_PI = 3.1415926535f;
+const float F_2PI = 2*F_PI;
+const float F_PI_2 = F_PI*0.5;
+
+#endif
+
diff --git a/lmms/include/lmms_math.h b/lmms/include/lmms_math.h
new file mode 100644
index 0000000..57454ac
--- /dev/null
+++ b/lmms/include/lmms_math.h
@@ -0,0 +1,110 @@
+/*
+ * lmms_math.h - defines math functions
+ *
+ * Copyright (c) 2004-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _LMMS_MATH_H
+#define _LMMS_MATH_H
+
+
+#ifdef __INTEL_COMPILER
+
+#include <math.h>
+
+static inline float absFraction( const float _x )
+{
+	return( _x - ( _x >= 0.0f ? floorf( _x ) : floorf( _x ) - 1 ) );
+}
+
+static inline float fraction( const float _x )
+{
+	return( _x - floorf( _x ) );
+}
+
+#else
+
+static inline float absFraction( const float _x )
+{
+	return( _x - ( _x >= 0.0f ? static_cast<int>( _x ) :
+						static_cast<int>( _x ) - 1 ) );
+}
+
+static inline float fraction( const float _x )
+{
+	return( _x - static_cast<int>( _x ) );
+}
+
+
+#if 0
+// SSE3-version
+static inline float absFraction( float _x )
+{
+	unsigned int tmp;
+	asm(
+		"fld %%st\n\t"
+		"fisttp %1\n\t"
+		"fild %1\n\t"
+		"ftst\n\t"
+		"sahf\n\t"
+		"jae 1f\n\t"
+		"fld1\n\t"
+		"fsubrp %%st, %%st(1)\n\t"
+	"1:\n\t"
+		"fsubrp %%st, %%st(1)"
+		: "+t"( _x ), "=m"( tmp )
+		:
+		: "st(1)", "cc" );
+	return( _x );
+}
+
+static inline float absFraction( float _x )
+{
+	unsigned int tmp;
+	asm(
+		"fld %%st\n\t"
+		"fisttp %1\n\t"
+		"fild %1\n\t"
+		"fsubrp %%st, %%st(1)"
+		: "+t"( _x ), "=m"( tmp )
+		:
+		: "st(1)" );
+	return( _x );
+}
+#endif
+
+#endif
+
+
+
+#define FAST_RAND_MAX 32767
+static inline int fast_rand()
+{
+	static unsigned long next = 1;
+	next = next * 1103515245 + 12345;
+	return( (unsigned)( next / 65536 ) % 32768 );
+}
+
+
+
+
+#endif
diff --git a/lmms/include/mmp.h b/lmms/include/mmp.h
new file mode 100644
index 0000000..d76a8f5
--- /dev/null
+++ b/lmms/include/mmp.h
@@ -0,0 +1,113 @@
+/*
+ * mmp.h - class for reading and writing multimedia-project-files
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * Copyright (c) 2012-2013 Paul Giblock <p/at/pgiblock.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _MMP_H
+#define _MMP_H
+
+#include <QtXml/QDomDocument>
+#include <QTextStream>
+
+#include "export.h"
+#include "lmms_basics.h"
+
+
+class EXPORT multimediaProject : public QDomDocument
+{
+public:
+	enum ProjectTypes
+	{
+		UnknownType,
+		SongProject,
+		SongProjectTemplate,
+		InstrumentTrackSettings,
+		DragNDropData,
+		ClipboardData,
+		JournalData,
+		EffectSettings,
+		VideoProject,		// might come later...
+		BurnProject,		// might come later...
+		Playlist,		// might come later...
+		NumProjectTypes
+	} ;
+
+
+	multimediaProject( const QString & _fileName );
+	multimediaProject( const QByteArray & _data );
+	multimediaProject( ProjectTypes _project_type );
+	virtual ~multimediaProject();
+
+	QString nameWithExtension( const QString & _fn ) const;
+
+	void write( QTextStream & _strm );
+	bool writeFile( const QString & _fn );
+
+	inline QDomElement & content()
+	{
+		return( m_content );
+	}
+	inline QDomElement & head()
+	{
+		return( m_head );
+	}
+
+	inline ProjectTypes type() const
+	{
+		return( m_type );
+	}
+
+
+private:
+	static ProjectTypes type( const QString & _type_name );
+	static QString typeName( ProjectTypes _project_type );
+
+	void cleanMetaNodes( QDomElement _de );
+
+	void upgrade();
+
+	void loadData( const QByteArray & _data, const QString & _sourceFile );
+
+
+	struct EXPORT typeDescStruct
+	{
+		ProjectTypes m_type;
+		QString m_name;
+	} ;
+	static typeDescStruct s_types[NumProjectTypes];
+
+	QDomElement m_content;
+	QDomElement m_head;
+	ProjectTypes m_type;
+
+} ;
+
+
+const int MMP_MAJOR_VERSION = 1;
+const int MMP_MINOR_VERSION = 0;
+const QString MMP_VERSION_STRING = QString::number( MMP_MAJOR_VERSION ) + "." + QString::number( MMP_MINOR_VERSION );
+
+
+#endif
+
diff --git a/lmms/include/note.h b/lmms/include/note.h
new file mode 100644
index 0000000..924ae7b
--- /dev/null
+++ b/lmms/include/note.h
@@ -0,0 +1,254 @@
+/*
+ * note.h - declaration of class note which contains all informations about a
+ *          note + definitions of several constants and enums
+ *
+ * Copyright (c) 2004-2010 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _NOTE_H
+#define _NOTE_H
+
+#include <QtCore/QVector>
+
+#include "volume.h"
+#include "panning.h"
+#include "MidiTime.h"
+#include "SerializingObject.h"
+
+class DetuningHelper;
+
+
+enum Keys
+{
+	Key_C = 0,
+	Key_CIS = 1, Key_DES = 1,
+	Key_D = 2,
+	Key_DIS = 3, Key_ES = 3,
+	Key_E = 4, Key_FES = 4,
+	Key_F = 5,
+	Key_FIS = 6, Key_GES = 6,
+	Key_G = 7,
+	Key_GIS = 8, Key_AS = 8,
+	Key_A = 9,
+	Key_AIS = 10, Key_B = 10,
+	Key_H = 11 
+} ;
+
+
+enum Octaves
+{
+	Octave_0,
+	Octave_1,
+	Octave_2,
+	Octave_3,
+	Octave_4, DefaultOctave = Octave_4,
+	Octave_5,
+	Octave_6,
+	Octave_7,
+	Octave_8,
+	NumOctaves
+} ;
+
+
+const int WhiteKeysPerOctave = 7;
+const int BlackKeysPerOctave = 5;
+const int KeysPerOctave = WhiteKeysPerOctave + BlackKeysPerOctave;
+const int NumKeys = NumOctaves * KeysPerOctave;
+const int DefaultKey = DefaultOctave*KeysPerOctave + Key_A;
+
+const float MaxDetuning = 4 * 12.0f;
+
+
+
+class EXPORT note : public SerializingObject
+{
+public:
+	note( const MidiTime & _length = MidiTime( 0 ),
+		const MidiTime & _pos = MidiTime( 0 ),
+		int key = DefaultKey,
+		volume_t _volume = DefaultVolume,
+		panning_t _panning = DefaultPanning,
+		DetuningHelper * _detuning = NULL );
+	note( const note & _note );
+	virtual ~note();
+	
+	// used by GUI
+	inline void setSelected( const bool _selected ){ m_selected = _selected; }
+	inline void setOldKey( const int _oldKey ){ m_oldKey = _oldKey; }
+	inline void setOldPos( const MidiTime & _oldPos ){ m_oldPos = _oldPos; }
+	inline void setOldLength( const MidiTime & _oldLength )
+	{
+		m_oldLength = _oldLength;
+	}
+	inline void setIsPlaying( const bool _isPlaying )
+	{
+		m_isPlaying = _isPlaying;
+	}
+	
+	
+	void setLength( const MidiTime & _length );
+	void setPos( const MidiTime & _pos );
+	void setKey( const int _key );
+	virtual void setVolume( volume_t volume );
+	virtual void setPanning( panning_t panning );
+	void quantizeLength( const int _q_grid );
+	void quantizePos( const int _q_grid );
+
+	static inline bool lessThan( note * &lhs, note * &rhs )
+	{
+		// function to compare two notes - must be called explictly when
+		// using qSort
+		return (bool) ((int) ( *lhs ).pos() < (int) ( *rhs ).pos());
+	}
+
+	inline bool selected() const
+	{
+		return m_selected;
+	}
+
+	inline int oldKey() const
+	{
+		return m_oldKey;
+	}
+
+	inline MidiTime oldPos() const
+	{
+		return m_oldPos;
+	}
+
+	inline MidiTime oldLength() const
+	{
+		return m_oldLength;
+	}
+
+	inline bool isPlaying() const
+	{
+		return m_isPlaying;
+	}
+
+	inline MidiTime endPos() const
+	{
+		const int l = length();
+		return pos() + l;
+	}
+
+	inline const MidiTime & length() const
+	{
+		return m_length;
+	}
+
+	inline const MidiTime & pos() const
+	{
+		return m_pos;
+	}
+
+	inline MidiTime pos( MidiTime _base_pos ) const
+	{
+		const int bp = _base_pos;
+		return m_pos - bp;
+	}
+
+	inline int key() const
+	{
+		return m_key;
+	}
+
+	inline volume_t getVolume() const
+	{
+		return m_volume;
+	}
+
+	int midiVelocity( int midiBaseVelocity ) const
+	{
+		return qMin( MidiMaxVelocity, getVolume() * midiBaseVelocity / DefaultVolume );
+	}
+
+	inline panning_t getPanning() const
+	{
+		return m_panning;
+	}
+
+	static QString classNodeName()
+	{
+		return "note";
+	}
+
+	inline virtual QString nodeName() const
+	{
+		return classNodeName();
+	}
+
+	static MidiTime quantized( const MidiTime & _m, const int _q_grid );
+
+	DetuningHelper * detuning() const
+	{
+		return m_detuning;
+	}
+
+	void editDetuningPattern();
+
+	bool hasDetuningInfo() const;
+
+
+protected:
+	virtual void saveSettings( QDomDocument & _doc,
+							QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+/*	virtual void undoStep( JournalEntry & _je );
+	virtual void redoStep( JournalEntry & _je );*/
+
+
+private:
+/*	enum Actions
+	{
+		ChangeKey,
+		ChangeVolume,
+		ChangePanning,
+		ChangeLength,
+		ChangePosition
+	} ;*/
+
+	
+	// for piano roll editing
+	bool m_selected; 
+	int m_oldKey;
+	MidiTime m_oldPos;
+	MidiTime m_oldLength;
+	bool m_isPlaying;
+	
+	int m_key;
+	volume_t m_volume;
+	panning_t m_panning;
+	MidiTime m_length;
+	MidiTime m_pos;
+	DetuningHelper * m_detuning;
+
+	void createDetuning();
+
+} ;
+
+
+typedef QVector<note *> NoteVector;
+
+
+#endif
+
diff --git a/lmms/include/nstate_button.h b/lmms/include/nstate_button.h
new file mode 100644
index 0000000..b866653
--- /dev/null
+++ b/lmms/include/nstate_button.h
@@ -0,0 +1,75 @@
+/*
+ * nstate_button.h - declaration of class nStateButton
+ *
+ * Copyright (c) 2005 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _NSTATE_BUTTON_H
+#define _NSTATE_BUTTON_H
+
+#include <QtGui/QPixmap>
+#include <QtCore/QVector>
+#include <QtCore/QPair>
+
+#include "tool_button.h"
+
+
+class nStateButton : public toolButton
+{
+	Q_OBJECT
+public:
+	nStateButton( QWidget * _parent );
+	virtual ~nStateButton();
+	void addState( const QPixmap & _pixmap, const QString & _tooltip = "" );
+
+	inline void setGeneralToolTip( const QString & _tooltip )
+	{
+		m_generalToolTip = _tooltip;
+	}
+
+	inline int state() const
+	{
+		return( m_curState );
+	}
+
+
+public slots:
+	void changeState( int _n );
+
+
+signals:
+	void changedState( int _n );
+
+
+protected:
+	virtual void mousePressEvent( QMouseEvent * _me );
+
+
+private:
+	QVector<QPair<QPixmap, QString> > m_states;
+	QString m_generalToolTip;
+
+	int m_curState;
+
+} ;
+
+#endif
diff --git a/lmms/include/panning.h b/lmms/include/panning.h
new file mode 100644
index 0000000..60188e3
--- /dev/null
+++ b/lmms/include/panning.h
@@ -0,0 +1,53 @@
+/*
+ * panning.h - declaration of some types, concerning the
+ *             panning of a note
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PANNING_H
+#define _PANNING_H
+
+#include "lmms_basics.h"
+#include "volume.h"
+#include "templates.h"
+#include "panning_constants.h"
+#include "Midi.h"
+
+inline stereoVolumeVector panningToVolumeVector( panning_t _p,
+							float _scale = 1.0f )
+{
+	stereoVolumeVector v = { { _scale, _scale } };
+	const float pf = _p / 100.0f;
+	v.vol[_p >= PanningCenter ? 0 : 1] *= 1.0f - qAbs<float>( pf );
+	return v;
+}
+
+
+inline int panningToMidi( panning_t _p )
+{
+	return MidiMinPanning + (int) (
+			  ( (float)( _p - PanningLeft ) ) / 
+			  ( (float)( PanningRight - PanningLeft ) ) *
+			  ( (float)( MidiMaxPanning - MidiMinPanning ) ) );
+}
+
+#endif
diff --git a/lmms/include/panning_constants.h b/lmms/include/panning_constants.h
new file mode 100644
index 0000000..7bb58c7
--- /dev/null
+++ b/lmms/include/panning_constants.h
@@ -0,0 +1,34 @@
+/*
+ * panning_constants.h - declaration of some constants, concerning the
+ *             panning of a note
+ *
+ * Copyright (c) 2004-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PANNING_CONSTANTS_H
+#define _PANNING_CONSTANTS_H
+
+const panning_t PanningRight = ( 0 + 100 );
+const panning_t PanningLeft = - PanningRight;
+const panning_t PanningCenter = 0;
+const panning_t DefaultPanning = PanningCenter;
+
+#endif
diff --git a/lmms/include/pattern.h b/lmms/include/pattern.h
new file mode 100644
index 0000000..c3985ff
--- /dev/null
+++ b/lmms/include/pattern.h
@@ -0,0 +1,193 @@
+/*
+ * pattern.h - declaration of class pattern, which contains all informations
+ *             about a pattern
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef PATTERN_H
+#define PATTERN_H
+
+#include <QtCore/QVector>
+#include <QtGui/QWidget>
+#include <QtGui/QDialog>
+#include <QtCore/QThread>
+#include <QtGui/QPixmap>
+
+
+#include "note.h"
+#include "track.h"
+
+
+class QAction;
+class QProgressBar;
+class QPushButton;
+
+class InstrumentTrack;
+class SampleBuffer;
+
+
+
+class EXPORT pattern : public trackContentObject
+{
+	Q_OBJECT
+public:
+	enum PatternTypes
+	{
+		BeatPattern,
+		MelodyPattern
+	} ;
+
+	pattern( InstrumentTrack * _instrument_track );
+	pattern( const pattern & _pat_to_copy );
+	virtual ~pattern();
+
+	void init();
+
+
+	virtual MidiTime length() const;
+	MidiTime beatPatternLength() const;
+
+	// note management
+	note * addNote( const note & _new_note, const bool _quant_pos = true );
+
+	void removeNote( const note * _note_to_del );
+
+	note * noteAtStep( int _step );
+
+	note * rearrangeNote( const note * _note_to_proc,
+						const bool _quant_pos = true );
+	void rearrangeAllNotes();
+	void clearNotes();
+
+	inline const NoteVector & notes() const
+	{
+		return m_notes;
+	}
+
+	void setStep( int _step, bool _enabled );
+
+	// pattern-type stuff
+	inline PatternTypes type() const
+	{
+		return m_patternType;
+	}
+	void setType( PatternTypes _new_pattern_type );
+	void checkType();
+
+
+	// settings-management
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+	inline virtual QString nodeName() const
+	{
+		return "pattern";
+	}
+
+	inline InstrumentTrack * instrumentTrack() const
+	{
+		return m_instrumentTrack;
+	}
+
+	bool empty();
+
+
+	virtual trackContentObjectView * createView( trackView * _tv );
+
+
+	using Model::dataChanged;
+
+
+protected:
+	void ensureBeatNotes();
+	void updateBBTrack();
+
+
+protected slots:
+	void addSteps();
+	void removeSteps();
+	void clear();
+	void changeTimeSignature();
+
+
+private:
+	InstrumentTrack * m_instrumentTrack;
+
+	PatternTypes m_patternType;
+
+	// data-stuff
+	NoteVector m_notes;
+	int m_steps;
+
+	friend class patternView;
+	friend class bbEditor;
+
+} ;
+
+
+
+class patternView : public trackContentObjectView
+{
+	Q_OBJECT
+public:
+	patternView( pattern * _pattern, trackView * _parent );
+	virtual ~patternView();
+
+
+public slots:
+	virtual void update();
+
+
+protected slots:
+	void openInPianoRoll();
+
+	void resetName();
+	void changeName();
+
+
+protected:
+	virtual void constructContextMenu( QMenu * );
+	virtual void mouseDoubleClickEvent( QMouseEvent * _me );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void resizeEvent( QResizeEvent * _re )
+	{
+		m_needsUpdate = true;
+		trackContentObjectView::resizeEvent( _re );
+	}
+	virtual void wheelEvent( QWheelEvent * _we );
+
+
+private:
+	static QPixmap * s_stepBtnOn;
+	static QPixmap * s_stepBtnOverlay;
+	static QPixmap * s_stepBtnOff;
+	static QPixmap * s_stepBtnOffLight;
+
+	pattern * m_pat;
+	QPixmap m_paintPixmap;
+	bool m_needsUpdate;
+
+} ;
+
+
+
+#endif
diff --git a/lmms/include/pixmap_button.h b/lmms/include/pixmap_button.h
new file mode 100644
index 0000000..d15c4b9
--- /dev/null
+++ b/lmms/include/pixmap_button.h
@@ -0,0 +1,64 @@
+/*
+ * pixmap_button.h - declaration of class pixmapButton
+ *
+ * Copyright (c) 2004-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _PIXMAP_BUTTON_H
+#define _PIXMAP_BUTTON_H
+
+#include <QtGui/QPixmap>
+
+#include "automatable_button.h"
+
+
+class EXPORT pixmapButton : public automatableButton
+{
+	Q_OBJECT
+public:
+	pixmapButton( QWidget * _parent,
+					const QString & _name = QString::null );
+	virtual ~pixmapButton();
+
+	void setActiveGraphic( const QPixmap & _pm );
+	void setInactiveGraphic( const QPixmap & _pm, bool _update = true );
+
+
+signals:
+	void doubleClicked();
+
+
+protected:
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+	virtual void mouseDoubleClickEvent( QMouseEvent * _me );
+
+
+private:
+	QPixmap m_activePixmap;
+	QPixmap m_inactivePixmap;
+	bool	m_pressed;
+
+} ;
+
+#endif
diff --git a/lmms/include/plugin_browser.h b/lmms/include/plugin_browser.h
new file mode 100644
index 0000000..b0473b7
--- /dev/null
+++ b/lmms/include/plugin_browser.h
@@ -0,0 +1,87 @@
+/*
+ * plugin_browser.h - include file for pluginBrowser
+ *
+ * Copyright (c) 2005-2009 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _PLUGIN_BROWSER_H
+#define _PLUGIN_BROWSER_H
+
+#include <QtCore/QTimer>
+#include <QtGui/QPixmap>
+
+#include "SideBarWidget.h"
+#include "Plugin.h"
+
+
+class trackContainer;
+
+
+class pluginBrowser : public SideBarWidget
+{
+	Q_OBJECT
+public:
+	pluginBrowser( QWidget * _parent );
+	virtual ~pluginBrowser();
+
+
+private:
+	Plugin::DescriptorList m_pluginDescriptors;
+
+	QWidget * m_view;
+
+} ;
+
+
+
+
+class pluginDescWidget : public QWidget
+{
+	Q_OBJECT
+public:
+	pluginDescWidget( const Plugin::Descriptor & _pd, QWidget * _parent );
+	virtual ~pluginDescWidget();
+
+
+protected:
+	virtual void enterEvent( QEvent * _e );
+	virtual void leaveEvent( QEvent * _e );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+
+
+private slots:
+	void updateHeight();
+
+
+private:
+	QTimer m_updateTimer;
+
+	const Plugin::Descriptor & m_pluginDescriptor;
+	QPixmap m_logo;
+
+	bool m_mouseOver;
+	int m_targetHeight;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/project_notes.h b/lmms/include/project_notes.h
new file mode 100644
index 0000000..8765070
--- /dev/null
+++ b/lmms/include/project_notes.h
@@ -0,0 +1,91 @@
+/*
+ * project_notes.h - header for project-notes-editor
+ *
+ * Copyright (c) 2005-2007 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _PROJECT_NOTES_H
+#define _PROJECT_NOTES_H
+
+#include <QtGui/QMainWindow>
+
+#include "JournallingObject.h"
+
+class QAction;
+class QComboBox;
+class QTextCharFormat;
+class QTextEdit;
+
+
+class EXPORT projectNotes : public QMainWindow, public SerializingObject
+{
+	Q_OBJECT
+public:
+	projectNotes();
+	virtual ~projectNotes();
+
+	void clear();
+	void setText( const QString & _text );
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+
+	inline virtual QString nodeName() const
+	{
+		return "projectnotes";
+	}
+
+
+protected:
+	void setupActions();
+
+
+private slots:
+	void textBold();
+	void textUnderline();
+	void textItalic();
+	void textFamily( const QString & _f );
+	void textSize( const QString & _p );
+	void textColor();
+	void textAlign( QAction * _a );
+
+	void formatChanged( const QTextCharFormat & _f );
+	void alignmentChanged( int _a );
+
+
+private:
+	QTextEdit * m_edit;
+	QAction * m_actionTextBold,
+		* m_actionTextUnderline,
+		* m_actionTextItalic,
+		* m_actionTextColor,
+		* m_actionAlignLeft,
+		* m_actionAlignCenter,
+		* m_actionAlignRight,
+		* m_actionAlignJustify;
+	QComboBox * m_comboFont;
+	QComboBox * m_comboSize;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/project_version.h b/lmms/include/project_version.h
new file mode 100644
index 0000000..575d1a6
--- /dev/null
+++ b/lmms/include/project_version.h
@@ -0,0 +1,56 @@
+/*
+ * project_version.h - version compared in import upgrades
+ *
+ * Copyright (c) 2007 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _PROJECT_VERSION_H
+#define _PROJECT_VERSION_H
+
+#include <QtCore/QString>
+
+
+class projectVersion : public QString
+{
+public:
+	projectVersion( const QString & _s ) :
+		QString( _s )
+	{
+	}
+
+	static int compare( const projectVersion & _v1,
+						const projectVersion & _v2 );
+
+} ;
+
+
+
+
+inline bool operator<( const projectVersion & _v1, const char * _str )
+{
+	return projectVersion::compare( _v1, projectVersion( _str ) ) < 0;
+}
+
+
+
+
+#endif
diff --git a/lmms/include/rename_dialog.h b/lmms/include/rename_dialog.h
new file mode 100644
index 0000000..0cc78fe
--- /dev/null
+++ b/lmms/include/rename_dialog.h
@@ -0,0 +1,61 @@
+/*
+ * rename_dialog.h - declaration of class renameDialog, a simple dialog for
+ *                   changing the content of a string
+ *
+ * Copyright (c) 2004-2005 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _RENAME_DIALOG_H
+#define _RENAME_DIALOG_H
+
+#include <QtGui/QDialog>
+
+
+class QLineEdit;
+
+
+class renameDialog : public QDialog
+{
+	Q_OBJECT
+public:
+	renameDialog( QString & _string );
+	~renameDialog();
+
+
+protected:
+	void keyPressEvent( QKeyEvent * _ke );
+
+
+protected slots:
+	void textChanged( const QString & _new_string );
+
+
+private:
+	QString & m_stringToEdit;
+	QString m_originalString;
+	QLineEdit * m_stringLE;
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/rubberband.h b/lmms/include/rubberband.h
new file mode 100644
index 0000000..2e4d303
--- /dev/null
+++ b/lmms/include/rubberband.h
@@ -0,0 +1,94 @@
+/*
+ * rubberband.h - rubberband - either own implementation for Qt3 or wrapper for
+ *                             Qt4
+ *
+ * Copyright (c) 2006 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _RUBBERBAND_H
+#define _RUBBERBAND_H
+
+#include <QtGui/QRubberBand>
+#include <QtCore/QVector>
+
+
+class selectableObject : public QWidget
+{
+	Q_OBJECT
+public:
+	selectableObject( QWidget * _parent ) :
+		QWidget( _parent ),
+		m_selected( false )
+	{
+	}
+
+	virtual ~selectableObject()
+	{
+	}
+
+	inline void setSelected( bool _selected )
+	{
+		m_selected = _selected;
+		update();
+	}
+
+	inline bool isSelected() const
+	{
+		return( m_selected );
+	}
+
+
+public slots:
+	virtual void update()
+	{
+		QWidget::update();
+	}
+
+
+private:
+	bool m_selected;
+
+} ;
+
+
+
+
+class rubberBand : public QRubberBand
+{
+public:
+	rubberBand( QWidget * _parent );
+	virtual ~rubberBand();
+
+	QVector<selectableObject *> selectedObjects() const;
+
+
+protected:
+	virtual void resizeEvent( QResizeEvent * _re );
+
+private:
+	QVector<selectableObject *> selectableObjects() const;
+
+};
+
+
+#endif
+
diff --git a/lmms/include/setup_dialog.h b/lmms/include/setup_dialog.h
new file mode 100644
index 0000000..53c2be0
--- /dev/null
+++ b/lmms/include/setup_dialog.h
@@ -0,0 +1,180 @@
+/*
+ * setup_dialog.h - dialog for setting up LMMS
+ *
+ * Copyright (c) 2005-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _SETUP_DIALOG_H
+#define _SETUP_DIALOG_H
+
+#include <QtGui/QDialog>
+#include <QtCore/QMap>
+
+#include "lmmsconfig.h"
+#include "AudioDevice.h"
+#include "MidiClient.h"
+
+
+class QComboBox;
+class QLabel;
+class QLineEdit;
+class QSlider;
+
+class tabBar;
+
+
+class setupDialog : public QDialog
+{
+	Q_OBJECT
+public:
+	enum ConfigTabs
+	{
+		GeneralSettings,
+		PathSettings,
+		PerformanceSettings,
+		AudioSettings,
+		MidiSettings
+	} ;
+
+	setupDialog( ConfigTabs _tab_to_open = GeneralSettings );
+	virtual ~setupDialog();
+
+
+protected slots:
+	virtual void accept();
+
+
+private slots:
+	// general settings widget
+	void setBufferSize( int _value );
+	void resetBufSize();
+	void displayBufSizeHelp();
+
+	// path settings widget
+	void setWorkingDir( const QString & _wd );
+	void setVSTDir( const QString & _vd );
+	void setArtworkDir( const QString & _ad );
+	void setFLDir( const QString & _fd );
+	void setLADSPADir( const QString & _ld );
+	void setSTKDir( const QString & _sd );
+	void setDefaultSoundfont( const QString & _sf );
+	void setBackgroundArtwork( const QString & _ba );
+	
+	// audio settings widget
+	void audioInterfaceChanged( const QString & _driver );
+	void displayAudioHelp();
+
+	// MIDI settings widget
+	void midiInterfaceChanged( const QString & _driver );
+	void displayMIDIHelp();
+
+
+	void toggleToolTips( bool _enabled );
+	void toggleWarnAfterSetup( bool _enabled );
+	void toggleDisplaydBV( bool _enabled );
+	void toggleMMPZ( bool _enabled );
+	void toggleHQAudioDev( bool _enabled );
+
+	void openWorkingDir();
+	void openVSTDir();
+	void openArtworkDir();
+	void openFLDir();
+	void openLADSPADir();
+	void openSTKDir();
+	void openDefaultSoundfont();
+	void openBackgroundArtwork();
+
+	void toggleSmoothScroll( bool _enabled );
+	void toggleAutoSave( bool _enabled );
+	void toggleOneInstrumentTrackWindow( bool _enabled );
+	void toggleCompactTrackButtons( bool _enabled );
+	void toggleSyncVSTPlugins( bool _enabled );
+	void toggleAnimateAFP( bool _enabled );
+	void toggleNoteLabels( bool en );
+	void toggleDisplayWaveform( bool en );
+
+
+private:
+	tabBar * m_tabBar;
+
+	QSlider * m_bufSizeSlider;
+	QLabel * m_bufSizeLbl;
+	int m_bufferSize;
+
+	bool m_toolTips;
+	bool m_warnAfterSetup;
+	bool m_displaydBV;
+	bool m_MMPZ;
+	bool m_hqAudioDev;
+
+
+	QLineEdit * m_wdLineEdit;
+	QLineEdit * m_vdLineEdit;
+	QLineEdit * m_adLineEdit;
+	QLineEdit * m_fdLineEdit;
+	QLineEdit * m_ladLineEdit;
+#ifdef LMMS_HAVE_FLUIDSYNTH
+	QLineEdit * m_sfLineEdit;
+#endif
+#ifdef LMMS_HAVE_STK
+	QLineEdit * m_stkLineEdit;
+#endif
+	QLineEdit * m_baLineEdit;
+
+	QString m_workingDir;
+	QString m_vstDir;
+	QString m_artworkDir;
+	QString m_flDir;
+	QString m_ladDir;
+#ifdef LMMS_HAVE_FLUIDSYNTH
+	QString m_defaultSoundfont;
+#endif
+#ifdef LMMS_HAVE_STK
+	QString m_stkDir;
+#endif
+	QString m_backgroundArtwork;
+
+	bool m_smoothScroll;
+	bool m_enableAutoSave;
+	bool m_oneInstrumentTrackWindow;
+	bool m_compactTrackButtons;
+	bool m_syncVSTPlugins;
+	bool m_animateAFP;
+	bool m_printNoteLabels;
+	bool m_displayWaveform;
+
+	typedef QMap<QString, AudioDevice::setupWidget *> AswMap;
+	typedef QMap<QString, MidiClient::setupWidget *> MswMap;
+	typedef QMap<QString, QString> trMap;
+
+	QComboBox * m_audioInterfaces;
+	AswMap m_audioIfaceSetupWidgets;
+	trMap m_audioIfaceNames;
+
+	QComboBox * m_midiInterfaces;
+	MswMap m_midiIfaceSetupWidgets;
+	trMap m_midiIfaceNames;
+
+
+} ;
+
+
+#endif
diff --git a/lmms/include/shared_object.h b/lmms/include/shared_object.h
new file mode 100644
index 0000000..a0d4615
--- /dev/null
+++ b/lmms/include/shared_object.h
@@ -0,0 +1,84 @@
+/*
+ * shared_object.h - class sharedObject for use among other objects
+ *
+ * Copyright (c) 2006-2007 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * Copyright (c) 2008-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef SHARED_OBJECT_H
+#define SHARED_OBJECT_H
+
+#include <QtCore/QMutex>
+
+
+class sharedObject
+{
+public:
+	sharedObject() :
+		m_referenceCount( 1 ),
+		m_lock()
+	{
+	}
+
+	virtual ~sharedObject()
+	{
+	}
+
+	template<class T>
+	static T* ref( T* object )
+	{
+		object->m_lock.lock();
+		// TODO: Use QShared
+		++object->m_referenceCount;
+		object->m_lock.unlock();
+		return object;
+	}
+
+	template<class T>
+	static void unref( T* object )
+	{
+		object->m_lock.lock();
+		bool deleteObject = --object->m_referenceCount <= 0;
+		object->m_lock.unlock();
+
+		if ( deleteObject )
+		{
+			delete object;
+		}
+	}
+
+	// keep clang happy which complaines about unused member variable
+	void dummy()
+	{
+		m_referenceCount = 0;
+	}
+
+private:
+	int m_referenceCount;
+	QMutex m_lock;
+
+} ;
+
+
+
+
+#endif
+
diff --git a/lmms/include/song.h b/lmms/include/song.h
new file mode 100644
index 0000000..543acd5
--- /dev/null
+++ b/lmms/include/song.h
@@ -0,0 +1,380 @@
+/*
+ * song.h - class song - the root of the model-tree
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _SONG_H
+#define _SONG_H
+
+#include <QtCore/QSharedMemory>
+#include <QtCore/QVector>
+
+#include "TrackContainer.h"
+#include "AutomatableModel.h"
+#include "Controller.h"
+#include "MeterModel.h"
+#include "VstSyncController.h"
+
+class AutomationTrack;
+class pattern;
+class timeLine;
+
+
+const bpm_t MinTempo = 10;
+const bpm_t DefaultTempo = 140;
+const bpm_t MaxTempo = 999;
+const tick_t MaxSongLength = 9999 * DefaultTicksPerTact;
+
+
+class EXPORT song : public TrackContainer
+{
+	Q_OBJECT
+	mapPropertyFromModel(int,getTempo,setTempo,m_tempoModel);
+	mapPropertyFromModel(int,masterPitch,setMasterPitch,m_masterPitchModel);
+	mapPropertyFromModel(int,masterVolume,setMasterVolume,
+							m_masterVolumeModel);
+public:
+	enum PlayModes
+	{
+		Mode_None,
+		Mode_PlaySong,
+		Mode_PlayTrack,
+		Mode_PlayBB,
+		Mode_PlayPattern,
+		Mode_PlayAutomationPattern,
+		Mode_Count
+	} ;
+
+
+	class playPos : public MidiTime
+	{
+	public:
+		playPos( const int _abs = 0 ) :
+			MidiTime( _abs ),
+			m_timeLine( NULL ),
+			m_timeLineUpdate( true ),
+			m_currentFrame( 0.0f )
+		{
+		}
+		inline void setCurrentFrame( const float _f )
+		{
+			m_currentFrame = _f;
+		}
+		inline float currentFrame() const
+		{
+			return m_currentFrame;
+		}
+		timeLine * m_timeLine;
+		bool m_timeLineUpdate;
+
+	private:
+		float m_currentFrame;
+
+	} ;
+
+
+
+	void processNextBuffer();
+
+	inline int getMilliseconds() const
+	{
+		return m_elapsedMilliSeconds;
+	}
+	inline void setMilliSeconds( float _ellapsedMilliSeconds )
+	{
+		m_elapsedMilliSeconds = (_ellapsedMilliSeconds);
+	}
+	inline int getTacts() const
+	{
+		return currentTact();
+	}
+
+	inline int ticksPerTact() const
+	{
+		return DefaultTicksPerTact *
+				m_timeSigModel.getNumerator() /
+					 m_timeSigModel.getDenominator();
+	}
+
+	// Returns the beat position inside the bar, 0-based
+	inline int getBeat() const
+	{
+		return (currentTick() - currentTact()*ticksPerTact()) /
+			(ticksPerTact() / m_timeSigModel.getNumerator() );
+	}
+	// the remainder after bar and beat are removed
+	inline int getBeatTicks() const
+	{
+		return 	(currentTick() - currentTact()*ticksPerTact()) %
+			(ticksPerTact() / m_timeSigModel.getNumerator() );
+	}
+	inline int getTicks() const
+	{
+		return currentTick();
+	}
+	inline bool isTempoAutomated()
+	{
+		return m_tempoModel.isAutomated();
+	}
+	inline bool isPaused() const
+	{
+		return m_paused;
+	}
+
+	inline bool isPlaying() const
+	{
+		return m_playing && m_exporting == false;
+	}
+
+	inline bool isStopped() const
+	{
+		return m_playing == false && m_paused == false;
+	}
+
+	inline bool isExporting() const
+	{
+		return m_exporting;
+	}
+
+	inline void setExportLoop( bool exportLoop )
+	{
+		m_exportLoop = exportLoop;
+	}
+
+	inline bool isRecording() const
+	{
+		return m_recording;
+	}
+
+	inline bool isExportDone() const
+	{
+		if ( m_exportLoop )
+		{
+			return m_exporting == true &&
+				m_playPos[Mode_PlaySong].getTicks() >= length() * ticksPerTact();
+		}
+		else
+		{
+			return m_exporting == true &&
+				m_playPos[Mode_PlaySong].getTicks() >= ( length() + 1 ) * ticksPerTact();
+		}
+	}
+
+	inline PlayModes playMode() const
+	{
+		return m_playMode;
+	}
+
+	inline playPos & getPlayPos( PlayModes _pm )
+	{
+		return m_playPos[_pm];
+	}
+
+	void updateLength();
+	tact_t length() const
+	{
+		return m_length;
+	}
+
+
+	bpm_t getTempo();
+	virtual AutomationPattern * tempoAutomationPattern();
+
+	AutomationTrack * globalAutomationTrack()
+	{
+		return m_globalAutomationTrack;
+	}
+
+	// file management
+	void createNewProject();
+	void createNewProjectFromTemplate( const QString & _template );
+	void loadProject( const QString & _filename );
+	bool guiSaveProject();
+	bool guiSaveProjectAs( const QString & _filename );
+    bool saveProjectFile( const QString & _filename );
+	inline const QString & projectFileName() const
+	{
+		return m_fileName;
+	}
+	inline bool isLoadingProject() const
+	{
+		return m_loadingProject;
+	}
+	inline bool isModified() const
+	{
+		return m_modified;
+	}
+
+	inline virtual QString nodeName() const
+	{
+		return "song";
+	}
+
+	virtual inline bool fixedTCOs() const
+	{
+		return false;
+	}
+
+	void addController( Controller * _c );
+	void removeController( Controller * _c );
+	
+
+	const ControllerVector & controllers() const
+	{
+		return m_controllers;
+	}
+
+
+	MeterModel & getTimeSigModel()
+	{
+		return m_timeSigModel;
+	}
+
+
+public slots:
+	void playSong();
+	void record();
+	void playAndRecord();
+	void playTrack( track * _trackToPlay );
+	void playBB();
+	void playPattern( pattern * _patternToPlay, bool _loop = true );
+	void togglePause();
+	void stop();
+
+	void importProject();
+	void exportProject(bool multiExport=false);
+	void exportProjectTracks();
+
+	void startExport();
+	void stopExport();
+
+
+	void setModified();
+
+	void clearProject();
+
+	void addBBTrack();
+
+	bool isLoadingProject();
+
+
+private slots:
+	void insertBar();
+	void removeBar();
+	void addSampleTrack();
+	void addAutomationTrack();
+
+	void setTempo();
+	void setTimeSignature();
+
+	void masterVolumeChanged();
+
+	void savePos();
+
+	void updateFramesPerTick();
+
+
+
+private:
+	song();
+	song( const song & );
+	virtual ~song();
+
+
+	inline tact_t currentTact() const
+	{
+		return m_playPos[m_playMode].getTact();
+	}
+
+	inline tick_t currentTick() const
+	{
+		return m_playPos[m_playMode].getTicks();
+	}
+	void setPlayPos( tick_t _ticks, PlayModes _play_mode );
+
+	void saveControllerStates( QDomDocument & _doc, QDomElement & _this );
+	void restoreControllerStates( const QDomElement & _this );
+	void CheckIfLoop();
+	void loopInBuffer(bool, int);
+	bool loopPointsEnabled();
+	void processNextBufferSong();
+	void processNextBufferTrack();
+	void processNextBufferBB();
+	void processNextBufferPattern();
+	int getMaxTact();
+
+
+	AutomationTrack * m_globalAutomationTrack;
+
+	IntModel m_tempoModel;
+	MeterModel m_timeSigModel;
+	int m_oldTicksPerTact;
+	IntModel m_masterVolumeModel;
+	IntModel m_masterPitchModel;
+
+	ControllerVector m_controllers;
+
+
+	QString m_fileName;
+	QString m_oldFileName;
+	bool m_modified;
+
+	volatile bool m_recording;
+	volatile bool m_exporting;
+	volatile bool m_exportLoop;
+	volatile bool m_playing;
+	volatile bool m_paused;
+
+	bool m_loadingProject;
+
+	PlayModes m_playMode;
+	playPos m_playPos[Mode_Count];
+	tact_t m_length;
+
+	track * m_trackToPlay;
+	pattern * m_patternToPlay;
+	bool m_loopPattern;
+
+	double m_elapsedMilliSeconds;
+	tick_t m_elapsedTicks;
+	tact_t m_elapsedTacts;
+
+	VstSyncController m_vstSyncController;
+
+
+	friend class engine;
+	friend class SongEditor;
+	friend class mainWindow;
+	friend class ControllerRackView;
+
+signals:
+	void projectLoaded();
+	void playbackStateChanged();
+	void lengthChanged( int _tacts );
+	void tempoChanged( bpm_t _new_bpm );
+	void timeSignatureChanged( int _old_ticks_per_tact,
+							int _ticks_per_tact );
+
+} ;
+
+
+#endif
diff --git a/lmms/include/string_pair_drag.h b/lmms/include/string_pair_drag.h
new file mode 100644
index 0000000..46b546a
--- /dev/null
+++ b/lmms/include/string_pair_drag.h
@@ -0,0 +1,58 @@
+/*
+ * string_pair_drag.h - class stringPairDrag which provides general support
+ *                      for drag'n'drop of string-pairs
+ *
+ * Copyright (c) 2005-2007 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _STRING_PAIR_DRAG_H
+#define _STRING_PAIR_DRAG_H
+
+#include <QtGui/QDrag>
+#include <QtGui/QDragEnterEvent>
+#include <QtGui/QDropEvent>
+
+#include "export.h"
+
+class QPixmap;
+
+
+class EXPORT stringPairDrag : public QDrag
+{
+public:
+	stringPairDrag( const QString & _key, const QString & _value,
+					const QPixmap & _icon, QWidget * _w );
+	~stringPairDrag();
+
+	static bool processDragEnterEvent( QDragEnterEvent * _dee,
+						const QString & _allowed_keys );
+	static QString decodeKey( QDropEvent * _de );
+	static QString decodeValue( QDropEvent * _de );
+
+	static const char * mimeType()
+	{
+		return( "application/x-lmms-stringpair" );
+	}
+
+} ;
+
+
+#endif
diff --git a/lmms/include/tab_bar.h b/lmms/include/tab_bar.h
new file mode 100644
index 0000000..dd60410
--- /dev/null
+++ b/lmms/include/tab_bar.h
@@ -0,0 +1,88 @@
+/*
+ * tab_bar.h - class tabBar
+ *
+ * Copyright (c) 2004-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TAB_BAR_H
+#define _TAB_BAR_H
+
+#include <QtCore/QMap>
+#include <QtGui/QLayout>
+#include <QtGui/QWidget>
+
+#include "export.h"
+
+
+class tabButton;
+
+
+class EXPORT tabBar : public QWidget
+{
+	Q_OBJECT
+public:
+	tabBar( QWidget * _parent,
+			QBoxLayout::Direction _dir = QBoxLayout::LeftToRight );
+	virtual ~tabBar();
+
+	tabButton * addTab( QWidget * _w, const QString & _text,
+					int _id, bool _add_stretch = false,
+					bool _text_is_tooltip = false );
+	void removeTab( int _id );
+
+	inline void setExclusive( bool _on )
+	{
+		m_exclusive = _on;
+	}
+
+	int activeTab();
+
+
+public slots:
+	void setActiveTab( int _id );
+
+
+protected:
+	bool tabState( int _id );
+	void setTabState( int _id, bool _checked );
+	bool allHidden();
+
+
+protected slots:
+	void hideAll( int _exception = -1 );
+	void tabClicked( int _id );
+
+
+private:
+	QMap<int, QPair<tabButton *, QWidget *> > m_tabs;
+	QBoxLayout * m_layout;
+	bool m_exclusive;
+
+
+signals:
+	void allWidgetsHidden();
+	void widgetShown();
+
+} ;
+
+
+#endif
diff --git a/lmms/include/tab_button.h b/lmms/include/tab_button.h
new file mode 100644
index 0000000..87c0aed
--- /dev/null
+++ b/lmms/include/tab_button.h
@@ -0,0 +1,66 @@
+/*
+ * tab_button.h - declaration of class tabButton
+ *
+ * Copyright (c) 2005-2007 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TAB_BUTTON_H
+#define _TAB_BUTTON_H
+
+#include <QtGui/QPushButton>
+
+
+class tabButton : public QPushButton
+{
+	Q_OBJECT
+public:
+	tabButton( const QString & _text, int _id, QWidget * _parent ) :
+		QPushButton( _text, _parent ),
+		m_id( _id )
+	{
+		setCheckable( true );
+		connect( this, SIGNAL( clicked() ), this,
+						SLOT( slotClicked() ) );
+	}
+
+	~tabButton()
+	{
+	}
+
+
+signals:
+	void clicked( int );
+
+
+protected slots:
+	void slotClicked()
+	{
+		emit clicked( m_id );
+	}
+
+
+private:
+	int m_id;
+
+} ;
+
+#endif
diff --git a/lmms/include/tab_widget.h b/lmms/include/tab_widget.h
new file mode 100644
index 0000000..40d7abf
--- /dev/null
+++ b/lmms/include/tab_widget.h
@@ -0,0 +1,72 @@
+/*
+ * tab_widget.h - LMMS-tabwidget
+ *
+ * Copyright (c) 2005-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TAB_WIDGET_H
+#define _TAB_WIDGET_H
+
+#include <QtGui/QWidget>
+#include <QtCore/QMap>
+
+
+class tabWidget : public QWidget
+{
+	Q_OBJECT
+public:
+	tabWidget( const QString & _caption, QWidget * _parent );
+	virtual ~tabWidget();
+
+	void addTab( QWidget * _w, const QString & _name, int _idx = -1 );
+
+	void setActiveTab( int _idx );
+
+	inline int activeTab() const
+	{
+		return( m_activeTab );
+	}
+
+
+protected:
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void resizeEvent( QResizeEvent * _re );
+	virtual void wheelEvent( QWheelEvent * _we );
+
+
+private:
+	struct widgetDesc
+	{
+		QWidget * w;	// ptr to widget
+		QString name;	// name for widget
+		int nwidth;	// width of name when painting
+	} ;
+	typedef QMap<int, widgetDesc> widgetStack;
+
+	widgetStack m_widgets;
+	int m_activeTab;
+	QString m_caption;
+
+} ;
+
+#endif
diff --git a/lmms/include/templates.h b/lmms/include/templates.h
new file mode 100644
index 0000000..3c6a917
--- /dev/null
+++ b/lmms/include/templates.h
@@ -0,0 +1,39 @@
+/*
+ * templates.h - miscellanous templates and algorithms
+ *
+ * Copyright (c) 2004-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TEMPLATES_H
+#define _TEMPLATES_H
+
+#include <QtCore/QtAlgorithms>
+
+
+template<class T>
+inline T tLimit( const T x, const T x1, const T x2 )
+{
+	return qBound( x1, x, x2 );
+}
+
+
+#endif
diff --git a/lmms/include/text_float.h b/lmms/include/text_float.h
new file mode 100644
index 0000000..b631ca8
--- /dev/null
+++ b/lmms/include/text_float.h
@@ -0,0 +1,82 @@
+/*
+ * text_float.h - class textFloat, a floating text-label
+ *
+ * Copyright (c) 2005-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TEXT_FLOAT
+#define _TEXT_FLOAT
+
+#include <QtGui/QWidget>
+#include <QtGui/QPixmap>
+
+#include "export.h"
+
+
+class EXPORT textFloat : public QWidget
+{
+public:
+	textFloat();
+	virtual ~textFloat()
+	{
+	}
+
+	void setTitle( const QString & _title );
+	void setText( const QString & _text );
+	void setPixmap( const QPixmap & _pixmap );
+
+	void setVisibilityTimeOut( int _msecs );
+
+
+	static textFloat * displayMessage( const QString & _msg,
+						int _timeout = 2000,
+						QWidget * _parent = NULL,
+						int _add_y_margin = 0 );
+	static textFloat * displayMessage( const QString & _title,
+						const QString & _msg,
+						const QPixmap & _pixmap =
+								QPixmap(),
+						int _timeout = 2000,
+						QWidget * _parent = NULL );
+
+	void moveGlobal( QWidget * _w, const QPoint & _offset )
+	{
+		move( _w->mapToGlobal( QPoint( 0, 0 ) )+_offset );
+	}
+
+
+protected:
+	virtual void paintEvent( QPaintEvent * _me );
+	virtual void mousePressEvent( QMouseEvent * _me );
+
+
+private:
+	void updateSize();
+
+	QString m_title;
+	QString m_text;
+	QPixmap m_pixmap;
+
+} ;
+
+
+#endif
diff --git a/lmms/include/timeline.h b/lmms/include/timeline.h
new file mode 100644
index 0000000..ff46618
--- /dev/null
+++ b/lmms/include/timeline.h
@@ -0,0 +1,192 @@
+/*
+ * timeline.h - class timeLine, representing a time-line with position marker
+ *
+ * Copyright (c) 2004-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TIMELINE_H
+#define _TIMELINE_H
+
+#include <QtGui/QWidget>
+
+#include "song.h"
+
+
+class QPixmap;
+class nStateButton;
+class textFloat;
+
+
+class timeLine : public QWidget, public JournallingObject
+{
+	Q_OBJECT
+public:
+	enum AutoScrollStates
+	{
+		AutoScrollEnabled,
+		AutoScrollDisabled
+	} ;
+
+	enum LoopPointStates
+	{
+		LoopPointsDisabled,
+		LoopPointsEnabled
+	} ;
+
+	enum BehaviourAtStopStates
+	{
+		BackToZero,
+		BackToStart,
+		KeepStopPosition
+	} ;
+
+
+	timeLine( int _xoff, int _yoff, float _ppt, song::playPos & _pos,
+				const MidiTime & _begin, QWidget * _parent );
+	virtual ~timeLine();
+
+	inline song::playPos & pos()
+	{
+		return( m_pos );
+	}
+
+	AutoScrollStates autoScroll() const
+	{
+		return m_autoScroll;
+	}
+
+	BehaviourAtStopStates behaviourAtStop() const
+	{
+		return m_behaviourAtStop;
+	}
+
+	bool loopPointsEnabled() const
+	{
+		return m_loopPoints == LoopPointsEnabled;
+	}
+
+	inline const MidiTime & loopBegin() const
+	{
+		return ( m_loopPos[0] < m_loopPos[1] ) ?
+						m_loopPos[0] : m_loopPos[1];
+	}
+
+	inline const MidiTime & loopEnd() const
+	{
+		return ( m_loopPos[0] > m_loopPos[1] ) ?
+						m_loopPos[0] : m_loopPos[1];
+	}
+
+	inline void savePos( const MidiTime & _pos )
+	{
+		m_savedPos = _pos;
+	}
+	inline const MidiTime & savedPos() const
+	{
+		return m_savedPos;
+	}
+
+	inline void setPixelsPerTact( float _ppt )
+	{
+		m_ppt = _ppt;
+		update();
+	}
+
+	void addToolButtons( QWidget * _tool_bar );
+
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _parent );
+	virtual void loadSettings( const QDomElement & _this );
+	inline virtual QString nodeName() const
+	{
+		return "timeline";
+	}
+
+	inline int markerX( const MidiTime & _t ) const
+	{
+		return m_xOffset + static_cast<int>( ( _t - m_begin ) *
+					m_ppt / MidiTime::ticksPerTact() );
+	}
+
+
+public slots:
+	void updatePosition( const MidiTime & );
+	void updatePosition()
+	{
+		updatePosition( MidiTime() );
+	}
+	void toggleAutoScroll( int _n );
+	void toggleLoopPoints( int _n );
+	void toggleBehaviourAtStop( int _n );
+
+
+protected:
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseMoveEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+
+
+private:
+	static QPixmap * s_timeLinePixmap;
+	static QPixmap * s_posMarkerPixmap;
+	static QPixmap * s_loopPointPixmap;
+	static QPixmap * s_loopPointDisabledPixmap;
+
+	AutoScrollStates m_autoScroll;
+	LoopPointStates m_loopPoints;
+	BehaviourAtStopStates m_behaviourAtStop;
+
+	bool m_changedPosition;
+
+	int m_xOffset;
+	int m_posMarkerX;
+	float m_ppt;
+	song::playPos & m_pos;
+	const MidiTime & m_begin;
+	MidiTime m_loopPos[2];
+
+	MidiTime m_savedPos;
+
+
+	textFloat * m_hint;
+
+
+	enum actions
+	{
+		NoAction,
+		MovePositionMarker,
+		MoveLoopBegin,
+		MoveLoopEnd
+	} m_action;
+
+	int m_moveXOff;
+
+
+signals:
+	void positionChanged( const MidiTime & _t );
+	void loopPointStateLoaded( int _n );
+
+} ;
+
+
+#endif
diff --git a/lmms/include/tool_button.h b/lmms/include/tool_button.h
new file mode 100644
index 0000000..3a908f9
--- /dev/null
+++ b/lmms/include/tool_button.h
@@ -0,0 +1,82 @@
+/*
+ * tool_button.h - declaration of class toolButton 
+ *
+ * Copyright (c) 2005-2006 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TOOL_BUTTON_H
+#define _TOOL_BUTTON_H 
+
+#include <QtGui/QToolButton>
+#include <QtGui/QColor>
+
+
+class toolButton : public QToolButton
+{
+	Q_OBJECT
+public:
+	toolButton( const QPixmap & _pixmap, const QString & _tooltip,
+			QObject * _receiver, const char * _slot,
+			QWidget * _parent );
+
+	inline toolButton( QWidget * _parent ) :
+		QToolButton( _parent ),
+		m_colorStandard( s_stdColor ),
+		m_colorHighlighted( s_hlColor )
+	{
+		// setup colors
+		leaveEvent( NULL );
+	}
+
+	virtual ~toolButton();
+
+	inline void setStandardColor( const QColor & _color )
+	{
+		m_colorStandard = _color;
+	}
+
+	inline void setHighlightedColor( const QColor & _color )
+	{
+		m_colorHighlighted = _color;
+	}
+
+
+protected:
+	virtual void enterEvent( QEvent * _ev );
+	virtual void leaveEvent( QEvent * _ev );
+
+
+private slots:
+	void toggledBool( bool _on );
+
+
+private:
+	static const QColor s_stdColor;
+	static const QColor s_hlColor;
+
+	QColor m_colorStandard;
+	QColor m_colorHighlighted;
+
+} ;
+
+#endif
+
diff --git a/lmms/include/tooltip.h b/lmms/include/tooltip.h
new file mode 100644
index 0000000..b889381
--- /dev/null
+++ b/lmms/include/tooltip.h
@@ -0,0 +1,42 @@
+/*
+ * tooltip.h - namespace toolTip, a tooltip-wrapper for LMMS
+ *
+ * Copyright (c) 2005-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TOOLTIP_H
+#define _TOOLTIP_H
+
+#include <qstring.h>
+
+#include "export.h"
+
+class QWidget;
+
+
+struct toolTip
+{
+	static void EXPORT add( QWidget * _w, const QString & _txt );
+} ;
+
+
+#endif
diff --git a/lmms/include/track.h b/lmms/include/track.h
new file mode 100644
index 0000000..b5a4b3e
--- /dev/null
+++ b/lmms/include/track.h
@@ -0,0 +1,610 @@
+/*
+ * track.h - declaration of classes concerning tracks -> necessary for all
+ *           track-like objects (beat/bassline, sample-track...)
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ *
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef TRACK_H
+#define TRACK_H
+
+#include <QtCore/QVector>
+#include <QtCore/QList>
+#include <QtGui/QWidget>
+
+#include "lmms_basics.h"
+#include "MidiTime.h"
+#include "rubberband.h"
+#include "JournallingObject.h"
+#include "AutomatableModel.h"
+#include "ModelView.h"
+
+
+class QMenu;
+class QPushButton;
+
+class pixmapButton;
+class textFloat;
+class track;
+class trackContentObjectView;
+class TrackContainer;
+class TrackContainerView;
+class trackContentWidget;
+class trackView;
+
+typedef QWidget trackSettingsWidget;
+
+const int DEFAULT_SETTINGS_WIDGET_WIDTH = 224;
+const int TRACK_OP_WIDTH = 78;
+// This shaves 150-ish pixels off track buttons,
+// ruled from config: ui.compacttrackbuttons
+const int DEFAULT_SETTINGS_WIDGET_WIDTH_COMPACT = 96;
+const int TRACK_OP_WIDTH_COMPACT = 60;
+
+/*! The minimum track height in pixels
+ *
+ * Tracks can be resized by shift-dragging anywhere inside the track
+ * display.  This sets the minimum size in pixels for a track.
+ */
+const int MINIMAL_TRACK_HEIGHT = 8;
+const int DEFAULT_TRACK_HEIGHT = 32;
+
+const int TCO_BORDER_WIDTH = 2;
+
+
+class trackContentObject : public Model, public JournallingObject
+{
+	Q_OBJECT
+	mapPropertyFromModel(bool,isMuted,setMuted,m_mutedModel);
+	mapPropertyFromModel(bool,isSolo,setSolo,m_soloModel);
+public:
+	trackContentObject( track * _track );
+	virtual ~trackContentObject();
+
+	inline track * getTrack() const
+	{
+		return m_track;
+	}
+
+	inline const QString & name() const
+	{
+		return m_name;
+	}
+
+	inline void setName( const QString & _name )
+	{
+		m_name = _name;
+		emit dataChanged();
+	}
+
+	virtual QString displayName() const
+	{
+		return name();
+	}
+
+
+	inline const MidiTime & startPosition() const
+	{
+		return m_startPosition;
+	}
+
+	inline MidiTime endPosition() const
+	{
+		const int sp = m_startPosition;
+		return sp + m_length;
+	}
+
+	inline const MidiTime & length() const
+	{
+		return m_length;
+	}
+
+	virtual void movePosition( const MidiTime & _pos );
+	virtual void changeLength( const MidiTime & _length );
+
+	virtual trackContentObjectView * createView( trackView * _tv ) = 0;
+
+
+public slots:
+	void copy();
+	void paste();
+	void toggleMute();
+
+
+protected:
+	virtual void undoStep( JournalEntry & _je );
+	virtual void redoStep( JournalEntry & _je );
+
+
+signals:
+	void lengthChanged();
+	void positionChanged();
+	void destroyedTCO();
+
+
+private:
+	enum Actions
+	{
+		NoAction,
+		Move,
+		Resize
+	} ;
+
+	track * m_track;
+	QString m_name;
+
+	MidiTime m_startPosition;
+	MidiTime m_length;
+
+	BoolModel m_mutedModel;
+	BoolModel m_soloModel;
+
+
+	friend class trackContentObjectView;
+
+} ;
+
+
+
+class trackContentObjectView : public selectableObject, public ModelView
+{
+	Q_OBJECT
+public:
+	trackContentObjectView( trackContentObject * _tco, trackView * _tv );
+	virtual ~trackContentObjectView();
+
+	bool fixedTCOs();
+
+	inline trackContentObject * getTrackContentObject()
+	{
+		return m_tco;
+	}
+
+
+public slots:
+	virtual bool close();
+	void cut();
+	void remove();
+
+protected:
+	virtual void constructContextMenu( QMenu * )
+	{
+	}
+
+	virtual void contextMenuEvent( QContextMenuEvent * _cme );
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+	virtual void leaveEvent( QEvent * _e );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseMoveEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+
+	void setAutoResizeEnabled( bool _e = false );
+	float pixelsPerTact();
+
+	inline trackView * getTrackView()
+	{
+		return m_trackView;
+	}
+
+
+protected slots:
+	void updateLength();
+	void updatePosition();
+
+
+private:
+	enum Actions
+	{
+		NoAction,
+		Move,
+		MoveSelection,
+		Resize
+	} ;
+
+	static textFloat * s_textFloat;
+
+	trackContentObject * m_tco;
+	trackView * m_trackView;
+	Actions m_action;
+	bool m_autoResize;
+	int m_initialMouseX;
+
+	textFloat * m_hint;
+
+	MidiTime m_oldTime;// used for undo/redo while mouse-button is pressed
+
+} ;
+
+
+
+
+
+class trackContentWidget : public QWidget, public JournallingObject
+{
+	Q_OBJECT
+public:
+	trackContentWidget( trackView * _parent );
+	virtual ~trackContentWidget();
+
+	/*! \brief Updates the background tile pixmap. */
+	void updateBackground();
+
+	void addTCOView( trackContentObjectView * _tcov );
+	void removeTCOView( trackContentObjectView * _tcov );
+	void removeTCOView( int _tco_num )
+	{
+		if( _tco_num >= 0 && _tco_num < m_tcoViews.size() )
+		{
+			removeTCOView( m_tcoViews[_tco_num] );
+		}
+	}
+
+	MidiTime endPosition( const MidiTime & _pos_start );
+
+public slots:
+	void update();
+	void changePosition( const MidiTime & _new_pos = MidiTime( -1 ) );
+
+
+protected:
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void resizeEvent( QResizeEvent * _re );
+
+	virtual QString nodeName() const
+	{
+		return "trackcontentwidget";
+	}
+
+	virtual void saveSettings( QDomDocument& doc, QDomElement& element )
+	{
+		Q_UNUSED(doc)
+		Q_UNUSED(element)
+	}
+
+	virtual void loadSettings( const QDomElement& element )
+	{
+		Q_UNUSED(element)
+	}
+
+	virtual void undoStep( JournalEntry & _je );
+	virtual void redoStep( JournalEntry & _je );
+
+
+private:
+	enum Actions
+	{
+		AddTrackContentObject,
+		RemoveTrackContentObject
+	} ;
+
+	track * getTrack();
+	MidiTime getPosition( int _mouse_x );
+
+	trackView * m_trackView;
+
+	typedef QVector<trackContentObjectView *> tcoViewVector;
+	tcoViewVector m_tcoViews;
+
+	QPixmap m_background;
+
+} ;
+
+
+
+
+
+class trackOperationsWidget : public QWidget
+{
+	Q_OBJECT
+public:
+	trackOperationsWidget( trackView * _parent );
+	~trackOperationsWidget();
+
+
+protected:
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+
+
+private slots:
+	void cloneTrack();
+	void removeTrack();
+	void updateMenu();
+
+
+private:
+	static QPixmap * s_grip;
+
+	trackView * m_trackView;
+
+	QPushButton * m_trackOps;
+	pixmapButton * m_muteBtn;
+	pixmapButton * m_soloBtn;
+
+
+	friend class trackView;
+
+signals:
+	void trackRemovalScheduled( trackView * _t );
+
+} ;
+
+
+
+
+
+// base-class for all tracks
+class EXPORT track : public Model, public JournallingObject
+{
+	Q_OBJECT
+	mapPropertyFromModel(bool,isMuted,setMuted,m_mutedModel);
+	mapPropertyFromModel(bool,isSolo,setSolo,m_soloModel);
+public:
+	typedef QVector<trackContentObject *> tcoVector;
+
+	enum TrackTypes
+	{
+		InstrumentTrack,
+		BBTrack,
+		SampleTrack,
+		EventTrack,
+		VideoTrack,
+		AutomationTrack,
+		HiddenAutomationTrack,
+		NumTrackTypes
+	} ;
+
+	track( TrackTypes _type, TrackContainer * _tc );
+	virtual ~track();
+
+	static track * create( TrackTypes _tt, TrackContainer * _tc );
+	static track * create( const QDomElement & _this,
+							TrackContainer * _tc );
+	void clone();
+
+
+	// pure virtual functions
+	TrackTypes type() const
+	{
+		return m_type;
+	}
+
+	virtual bool play( const MidiTime & _start, const fpp_t _frames,
+						const f_cnt_t _frame_base, int _tco_num = -1 ) = 0;
+
+
+	virtual trackView * createView( TrackContainerView * _view ) = 0;
+	virtual trackContentObject * createTCO( const MidiTime & _pos ) = 0;
+
+	virtual void saveTrackSpecificSettings( QDomDocument & _doc,
+						QDomElement & _parent ) = 0;
+	virtual void loadTrackSpecificSettings( const QDomElement & _this ) = 0;
+
+
+	virtual void saveSettings( QDomDocument & _doc, QDomElement & _this );
+	virtual void loadSettings( const QDomElement & _this );
+
+	void setSimpleSerializing()
+	{
+		m_simpleSerializingMode = true;
+	}
+
+	// -- for usage by trackContentObject only ---------------
+	trackContentObject * addTCO( trackContentObject * _tco );
+	void removeTCO( trackContentObject * _tco );
+	// -------------------------------------------------------
+
+	int numOfTCOs();
+	trackContentObject * getTCO( int _tco_num );
+	int getTCONum( trackContentObject * _tco );
+
+	const tcoVector & getTCOs() const
+	{
+		return( m_trackContentObjects );
+	}
+	void getTCOsInRange( tcoVector & _tco_v, const MidiTime & _start,
+							const MidiTime & _end );
+	void swapPositionOfTCOs( int _tco_num1, int _tco_num2 );
+
+
+	void insertTact( const MidiTime & _pos );
+	void removeTact( const MidiTime & _pos );
+
+	tact_t length() const;
+
+
+	inline TrackContainer* trackContainer() const
+	{
+		return m_trackContainer;
+	}
+
+	// name-stuff
+	virtual const QString & name() const
+	{
+		return( m_name );
+	}
+
+	virtual QString displayName() const
+	{
+		return( name() );
+	}
+
+	using Model::dataChanged;
+
+	inline int getHeight() {
+	  return ( m_height >= MINIMAL_TRACK_HEIGHT ? m_height : DEFAULT_TRACK_HEIGHT );
+	}
+	inline void setHeight( int _height ) {
+	  m_height = _height;
+	}
+
+
+public slots:
+	virtual void setName( const QString & _new_name )
+	{
+		m_name = _new_name;
+		emit nameChanged();
+	}
+
+	void toggleSolo();
+
+
+private:
+	TrackContainer* m_trackContainer;
+	TrackTypes m_type;
+	QString m_name;
+	int m_height;
+
+	BoolModel m_mutedModel;
+	BoolModel m_soloModel;
+	bool m_mutedBeforeSolo;
+
+	bool m_simpleSerializingMode;
+
+	tcoVector m_trackContentObjects;
+
+
+	friend class trackView;
+
+
+signals:
+	void destroyedTrack();
+	void nameChanged();
+	void trackContentObjectAdded( trackContentObject * );
+
+} ;
+
+
+
+
+class trackView : public QWidget, public ModelView, public JournallingObject
+{
+	Q_OBJECT
+public:
+	trackView( track * _track, TrackContainerView* tcv );
+	virtual ~trackView();
+
+	inline const track * getTrack() const
+	{
+		return( m_track );
+	}
+
+	inline track * getTrack()
+	{
+		return( m_track );
+	}
+
+	inline TrackContainerView* trackContainerView()
+	{
+		return m_trackContainerView;
+	}
+
+	inline trackOperationsWidget * getTrackOperationsWidget()
+	{
+		return( &m_trackOperationsWidget );
+	}
+
+	inline trackSettingsWidget * getTrackSettingsWidget()
+	{
+		return( &m_trackSettingsWidget );
+	}
+
+	inline trackContentWidget * getTrackContentWidget()
+	{
+		return( &m_trackContentWidget );
+	}
+
+	bool isMovingTrack() const
+	{
+		return( m_action == MoveTrack );
+	}
+
+	virtual void update();
+
+
+public slots:
+	virtual bool close();
+
+
+protected:
+	virtual void modelChanged();
+	virtual void undoStep( JournalEntry & _je );
+	virtual void redoStep( JournalEntry & _je );
+
+	virtual void saveSettings( QDomDocument& doc, QDomElement& element )
+	{
+		Q_UNUSED(doc)
+		Q_UNUSED(element)
+	}
+
+	virtual void loadSettings( const QDomElement& element )
+	{
+		Q_UNUSED(element)
+	}
+
+	virtual QString nodeName() const
+	{
+		return "trackview";
+	}
+
+
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseMoveEvent( QMouseEvent * _me );
+	virtual void mouseReleaseEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void resizeEvent( QResizeEvent * _re );
+
+
+private:
+	enum Actions
+	{
+		NoAction,
+		MoveTrack,
+		ResizeTrack
+	} ;
+
+	track * m_track;
+	TrackContainerView * m_trackContainerView;
+
+	trackOperationsWidget m_trackOperationsWidget;
+	trackSettingsWidget m_trackSettingsWidget;
+	trackContentWidget m_trackContentWidget;
+
+	Actions m_action;
+
+
+	friend class trackLabelButton;
+
+
+private slots:
+	void createTCOView( trackContentObject * _tco );
+
+} ;
+
+
+
+#endif
diff --git a/lmms/include/track_label_button.h b/lmms/include/track_label_button.h
new file mode 100644
index 0000000..5638cf5
--- /dev/null
+++ b/lmms/include/track_label_button.h
@@ -0,0 +1,61 @@
+/*
+ * track_label_button.h - class trackLabelButton
+ *
+ * Copyright (c) 2004-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TRACK_LABEL_BUTTON_H
+#define _TRACK_LABEL_BUTTON_H
+
+#include <QtGui/QToolButton>
+
+
+class trackView;
+
+
+class trackLabelButton : public QToolButton
+{
+	Q_OBJECT
+public:
+	trackLabelButton( trackView * _tv, QWidget * _parent );
+	virtual ~trackLabelButton();
+
+
+public slots:
+	void rename();
+
+
+protected:
+	virtual void dragEnterEvent( QDragEnterEvent * _dee );
+	virtual void dropEvent( QDropEvent * _de );
+	virtual void mousePressEvent( QMouseEvent * _me );
+	virtual void mouseDoubleClickEvent( QMouseEvent * _me );
+	virtual void paintEvent( QPaintEvent * _pe );
+
+
+private:
+	trackView * m_trackView;
+	QString m_iconName;
+
+} ;
+
+#endif
diff --git a/lmms/include/transformable_auto_model.h b/lmms/include/transformable_auto_model.h
new file mode 100644
index 0000000..85a64a7
--- /dev/null
+++ b/lmms/include/transformable_auto_model.h
@@ -0,0 +1,91 @@
+/*
+ * transformable_auto_model.h - template transformableAutoModel
+ *
+ * Copyright (c) 2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _TRANSFORMABLE_AUTO_MODEL_H
+#define _TRANSFORMABLE_AUTO_MODEL_H
+
+#include "AutomatableModel.h"
+//#include "automatable_model_templates.h"
+
+
+template<typename T>
+struct AutoModelTransformer
+{
+	inline virtual T transform( const T & _val ) const
+	{
+		return( _val );
+	}
+} ;
+
+
+template<typename T, typename EDIT_STEP_TYPE>
+class transformableAutoModel : public AutomatableModel<T, EDIT_STEP_TYPE>
+{
+public:
+	transformableAutoModel( const AutoModelTransformer<T> * _transformer,
+				const T _val = 0,
+				const T _min = 0,
+				const T _max = 0,
+				const T _step = defaultRelStep(),
+				Model * _parent = NULL,
+				bool _default_constructed = false ) :
+		AutomatableModel( _val, _min, _max, _step, _parent,
+						_default_constructed ),
+		m_transformer( _transformer )
+	{
+	}
+
+	inline virtual ~transformableAutoModel()
+	{
+	}
+
+	inline virtual void setValue( const T _value )
+	{
+		autoModel::setValue( _value );
+		if( m_transformer != NULL )
+		{
+			m_transformedValue = m_transformer->transform(
+							autoModel::value() );
+		}
+		else
+		{
+			m_transformedValue = autoModel::value();
+		}
+	}
+
+	inline virtual T value() const
+	{
+		return( m_transformedValue );
+	}
+
+private:
+	T m_transformedValue;
+	const AutoModelTransformer<T> * m_transformer;
+
+} ;
+
+
+#endif
+
diff --git a/lmms/include/update_event.h b/lmms/include/update_event.h
new file mode 100644
index 0000000..fd2deff
--- /dev/null
+++ b/lmms/include/update_event.h
@@ -0,0 +1,44 @@
+/*
+ * update_event.h - signal GUI updates
+ *
+ * Copyright (c) 2007 Javier Serrano Polo <jasp00/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _UPDATE_EVENT_H
+#define _UPDATE_EVENT_H
+
+#include "custom_events.h"
+
+
+
+class updateEvent : public QEvent
+{
+public:
+	updateEvent() :
+		QEvent( (QEvent::Type)customEvents::GUI_UPDATE )
+	{
+	}
+
+} ;
+
+
+#endif
diff --git a/lmms/include/versioninfo.h b/lmms/include/versioninfo.h
new file mode 100644
index 0000000..0fd3152
--- /dev/null
+++ b/lmms/include/versioninfo.h
@@ -0,0 +1,29 @@
+#ifdef __GNUC__
+#define GCC_VERSION "GCC "__VERSION__
+#else
+#define GCC_VERSION "unknown compiler"
+#endif
+
+#ifdef LMMS_HOST_X86
+#define MACHINE "i386"
+#endif
+
+#ifdef LMMS_HOST_X86_64
+#define MACHINE "x86_64"
+#endif
+
+#ifndef MACHINE
+#define MACHINE "unknown processor"
+#endif
+
+#ifdef LMMS_BUILD_LINUX
+#define PLATFORM "Linux"
+#endif
+
+#ifdef LMMS_BUILD_APPLE
+#define PLATFORM "OS X"
+#endif
+
+#ifdef LMMS_BUILD_WIN32
+#define PLATFORM "win32"
+#endif
diff --git a/lmms/include/visualization_widget.h b/lmms/include/visualization_widget.h
new file mode 100644
index 0000000..8b8c3fd
--- /dev/null
+++ b/lmms/include/visualization_widget.h
@@ -0,0 +1,69 @@
+/*
+ * visualization_widget.h - widget for visualization of sound-data
+ *
+ * Copyright (c) 2005-2008 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of"the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#ifndef _VISUALIZATION_WIDGET
+#define _VISUALIZATION_WIDGET
+
+#include <QtGui/QWidget>
+#include <QtGui/QPixmap>
+
+#include "Mixer.h"
+
+
+class visualizationWidget : public QWidget
+{
+	Q_OBJECT
+public:
+	enum visualizationTypes
+	{
+		Simple		// add more here
+	} ;
+
+	visualizationWidget( const QPixmap & _bg, QWidget * _parent,
+					visualizationTypes _vtype = Simple );
+	virtual ~visualizationWidget();
+
+	void setActive( bool _active );
+
+
+protected:
+	virtual void paintEvent( QPaintEvent * _pe );
+	virtual void mousePressEvent( QMouseEvent * _me );
+
+
+protected slots:
+	void updateAudioBuffer();
+
+
+private:
+	QPixmap s_background;
+	QPointF * m_points;
+
+	sampleFrame * m_buffer;
+	bool m_active;
+
+} ;
+
+#endif
diff --git a/lmms/include/volume.h b/lmms/include/volume.h
new file mode 100644
index 0000000..383dc24
--- /dev/null
+++ b/lmms/include/volume.h
@@ -0,0 +1,43 @@
+/*
+ * volume.h - declaration of some constants and types, concerning the volume
+ *            of a note
+ *
+ * Copyright (c) 2004-2014 Tobias Doerffel <tobydox/at/users.sourceforge.net>
+ * 
+ * This file is part of Linux MultiMedia Studio - http://lmms.sourceforge.net
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program (see COPYING); if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef _VOLUME_H
+#define _VOLUME_H
+
+#include "lmmsconfig.h"
+
+#include "lmms_basics.h"
+#include "Midi.h"
+
+const volume_t MinVolume = 0;
+const volume_t MaxVolume = 200;
+const volume_t DefaultVolume = 100;
+
+typedef struct
+{
+	float vol[2];
+} stereoVolumeVector;
+
+#endif
-- 
1.9.1
